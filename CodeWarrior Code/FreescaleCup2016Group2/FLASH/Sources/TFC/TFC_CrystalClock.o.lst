   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"TFC_CrystalClock.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.fll_freq.part.0,"ax",%progbits
  18              		.align	2
  19              		.code	16
  20              		.thumb_func
  22              	fll_freq.part.0:
  23              	.LFB28:
  24              		.file 1 "../Sources/TFC/TFC_CrystalClock.c"
   1:../Sources/TFC/TFC_CrystalClock.c **** 
   2:../Sources/TFC/TFC_CrystalClock.c **** 
   3:../Sources/TFC/TFC_CrystalClock.c **** #include "TFC\TFC.h"
   4:../Sources/TFC/TFC_CrystalClock.c **** 
   5:../Sources/TFC/TFC_CrystalClock.c **** /* For some reason CW needs to have cw.h explicitly included here for
   6:../Sources/TFC/TFC_CrystalClock.c ****  * the code relocation of set_sys_dividers() to work correctly even
   7:../Sources/TFC/TFC_CrystalClock.c ****  * though common.h should pull in cw.h.
   8:../Sources/TFC/TFC_CrystalClock.c ****  */
   9:../Sources/TFC/TFC_CrystalClock.c **** #if (defined(CW))
  10:../Sources/TFC/TFC_CrystalClock.c **** 	#include "cw.h"
  11:../Sources/TFC/TFC_CrystalClock.c **** #endif
  12:../Sources/TFC/TFC_CrystalClock.c **** 
  13:../Sources/TFC/TFC_CrystalClock.c **** // Constants for use in pll_init
  14:../Sources/TFC/TFC_CrystalClock.c **** #define NO_OSCINIT 0
  15:../Sources/TFC/TFC_CrystalClock.c **** #define OSCINIT 1
  16:../Sources/TFC/TFC_CrystalClock.c **** 
  17:../Sources/TFC/TFC_CrystalClock.c **** #define OSC_0 0
  18:../Sources/TFC/TFC_CrystalClock.c **** #define OSC_1 1
  19:../Sources/TFC/TFC_CrystalClock.c **** 
  20:../Sources/TFC/TFC_CrystalClock.c **** #define LOW_POWER 0
  21:../Sources/TFC/TFC_CrystalClock.c **** #define HIGH_GAIN 1
  22:../Sources/TFC/TFC_CrystalClock.c **** 
  23:../Sources/TFC/TFC_CrystalClock.c **** #define CANNED_OSC  0
  24:../Sources/TFC/TFC_CrystalClock.c **** #define CRYSTAL 1
  25:../Sources/TFC/TFC_CrystalClock.c **** 
  26:../Sources/TFC/TFC_CrystalClock.c **** #define PLL_0 0
  27:../Sources/TFC/TFC_CrystalClock.c **** #define PLL_1 1
  28:../Sources/TFC/TFC_CrystalClock.c **** 
  29:../Sources/TFC/TFC_CrystalClock.c **** #define PLL_ONLY 0
  30:../Sources/TFC/TFC_CrystalClock.c **** #define MCGOUT 1
  31:../Sources/TFC/TFC_CrystalClock.c **** 
  32:../Sources/TFC/TFC_CrystalClock.c **** // MCG Mode defines
  33:../Sources/TFC/TFC_CrystalClock.c **** 
  34:../Sources/TFC/TFC_CrystalClock.c **** #define BLPI 1
  35:../Sources/TFC/TFC_CrystalClock.c **** #define FBI  2
  36:../Sources/TFC/TFC_CrystalClock.c **** #define FEI  3
  37:../Sources/TFC/TFC_CrystalClock.c **** #define FEE  4
  38:../Sources/TFC/TFC_CrystalClock.c **** #define FBE  5
  39:../Sources/TFC/TFC_CrystalClock.c **** #define BLPE 6
  40:../Sources/TFC/TFC_CrystalClock.c **** #define PBE  7
  41:../Sources/TFC/TFC_CrystalClock.c **** #define PEE  8
  42:../Sources/TFC/TFC_CrystalClock.c **** 
  43:../Sources/TFC/TFC_CrystalClock.c **** // IRC defines
  44:../Sources/TFC/TFC_CrystalClock.c **** #define SLOW_IRC 0
  45:../Sources/TFC/TFC_CrystalClock.c **** #define FAST_IRC 1
  46:../Sources/TFC/TFC_CrystalClock.c **** 
  47:../Sources/TFC/TFC_CrystalClock.c **** 
  48:../Sources/TFC/TFC_CrystalClock.c **** unsigned char fll_rtc_init(unsigned char, unsigned char);
  49:../Sources/TFC/TFC_CrystalClock.c **** 
  50:../Sources/TFC/TFC_CrystalClock.c **** 
  51:../Sources/TFC/TFC_CrystalClock.c **** // prototypes
  52:../Sources/TFC/TFC_CrystalClock.c **** void rtc_as_refclk(void);
  53:../Sources/TFC/TFC_CrystalClock.c **** int fee_fei(int slow_irc_freq);
  54:../Sources/TFC/TFC_CrystalClock.c **** int fei_fbe(int crystal_val, unsigned char hgo_val, unsigned char erefs_val);
  55:../Sources/TFC/TFC_CrystalClock.c **** int fbe_fei(int slow_irc_freq);
  56:../Sources/TFC/TFC_CrystalClock.c **** int fei_fbi(int irc_freq, unsigned char irc_select);
  57:../Sources/TFC/TFC_CrystalClock.c **** int fbi_fei(int slow_irc_freq);
  58:../Sources/TFC/TFC_CrystalClock.c **** int fbe_pbe(int crystal_val, signed char prdiv_val, signed char vdiv_val);
  59:../Sources/TFC/TFC_CrystalClock.c **** int pbe_pee(int crystal_val);
  60:../Sources/TFC/TFC_CrystalClock.c **** int pee_pbe(int crystal_val);
  61:../Sources/TFC/TFC_CrystalClock.c **** int pbe_fbe(int crystal_val);
  62:../Sources/TFC/TFC_CrystalClock.c **** int fbe_fbi(int irc_freq, unsigned char irc_select);
  63:../Sources/TFC/TFC_CrystalClock.c **** int fbi_fbe(int crystal_val, unsigned char hgo_val, unsigned char erefs_val);
  64:../Sources/TFC/TFC_CrystalClock.c **** int fbi_fee(int crystal_val, unsigned char hgo_val, unsigned char erefs_val);
  65:../Sources/TFC/TFC_CrystalClock.c **** int fbe_fee(int crystal_val);
  66:../Sources/TFC/TFC_CrystalClock.c **** int fee_fbe(int crystal_val);
  67:../Sources/TFC/TFC_CrystalClock.c **** int pbe_blpe(int crystal_val);
  68:../Sources/TFC/TFC_CrystalClock.c **** int blpe_pbe(int crystal_val, signed char prdiv_val, signed char vdiv_val);
  69:../Sources/TFC/TFC_CrystalClock.c **** int blpe_fbe(int crystal_val);
  70:../Sources/TFC/TFC_CrystalClock.c **** int fbi_blpi(int irc_freq, unsigned char irc_select);
  71:../Sources/TFC/TFC_CrystalClock.c **** int blpi_fbi(int irc_freq, unsigned char irc_select);
  72:../Sources/TFC/TFC_CrystalClock.c **** int fei_fee(int crystal_val, unsigned char hgo_val, unsigned char erefs_val);
  73:../Sources/TFC/TFC_CrystalClock.c **** int fee_fbi(int irc_freq, unsigned char irc_select);
  74:../Sources/TFC/TFC_CrystalClock.c **** int fbe_blpe(int crystal_val);
  75:../Sources/TFC/TFC_CrystalClock.c **** 
  76:../Sources/TFC/TFC_CrystalClock.c **** int pll_init(int crystal_val, unsigned char hgo_val, unsigned char erefs_val, signed char prdiv_val
  77:../Sources/TFC/TFC_CrystalClock.c **** 
  78:../Sources/TFC/TFC_CrystalClock.c **** int fll_freq(int fll_ref);
  79:../Sources/TFC/TFC_CrystalClock.c **** unsigned char what_mcg_mode(void);
  80:../Sources/TFC/TFC_CrystalClock.c **** unsigned char atc(unsigned char irc_select, int irc_freq, int mcg_out_freq);
  81:../Sources/TFC/TFC_CrystalClock.c **** void clk_monitor_0(unsigned char en_dis);
  82:../Sources/TFC/TFC_CrystalClock.c **** 
  83:../Sources/TFC/TFC_CrystalClock.c **** 
  84:../Sources/TFC/TFC_CrystalClock.c **** 
  85:../Sources/TFC/TFC_CrystalClock.c **** 
  86:../Sources/TFC/TFC_CrystalClock.c **** // global variables
  87:../Sources/TFC/TFC_CrystalClock.c **** extern int core_clk_khz;
  88:../Sources/TFC/TFC_CrystalClock.c **** char drs_val, dmx32_val;
  89:../Sources/TFC/TFC_CrystalClock.c **** 
  90:../Sources/TFC/TFC_CrystalClock.c **** 
  91:../Sources/TFC/TFC_CrystalClock.c **** 
  92:../Sources/TFC/TFC_CrystalClock.c **** 
  93:../Sources/TFC/TFC_CrystalClock.c **** /*****************************************************************************
  94:../Sources/TFC/TFC_CrystalClock.c ****  * @name     pll_init
  95:../Sources/TFC/TFC_CrystalClock.c ****  *
  96:../Sources/TFC/TFC_CrystalClock.c ****  * @brief:   Initialization of the MCU.
  97:../Sources/TFC/TFC_CrystalClock.c ****  *
  98:../Sources/TFC/TFC_CrystalClock.c ****  * @param  : None
  99:../Sources/TFC/TFC_CrystalClock.c ****  *
 100:../Sources/TFC/TFC_CrystalClock.c ****  * @return : None
 101:../Sources/TFC/TFC_CrystalClock.c ****  *****************************************************************************
 102:../Sources/TFC/TFC_CrystalClock.c ****  * It will configure the MCU to disable STOP and COP Modules.
 103:../Sources/TFC/TFC_CrystalClock.c ****  * It also set the MCG configuration and bus clock frequency.
 104:../Sources/TFC/TFC_CrystalClock.c ****  ****************************************************************************/
 105:../Sources/TFC/TFC_CrystalClock.c **** void TFC_InitClock()
 106:../Sources/TFC/TFC_CrystalClock.c **** {
 107:../Sources/TFC/TFC_CrystalClock.c **** 	pll_init(8000000, LOW_POWER, CRYSTAL, 4, 24, MCGOUT);
 108:../Sources/TFC/TFC_CrystalClock.c ****     	
 109:../Sources/TFC/TFC_CrystalClock.c ****     /************* USB Part **********************/
 110:../Sources/TFC/TFC_CrystalClock.c ****    	/*********************************************/   
 111:../Sources/TFC/TFC_CrystalClock.c ****    //	SIM_CLKDIV2 &= (uint32_t)(~(SIM_CLKDIV2_USBFRAC_MASK | SIM_CLKDIV2_USBDIV_MASK));
 112:../Sources/TFC/TFC_CrystalClock.c **** 
 113:../Sources/TFC/TFC_CrystalClock.c ****     /* Configure USBFRAC = 0, USBDIV = 0 => frq(USBout) = 1 / 1 * frq(PLLin) */
 114:../Sources/TFC/TFC_CrystalClock.c ****    	//SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(1);
 115:../Sources/TFC/TFC_CrystalClock.c ****    			    
 116:../Sources/TFC/TFC_CrystalClock.c ****    	/* Configure USB to be clocked from PLL */
 117:../Sources/TFC/TFC_CrystalClock.c ****    	//SIM_SOPT2  |= (SIM_SOPT2_USBSRC_MASK | SIM_SOPT2_PLLFLLSEL_MASK);
 118:../Sources/TFC/TFC_CrystalClock.c **** 
 119:../Sources/TFC/TFC_CrystalClock.c ****    	/* Enable USB-OTG IP clocking */
 120:../Sources/TFC/TFC_CrystalClock.c ****    	//SIM_SCGC4 |= (SIM_SCGC4_USBOTG_MASK); 
 121:../Sources/TFC/TFC_CrystalClock.c ****     			    
 122:../Sources/TFC/TFC_CrystalClock.c ****     			/* Configure enable USB regulator for device */
 123:../Sources/TFC/TFC_CrystalClock.c ****    //SIM_SOPT1 |= SIM_SOPT1_USBREGEN_MASK;
 124:../Sources/TFC/TFC_CrystalClock.c ****    			    
 125:../Sources/TFC/TFC_CrystalClock.c ****    //NVICICER2 |= (1<<9);	/* Clear any pending interrupts on USB */
 126:../Sources/TFC/TFC_CrystalClock.c **** //   NVICISER2 |= (1<<9);	/* Enable interrupts from USB module */	 
 127:../Sources/TFC/TFC_CrystalClock.c **** 
 128:../Sources/TFC/TFC_CrystalClock.c ****     	
 129:../Sources/TFC/TFC_CrystalClock.c ****     /* Now running PEE Mode */
 130:../Sources/TFC/TFC_CrystalClock.c **** 
 131:../Sources/TFC/TFC_CrystalClock.c **** 
 132:../Sources/TFC/TFC_CrystalClock.c **** }
 133:../Sources/TFC/TFC_CrystalClock.c **** 
 134:../Sources/TFC/TFC_CrystalClock.c **** 
 135:../Sources/TFC/TFC_CrystalClock.c **** /*
 136:../Sources/TFC/TFC_CrystalClock.c ****  * File:    mcg.c
 137:../Sources/TFC/TFC_CrystalClock.c ****  *
 138:../Sources/TFC/TFC_CrystalClock.c ****  * MCG drivers for Freescale Kinetis L - series devices
 139:../Sources/TFC/TFC_CrystalClock.c ****  * Notes:
 140:../Sources/TFC/TFC_CrystalClock.c ****  * Assumes the MCG mode is in the default FEI mode out of reset
 141:../Sources/TFC/TFC_CrystalClock.c ****  */
 142:../Sources/TFC/TFC_CrystalClock.c **** 
 143:../Sources/TFC/TFC_CrystalClock.c **** #include "derivative.h"
 144:../Sources/TFC/TFC_CrystalClock.c **** #include "TFC\TFC_CrystalClock.h"
 145:../Sources/TFC/TFC_CrystalClock.c **** 
 146:../Sources/TFC/TFC_CrystalClock.c **** 
 147:../Sources/TFC/TFC_CrystalClock.c **** 
 148:../Sources/TFC/TFC_CrystalClock.c **** 
 149:../Sources/TFC/TFC_CrystalClock.c **** /*********************************************************************************************/
 150:../Sources/TFC/TFC_CrystalClock.c **** /* Functon name : pll_init
 151:../Sources/TFC/TFC_CrystalClock.c ****  *
 152:../Sources/TFC/TFC_CrystalClock.c ****  * Mode transition: Option to move from FEI to PEE mode or to just initialize the PLL
 153:../Sources/TFC/TFC_CrystalClock.c ****  *
 154:../Sources/TFC/TFC_CrystalClock.c ****  * This function initializess PLL0. Either OSC0 is selected for the
 155:../Sources/TFC/TFC_CrystalClock.c ****  * reference clock source. The oscillators can be configured to use a crystal or take in an
 156:../Sources/TFC/TFC_CrystalClock.c ****  * external square wave clock.
 157:../Sources/TFC/TFC_CrystalClock.c ****  * Using the function parameter names the PLL frequency is calculated as follows:
 158:../Sources/TFC/TFC_CrystalClock.c ****  * PLL freq = ((crystal_val / prdiv_val) * vdiv_val)
 159:../Sources/TFC/TFC_CrystalClock.c ****  * Refer to the readme file in the mcg driver directory for examples of pll_init configurations.
 160:../Sources/TFC/TFC_CrystalClock.c ****  * All parameters must be provided, for example crystal_val must be provided even if the
 161:../Sources/TFC/TFC_CrystalClock.c ****  * oscillator associated with that parameter is already initialized.
 162:../Sources/TFC/TFC_CrystalClock.c ****  * The various passed parameters are checked to ensure they are within the allowed range. If any
 163:../Sources/TFC/TFC_CrystalClock.c ****  * of these checks fail the driver will exit and return a fail/error code. An error code will
 164:../Sources/TFC/TFC_CrystalClock.c ****  * also be returned if any error occurs during the PLL initialization sequence. Refer to the
 165:../Sources/TFC/TFC_CrystalClock.c ****  * readme file in the mcg driver directory for a list of all these codes.
 166:../Sources/TFC/TFC_CrystalClock.c ****  *
 167:../Sources/TFC/TFC_CrystalClock.c ****  * Parameters: crystal_val - external clock frequency in Hz either from a crystal or square
 168:../Sources/TFC/TFC_CrystalClock.c ****  *                           wave clock source
 169:../Sources/TFC/TFC_CrystalClock.c ****  *             hgo_val     - selects whether low power or high gain mode is selected
 170:../Sources/TFC/TFC_CrystalClock.c ****  *                           for the crystal oscillator. This has no meaning if an
 171:../Sources/TFC/TFC_CrystalClock.c ****  *                           external clock is used.
 172:../Sources/TFC/TFC_CrystalClock.c ****  *             erefs_val   - selects external clock (=0) or crystal osc (=1)
 173:../Sources/TFC/TFC_CrystalClock.c ****  *             prdiv_val   - value to divide the external clock source by to create the desired
 174:../Sources/TFC/TFC_CrystalClock.c ****  *                           PLL reference clock frequency
 175:../Sources/TFC/TFC_CrystalClock.c ****  *             vdiv_val    - value to multiply the PLL reference clock frequency by
 176:../Sources/TFC/TFC_CrystalClock.c ****  *             mcgout_select  - 0 if the PLL is just to be enabled, non-zero if the PLL is used
 177:../Sources/TFC/TFC_CrystalClock.c ****  *                              to provide the MCGOUT clock for the system.
 178:../Sources/TFC/TFC_CrystalClock.c ****  *
 179:../Sources/TFC/TFC_CrystalClock.c ****  * Return value : PLL frequency (Hz) or error code
 180:../Sources/TFC/TFC_CrystalClock.c ****  */
 181:../Sources/TFC/TFC_CrystalClock.c **** 
 182:../Sources/TFC/TFC_CrystalClock.c **** int pll_init(int crystal_val, unsigned char hgo_val, unsigned char erefs_val, signed char prdiv_val
 183:../Sources/TFC/TFC_CrystalClock.c **** {
 184:../Sources/TFC/TFC_CrystalClock.c ****   unsigned char frdiv_val;
 185:../Sources/TFC/TFC_CrystalClock.c ****   unsigned char temp_reg;
 186:../Sources/TFC/TFC_CrystalClock.c ****   unsigned char prdiv, vdiv;
 187:../Sources/TFC/TFC_CrystalClock.c ****   short i;
 188:../Sources/TFC/TFC_CrystalClock.c ****   int ref_freq;
 189:../Sources/TFC/TFC_CrystalClock.c ****   int pll_freq;
 190:../Sources/TFC/TFC_CrystalClock.c **** 
 191:../Sources/TFC/TFC_CrystalClock.c ****   // check if in FEI mode
 192:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 193:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 194:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selecte
 195:../Sources/TFC/TFC_CrystalClock.c ****   {
 196:../Sources/TFC/TFC_CrystalClock.c ****     return 0x1;                                                     // return error code
 197:../Sources/TFC/TFC_CrystalClock.c ****   }
 198:../Sources/TFC/TFC_CrystalClock.c **** 
 199:../Sources/TFC/TFC_CrystalClock.c ****   // check external frequency is less than the maximum frequency
 200:../Sources/TFC/TFC_CrystalClock.c ****   if  (crystal_val > 50000000) {return 0x21;}
 201:../Sources/TFC/TFC_CrystalClock.c **** 
 202:../Sources/TFC/TFC_CrystalClock.c ****   // check crystal frequency is within spec. if crystal osc is being used as PLL ref
 203:../Sources/TFC/TFC_CrystalClock.c ****   if (erefs_val)
 204:../Sources/TFC/TFC_CrystalClock.c ****   {
 205:../Sources/TFC/TFC_CrystalClock.c ****     if ((crystal_val < 3000000) || (crystal_val > 32000000)) {return 0x22;} // return 1 if one of t
 206:../Sources/TFC/TFC_CrystalClock.c ****   }
 207:../Sources/TFC/TFC_CrystalClock.c **** 
 208:../Sources/TFC/TFC_CrystalClock.c ****   // make sure HGO will never be greater than 1. Could return an error instead if desired.
 209:../Sources/TFC/TFC_CrystalClock.c ****   if (hgo_val > 0)
 210:../Sources/TFC/TFC_CrystalClock.c ****   {
 211:../Sources/TFC/TFC_CrystalClock.c ****     hgo_val = 1; // force hgo_val to 1 if > 0
 212:../Sources/TFC/TFC_CrystalClock.c ****   }
 213:../Sources/TFC/TFC_CrystalClock.c **** 
 214:../Sources/TFC/TFC_CrystalClock.c ****   // Check PLL divider settings are within spec.
 215:../Sources/TFC/TFC_CrystalClock.c ****   if ((prdiv_val < 1) || (prdiv_val > 25)) {return 0x41;}
 216:../Sources/TFC/TFC_CrystalClock.c ****   if ((vdiv_val < 24) || (vdiv_val > 50)) {return 0x42;}
 217:../Sources/TFC/TFC_CrystalClock.c **** 
 218:../Sources/TFC/TFC_CrystalClock.c ****   // Check PLL reference clock frequency is within spec.
 219:../Sources/TFC/TFC_CrystalClock.c ****   ref_freq = crystal_val / prdiv_val;
 220:../Sources/TFC/TFC_CrystalClock.c ****   if ((ref_freq < 2000000) || (ref_freq > 4000000)) {return 0x43;}
 221:../Sources/TFC/TFC_CrystalClock.c **** 
 222:../Sources/TFC/TFC_CrystalClock.c ****   // Check PLL output frequency is within spec.
 223:../Sources/TFC/TFC_CrystalClock.c ****   pll_freq = (crystal_val / prdiv_val) * vdiv_val;
 224:../Sources/TFC/TFC_CrystalClock.c ****   if ((pll_freq < 48000000) || (pll_freq > 100000000)) {return 0x45;}
 225:../Sources/TFC/TFC_CrystalClock.c **** 
 226:../Sources/TFC/TFC_CrystalClock.c ****   // configure the MCG_C2 register
 227:../Sources/TFC/TFC_CrystalClock.c ****   // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the
 228:../Sources/TFC/TFC_CrystalClock.c ****   // it still needs to be set correctly even if the oscillator is not being used
 229:../Sources/TFC/TFC_CrystalClock.c ****       
 230:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C2;
 231:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
 232:../Sources/TFC/TFC_CrystalClock.c ****     
 233:../Sources/TFC/TFC_CrystalClock.c ****   if (crystal_val <= 8000000)
 234:../Sources/TFC/TFC_CrystalClock.c ****   {
 235:../Sources/TFC/TFC_CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 236:../Sources/TFC/TFC_CrystalClock.c ****   }
 237:../Sources/TFC/TFC_CrystalClock.c ****   else
 238:../Sources/TFC/TFC_CrystalClock.c ****   {
 239:../Sources/TFC/TFC_CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 240:../Sources/TFC/TFC_CrystalClock.c ****   }
 241:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C2 = temp_reg;
 242:../Sources/TFC/TFC_CrystalClock.c ****   
 243:../Sources/TFC/TFC_CrystalClock.c ****   // determine FRDIV based on reference clock frequency
 244:../Sources/TFC/TFC_CrystalClock.c ****   // since the external frequency has already been checked only the maximum frequency for each FRDI
 245:../Sources/TFC/TFC_CrystalClock.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 246:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
 247:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
 248:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
 249:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
 250:../Sources/TFC/TFC_CrystalClock.c ****   else {frdiv_val = 5;}
 251:../Sources/TFC/TFC_CrystalClock.c **** 
 252:../Sources/TFC/TFC_CrystalClock.c ****   // Select external oscillator and Reference Divider and clear IREFS to start ext osc
 253:../Sources/TFC/TFC_CrystalClock.c ****   // If IRCLK is required it must be enabled outside of this driver, existing state will be maintai
 254:../Sources/TFC/TFC_CrystalClock.c ****   // CLKS=2, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
 255:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C1;
 256:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these
 257:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
 258:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 = temp_reg;
 259:../Sources/TFC/TFC_CrystalClock.c **** 
 260:../Sources/TFC/TFC_CrystalClock.c ****   // if the external oscillator is used need to wait for OSCINIT to set
 261:../Sources/TFC/TFC_CrystalClock.c ****   if (erefs_val)
 262:../Sources/TFC/TFC_CrystalClock.c ****   {
 263:../Sources/TFC/TFC_CrystalClock.c ****     for (i = 0 ; i < 20000 ; i++)
 264:../Sources/TFC/TFC_CrystalClock.c ****     {
 265:../Sources/TFC/TFC_CrystalClock.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 266:../Sources/TFC/TFC_CrystalClock.c ****     }
 267:../Sources/TFC/TFC_CrystalClock.c ****   if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with error
 268:../Sources/TFC/TFC_CrystalClock.c ****   }
 269:../Sources/TFC/TFC_CrystalClock.c **** 
 270:../Sources/TFC/TFC_CrystalClock.c ****   // wait for Reference clock Status bit to clear
 271:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 272:../Sources/TFC/TFC_CrystalClock.c ****   {
 273:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 274:../Sources/TFC/TFC_CrystalClock.c ****   }
 275:../Sources/TFC/TFC_CrystalClock.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
 276:../Sources/TFC/TFC_CrystalClock.c **** 
 277:../Sources/TFC/TFC_CrystalClock.c ****   // Wait for clock status bits to show clock source is ext ref clk
 278:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 279:../Sources/TFC/TFC_CrystalClock.c ****   {
 280:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 281:../Sources/TFC/TFC_CrystalClock.c ****   }
 282:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
 283:../Sources/TFC/TFC_CrystalClock.c **** 
 284:../Sources/TFC/TFC_CrystalClock.c ****   // Now in FBE
 285:../Sources/TFC/TFC_CrystalClock.c ****   // It is recommended that the clock monitor is enabled when using an external clock as the clock 
 286:../Sources/TFC/TFC_CrystalClock.c ****   // It is enabled here but can be removed if this is not required.
 287:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 |= MCG_C6_CME0_MASK;
 288:../Sources/TFC/TFC_CrystalClock.c ****   
 289:../Sources/TFC/TFC_CrystalClock.c ****   // Configure PLL
 290:../Sources/TFC/TFC_CrystalClock.c ****   // Configure MCG_C5
 291:../Sources/TFC/TFC_CrystalClock.c ****   // If the PLL is to run in STOP mode then the PLLSTEN bit needs to be OR'ed in here or in user co
 292:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C5;
 293:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~MCG_C5_PRDIV0_MASK;
 294:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);    //set PLL ref divider
 295:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C5 = temp_reg;
 296:../Sources/TFC/TFC_CrystalClock.c **** 
 297:../Sources/TFC/TFC_CrystalClock.c ****   // Configure MCG_C6
 298:../Sources/TFC/TFC_CrystalClock.c ****   // The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk
 299:../Sources/TFC/TFC_CrystalClock.c ****   // The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6
 300:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C6; // store present C6 value
 301:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 302:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 303:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 = temp_reg; // update MCG_C6
 304:../Sources/TFC/TFC_CrystalClock.c **** 
 305:../Sources/TFC/TFC_CrystalClock.c ****   // wait for PLLST status bit to set
 306:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 307:../Sources/TFC/TFC_CrystalClock.c ****   {
 308:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 309:../Sources/TFC/TFC_CrystalClock.c ****   }
 310:../Sources/TFC/TFC_CrystalClock.c ****   if (!(MCG_S & MCG_S_PLLST_MASK)) return 0x16; // check bit is really set and return with error if
 311:../Sources/TFC/TFC_CrystalClock.c **** 
 312:../Sources/TFC/TFC_CrystalClock.c ****   // Wait for LOCK bit to set
 313:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 4000 ; i++)
 314:../Sources/TFC/TFC_CrystalClock.c ****   {
 315:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 316:../Sources/TFC/TFC_CrystalClock.c ****   }
 317:../Sources/TFC/TFC_CrystalClock.c ****   if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if
 318:../Sources/TFC/TFC_CrystalClock.c **** 
 319:../Sources/TFC/TFC_CrystalClock.c ****   // Use actual PLL settings to calculate PLL frequency
 320:../Sources/TFC/TFC_CrystalClock.c ****   prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 321:../Sources/TFC/TFC_CrystalClock.c ****   vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 322:../Sources/TFC/TFC_CrystalClock.c **** 
 323:../Sources/TFC/TFC_CrystalClock.c ****   // now in PBE
 324:../Sources/TFC/TFC_CrystalClock.c **** 
 325:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to switch CLKS mux to select PLL as MCG_OUT
 326:../Sources/TFC/TFC_CrystalClock.c **** 
 327:../Sources/TFC/TFC_CrystalClock.c ****   // Wait for clock status bits to update
 328:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 329:../Sources/TFC/TFC_CrystalClock.c ****   {
 330:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break; // jump out early if CLKST
 331:../Sources/TFC/TFC_CrystalClock.c ****   }
 332:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) return 0x1B; // check CLKST is set 
 333:../Sources/TFC/TFC_CrystalClock.c **** 
 334:../Sources/TFC/TFC_CrystalClock.c ****   // Now in PEE
 335:../Sources/TFC/TFC_CrystalClock.c ****   
 336:../Sources/TFC/TFC_CrystalClock.c ****   return ((crystal_val / prdiv) * vdiv); //MCGOUT equals PLL output frequency
 337:../Sources/TFC/TFC_CrystalClock.c **** } // pll_init
 338:../Sources/TFC/TFC_CrystalClock.c **** 
 339:../Sources/TFC/TFC_CrystalClock.c **** 
 340:../Sources/TFC/TFC_CrystalClock.c **** 
 341:../Sources/TFC/TFC_CrystalClock.c **** 
 342:../Sources/TFC/TFC_CrystalClock.c **** /********************************************************************/
 343:../Sources/TFC/TFC_CrystalClock.c **** 
 344:../Sources/TFC/TFC_CrystalClock.c **** int pee_pbe(int crystal_val)
 345:../Sources/TFC/TFC_CrystalClock.c **** {
 346:../Sources/TFC/TFC_CrystalClock.c ****   short i;
 347:../Sources/TFC/TFC_CrystalClock.c ****   
 348:../Sources/TFC/TFC_CrystalClock.c **** // Check MCG is in PEE mode
 349:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selcted
 350:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 351:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_PLLST_MASK)))                                    // check PLLS mux has selecte
 352:../Sources/TFC/TFC_CrystalClock.c ****   {
 353:../Sources/TFC/TFC_CrystalClock.c ****     return 0x8;                                                       // return error code
 354:../Sources/TFC/TFC_CrystalClock.c ****   } 
 355:../Sources/TFC/TFC_CrystalClock.c ****   
 356:../Sources/TFC/TFC_CrystalClock.c **** // As we are running from the PLL by default the PLL and external clock settings are valid
 357:../Sources/TFC/TFC_CrystalClock.c **** // To move to PBE from PEE simply requires the switching of the CLKS mux to select the ext clock 
 358:../Sources/TFC/TFC_CrystalClock.c **** // As CLKS is already 0 the CLKS value can simply be OR'ed into the register 
 359:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 |= MCG_C1_CLKS(2); // switch CLKS mux to select external reference clock as MCG_OUT
 360:../Sources/TFC/TFC_CrystalClock.c ****   
 361:../Sources/TFC/TFC_CrystalClock.c **** // Wait for clock status bits to update 
 362:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 363:../Sources/TFC/TFC_CrystalClock.c ****   {
 364:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 365:../Sources/TFC/TFC_CrystalClock.c ****   }
 366:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
 367:../Sources/TFC/TFC_CrystalClock.c **** 
 368:../Sources/TFC/TFC_CrystalClock.c **** // Now in PBE mode  
 369:../Sources/TFC/TFC_CrystalClock.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency
 370:../Sources/TFC/TFC_CrystalClock.c **** } // pee_pbe
 371:../Sources/TFC/TFC_CrystalClock.c **** 
 372:../Sources/TFC/TFC_CrystalClock.c **** 
 373:../Sources/TFC/TFC_CrystalClock.c **** int pbe_pee(int crystal_val)
 374:../Sources/TFC/TFC_CrystalClock.c **** {
 375:../Sources/TFC/TFC_CrystalClock.c ****   unsigned char prdiv, vdiv;
 376:../Sources/TFC/TFC_CrystalClock.c ****   short i;
 377:../Sources/TFC/TFC_CrystalClock.c **** 
 378:../Sources/TFC/TFC_CrystalClock.c ****   // Check MCG is in PBE mode
 379:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 380:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 381:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_PLLST_MASK) &&                                   // check PLLS mux has selecte
 382:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 383:../Sources/TFC/TFC_CrystalClock.c ****   {
 384:../Sources/TFC/TFC_CrystalClock.c ****     return 0x7;                                                       // return error code
 385:../Sources/TFC/TFC_CrystalClock.c ****   }
 386:../Sources/TFC/TFC_CrystalClock.c **** 
 387:../Sources/TFC/TFC_CrystalClock.c ****   // As the PLL settings have already been checked when PBE mode was enterred they are not checked 
 388:../Sources/TFC/TFC_CrystalClock.c **** 
 389:../Sources/TFC/TFC_CrystalClock.c ****   // Check the PLL state before transitioning to PEE mode
 390:../Sources/TFC/TFC_CrystalClock.c ****   
 391:../Sources/TFC/TFC_CrystalClock.c ****   // Check LOCK bit is set before transitioning MCG to PLL output (already checked in fbe_pbe but g
 392:../Sources/TFC/TFC_CrystalClock.c ****   // to re-check before switch to use PLL)
 393:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 394:../Sources/TFC/TFC_CrystalClock.c ****   {
 395:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 396:../Sources/TFC/TFC_CrystalClock.c ****   }
 397:../Sources/TFC/TFC_CrystalClock.c ****   if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if
 398:../Sources/TFC/TFC_CrystalClock.c ****   // Use actual PLL settings to calculate PLL frequency
 399:../Sources/TFC/TFC_CrystalClock.c ****   prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 400:../Sources/TFC/TFC_CrystalClock.c ****   vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 401:../Sources/TFC/TFC_CrystalClock.c ****   
 402:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to switch CLKS mux to select PLL as MCG_OUT
 403:../Sources/TFC/TFC_CrystalClock.c **** 
 404:../Sources/TFC/TFC_CrystalClock.c ****   // Wait for clock status bits to update
 405:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 406:../Sources/TFC/TFC_CrystalClock.c ****   {
 407:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break; // jump out early if CLKST
 408:../Sources/TFC/TFC_CrystalClock.c ****   }
 409:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) return 0x1B; // check CLKST is set 
 410:../Sources/TFC/TFC_CrystalClock.c **** 
 411:../Sources/TFC/TFC_CrystalClock.c ****   // Now in PEE
 412:../Sources/TFC/TFC_CrystalClock.c ****   return ((crystal_val / prdiv) * vdiv); //MCGOUT equals PLL output frequency
 413:../Sources/TFC/TFC_CrystalClock.c ****   
 414:../Sources/TFC/TFC_CrystalClock.c **** }  // pbe_pee
 415:../Sources/TFC/TFC_CrystalClock.c **** 
 416:../Sources/TFC/TFC_CrystalClock.c **** 
 417:../Sources/TFC/TFC_CrystalClock.c **** int pbe_fbe(int crystal_val)
 418:../Sources/TFC/TFC_CrystalClock.c **** {
 419:../Sources/TFC/TFC_CrystalClock.c ****   short i;
 420:../Sources/TFC/TFC_CrystalClock.c ****   
 421:../Sources/TFC/TFC_CrystalClock.c **** // Check MCG is in PBE mode
 422:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 423:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 424:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_PLLST_MASK) &&                                   // check PLLS mux has selecte
 425:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 426:../Sources/TFC/TFC_CrystalClock.c ****   {
 427:../Sources/TFC/TFC_CrystalClock.c ****     return 0x7;                                                       // return error code
 428:../Sources/TFC/TFC_CrystalClock.c ****   }
 429:../Sources/TFC/TFC_CrystalClock.c **** 
 430:../Sources/TFC/TFC_CrystalClock.c **** // As we are running from the ext clock, by default the external clock settings are valid
 431:../Sources/TFC/TFC_CrystalClock.c **** // To move to FBE from PBE simply requires the switching of the PLLS mux to disable the PLL 
 432:../Sources/TFC/TFC_CrystalClock.c ****   
 433:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 &= ~MCG_C6_PLLS_MASK; // clear PLLS to disable PLL, still clocked from ext ref clk
 434:../Sources/TFC/TFC_CrystalClock.c ****   
 435:../Sources/TFC/TFC_CrystalClock.c **** // wait for PLLST status bit to set
 436:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 437:../Sources/TFC/TFC_CrystalClock.c ****   {
 438:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_PLLST_MASK)) break; // jump out early if PLLST clears before loop finishes
 439:../Sources/TFC/TFC_CrystalClock.c ****   }
 440:../Sources/TFC/TFC_CrystalClock.c ****   if (MCG_S & MCG_S_PLLST_MASK) return 0x15; // check bit is really clear and return with error if 
 441:../Sources/TFC/TFC_CrystalClock.c **** 
 442:../Sources/TFC/TFC_CrystalClock.c **** // Now in FBE mode  
 443:../Sources/TFC/TFC_CrystalClock.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency 
 444:../Sources/TFC/TFC_CrystalClock.c **** } // pbe_fbe
 445:../Sources/TFC/TFC_CrystalClock.c **** 
 446:../Sources/TFC/TFC_CrystalClock.c **** 
 447:../Sources/TFC/TFC_CrystalClock.c **** /********************************************************************/
 448:../Sources/TFC/TFC_CrystalClock.c **** /* Functon name : fbe_pbe
 449:../Sources/TFC/TFC_CrystalClock.c ****  *
 450:../Sources/TFC/TFC_CrystalClock.c ****  * Mode transition: FBE to PBE mode
 451:../Sources/TFC/TFC_CrystalClock.c ****  *
 452:../Sources/TFC/TFC_CrystalClock.c ****  * This function transitions the MCG from FBE mode to PBE mode. 
 453:../Sources/TFC/TFC_CrystalClock.c ****  * This function presently only supports OSC0 and PLL0. Support for OSC1 and PLL1 will be added soo
 454:../Sources/TFC/TFC_CrystalClock.c ****  * The function requires the desired OSC and PLL be passed in to it for compatibility with the
 455:../Sources/TFC/TFC_CrystalClock.c ****  * future support of OSC/PLL selection
 456:../Sources/TFC/TFC_CrystalClock.c ****  *
 457:../Sources/TFC/TFC_CrystalClock.c ****  * Parameters: crystal_val - external clock frequency in Hz
 458:../Sources/TFC/TFC_CrystalClock.c ****  *             prdiv_val   - value to divide the external clock source by to create the desired
 459:../Sources/TFC/TFC_CrystalClock.c ****  *                           PLL reference clock frequency
 460:../Sources/TFC/TFC_CrystalClock.c ****  *             vdiv_val    - value to multiply the PLL reference clock frequency by
 461:../Sources/TFC/TFC_CrystalClock.c ****  *
 462:../Sources/TFC/TFC_CrystalClock.c ****  * Return value : MCGCLKOUT frequency (Hz) or error code
 463:../Sources/TFC/TFC_CrystalClock.c ****  */
 464:../Sources/TFC/TFC_CrystalClock.c **** int fbe_pbe(int crystal_val, signed char prdiv_val, signed char vdiv_val)
 465:../Sources/TFC/TFC_CrystalClock.c **** {
 466:../Sources/TFC/TFC_CrystalClock.c ****   unsigned char temp_reg;
 467:../Sources/TFC/TFC_CrystalClock.c ****   short i;
 468:../Sources/TFC/TFC_CrystalClock.c ****   int pll_freq;
 469:../Sources/TFC/TFC_CrystalClock.c ****   
 470:../Sources/TFC/TFC_CrystalClock.c **** // Check MCG is in FBE mode
 471:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 472:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 473:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 474:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 475:../Sources/TFC/TFC_CrystalClock.c ****   {
 476:../Sources/TFC/TFC_CrystalClock.c ****     return 0x4;                                                       // return error code
 477:../Sources/TFC/TFC_CrystalClock.c ****   }
 478:../Sources/TFC/TFC_CrystalClock.c ****   
 479:../Sources/TFC/TFC_CrystalClock.c **** // As the external frequency has already been checked when FBE mode was enterred it is not checked 
 480:../Sources/TFC/TFC_CrystalClock.c **** 
 481:../Sources/TFC/TFC_CrystalClock.c **** // Check PLL divider settings are within spec.
 482:../Sources/TFC/TFC_CrystalClock.c ****   if ((prdiv_val < 1) || (prdiv_val > 25)) {return 0x41;}
 483:../Sources/TFC/TFC_CrystalClock.c ****   if ((vdiv_val < 24) || (vdiv_val > 50)) {return 0x42;} 
 484:../Sources/TFC/TFC_CrystalClock.c ****   
 485:../Sources/TFC/TFC_CrystalClock.c **** // Check PLL reference clock frequency is within spec.
 486:../Sources/TFC/TFC_CrystalClock.c ****   if (((crystal_val / prdiv_val) < 2000000) || ((crystal_val / prdiv_val) > 4000000)) {return 0x43;
 487:../Sources/TFC/TFC_CrystalClock.c ****        
 488:../Sources/TFC/TFC_CrystalClock.c **** // Check PLL output frequency is within spec.
 489:../Sources/TFC/TFC_CrystalClock.c ****   pll_freq = (crystal_val / prdiv_val) * vdiv_val;
 490:../Sources/TFC/TFC_CrystalClock.c ****   if ((pll_freq < 48000000) || (pll_freq > 100000000)) {return 0x45;}
 491:../Sources/TFC/TFC_CrystalClock.c **** 
 492:../Sources/TFC/TFC_CrystalClock.c ****   // Configure MCG_C5
 493:../Sources/TFC/TFC_CrystalClock.c ****   // If the PLL is to run in STOP mode then the PLLSTEN bit needs to be OR'ed in here or in user co
 494:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C5;
 495:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~MCG_C5_PRDIV0_MASK;
 496:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);    //set PLL ref divider
 497:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C5 = temp_reg;
 498:../Sources/TFC/TFC_CrystalClock.c **** 
 499:../Sources/TFC/TFC_CrystalClock.c ****   // Configure MCG_C6
 500:../Sources/TFC/TFC_CrystalClock.c ****   // The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk 
 501:../Sources/TFC/TFC_CrystalClock.c ****   // The clock monitor is not enabled here as it has likely been enabled previously and so the valu
 502:../Sources/TFC/TFC_CrystalClock.c ****   // is not altered here.
 503:../Sources/TFC/TFC_CrystalClock.c ****   // The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6
 504:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C6; // store present C6 value
 505:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 506:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 507:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 = temp_reg; // update MCG_C6
 508:../Sources/TFC/TFC_CrystalClock.c ****   
 509:../Sources/TFC/TFC_CrystalClock.c ****   // wait for PLLST status bit to set
 510:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 511:../Sources/TFC/TFC_CrystalClock.c ****   {
 512:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 513:../Sources/TFC/TFC_CrystalClock.c ****   }
 514:../Sources/TFC/TFC_CrystalClock.c ****   if (!(MCG_S & MCG_S_PLLST_MASK)) return 0x16; // check bit is really set and return with error if
 515:../Sources/TFC/TFC_CrystalClock.c **** 
 516:../Sources/TFC/TFC_CrystalClock.c ****   // Wait for LOCK bit to set
 517:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 518:../Sources/TFC/TFC_CrystalClock.c ****   {
 519:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 520:../Sources/TFC/TFC_CrystalClock.c ****   }
 521:../Sources/TFC/TFC_CrystalClock.c ****   if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if
 522:../Sources/TFC/TFC_CrystalClock.c ****     
 523:../Sources/TFC/TFC_CrystalClock.c **** // now in PBE 
 524:../Sources/TFC/TFC_CrystalClock.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency
 525:../Sources/TFC/TFC_CrystalClock.c **** } // fbe_pbe
 526:../Sources/TFC/TFC_CrystalClock.c **** 
 527:../Sources/TFC/TFC_CrystalClock.c **** 
 528:../Sources/TFC/TFC_CrystalClock.c **** int pbe_blpe(int crystal_val)
 529:../Sources/TFC/TFC_CrystalClock.c **** {
 530:../Sources/TFC/TFC_CrystalClock.c **** // Check MCG is in PBE mode
 531:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 532:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 533:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_PLLST_MASK) &&                                   // check PLLS mux has selecte
 534:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 535:../Sources/TFC/TFC_CrystalClock.c ****   {
 536:../Sources/TFC/TFC_CrystalClock.c ****     return 0x7;                                                       // return error code
 537:../Sources/TFC/TFC_CrystalClock.c ****   }
 538:../Sources/TFC/TFC_CrystalClock.c ****   
 539:../Sources/TFC/TFC_CrystalClock.c **** // To enter BLPE mode the LP bit must be set, disabling the PLL  
 540:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C2 |= MCG_C2_LP_MASK;
 541:../Sources/TFC/TFC_CrystalClock.c ****   
 542:../Sources/TFC/TFC_CrystalClock.c **** // Now in BLPE mode
 543:../Sources/TFC/TFC_CrystalClock.c ****   return crystal_val;  
 544:../Sources/TFC/TFC_CrystalClock.c **** } // pbe_blpe
 545:../Sources/TFC/TFC_CrystalClock.c **** 
 546:../Sources/TFC/TFC_CrystalClock.c **** 
 547:../Sources/TFC/TFC_CrystalClock.c **** // ************************************************************************************************
 548:../Sources/TFC/TFC_CrystalClock.c **** // Since PBE mode can be enterred via FBE -> BLPE modes, it cannot be assumed that the PLL has been
 549:../Sources/TFC/TFC_CrystalClock.c **** // previously configured correctly. That is why this general purpose driver has the PLL settings as
 550:../Sources/TFC/TFC_CrystalClock.c **** // passed parameters.
 551:../Sources/TFC/TFC_CrystalClock.c **** // ************************************************************************************************
 552:../Sources/TFC/TFC_CrystalClock.c **** int blpe_pbe(int crystal_val, signed char prdiv_val, signed char vdiv_val)
 553:../Sources/TFC/TFC_CrystalClock.c **** {
 554:../Sources/TFC/TFC_CrystalClock.c ****   unsigned char temp_reg;
 555:../Sources/TFC/TFC_CrystalClock.c ****   short i;
 556:../Sources/TFC/TFC_CrystalClock.c ****   
 557:../Sources/TFC/TFC_CrystalClock.c **** // Check MCG is in BLPE mode
 558:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 559:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 560:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_C2 & MCG_C2_LP_MASK)))                                     // check MCG_C2[LP] bit is se
 561:../Sources/TFC/TFC_CrystalClock.c ****   {
 562:../Sources/TFC/TFC_CrystalClock.c ****     return 0x6;                                                       // return error code
 563:../Sources/TFC/TFC_CrystalClock.c ****   }
 564:../Sources/TFC/TFC_CrystalClock.c ****   
 565:../Sources/TFC/TFC_CrystalClock.c **** // As the external frequency has already been checked when FBE mode was enterred it is not checked 
 566:../Sources/TFC/TFC_CrystalClock.c **** 
 567:../Sources/TFC/TFC_CrystalClock.c **** // Check PLL divider settings are within spec.
 568:../Sources/TFC/TFC_CrystalClock.c ****   if ((prdiv_val < 1) || (prdiv_val > 25)) {return 0x41;}
 569:../Sources/TFC/TFC_CrystalClock.c ****   if ((vdiv_val < 24) || (vdiv_val > 50)) {return 0x42;} 
 570:../Sources/TFC/TFC_CrystalClock.c ****   
 571:../Sources/TFC/TFC_CrystalClock.c **** // Check PLL reference clock frequency is within spec.
 572:../Sources/TFC/TFC_CrystalClock.c ****   if (((crystal_val / prdiv_val) < 2000000) || ((crystal_val / prdiv_val) > 4000000)) {return 0x43;
 573:../Sources/TFC/TFC_CrystalClock.c ****        
 574:../Sources/TFC/TFC_CrystalClock.c **** // If PRDIV, VDIV and the PLL ref clock are in spec. then the PLL frequency is within spec.
 575:../Sources/TFC/TFC_CrystalClock.c **** 
 576:../Sources/TFC/TFC_CrystalClock.c **** // Configure MCG_C5
 577:../Sources/TFC/TFC_CrystalClock.c **** // If the PLL is to run in STOP mode then the PLLSTEN bit needs to be OR'ed in here or in user code
 578:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C5;
 579:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~MCG_C5_PRDIV0_MASK;
 580:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);    //set PLL ref divider
 581:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C5 = temp_reg;
 582:../Sources/TFC/TFC_CrystalClock.c **** 
 583:../Sources/TFC/TFC_CrystalClock.c **** // Configure MCG_C6
 584:../Sources/TFC/TFC_CrystalClock.c **** // The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk 
 585:../Sources/TFC/TFC_CrystalClock.c **** // The clock monitor is not enabled here as it has likely been enabled previously and so the value 
 586:../Sources/TFC/TFC_CrystalClock.c **** // is not altered here.
 587:../Sources/TFC/TFC_CrystalClock.c **** // The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6
 588:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C6; // store present C6 value
 589:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 590:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 591:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 = temp_reg; // update MCG_C6
 592:../Sources/TFC/TFC_CrystalClock.c ****   
 593:../Sources/TFC/TFC_CrystalClock.c **** // Now that PLL is configured, LP is cleared to enable the PLL
 594:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C2 &= ~MCG_C2_LP_MASK;
 595:../Sources/TFC/TFC_CrystalClock.c ****   
 596:../Sources/TFC/TFC_CrystalClock.c **** // wait for PLLST status bit to set
 597:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 598:../Sources/TFC/TFC_CrystalClock.c ****   {
 599:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 600:../Sources/TFC/TFC_CrystalClock.c ****   }
 601:../Sources/TFC/TFC_CrystalClock.c ****   if (!(MCG_S & MCG_S_PLLST_MASK)) return 0x16; // check bit is really set and return with error if
 602:../Sources/TFC/TFC_CrystalClock.c **** 
 603:../Sources/TFC/TFC_CrystalClock.c **** // Wait for LOCK bit to set
 604:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 605:../Sources/TFC/TFC_CrystalClock.c ****   {
 606:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 607:../Sources/TFC/TFC_CrystalClock.c ****   }
 608:../Sources/TFC/TFC_CrystalClock.c ****   if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if
 609:../Sources/TFC/TFC_CrystalClock.c **** 
 610:../Sources/TFC/TFC_CrystalClock.c **** // now in PBE 
 611:../Sources/TFC/TFC_CrystalClock.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency  
 612:../Sources/TFC/TFC_CrystalClock.c **** } // blpe_pbe
 613:../Sources/TFC/TFC_CrystalClock.c **** 
 614:../Sources/TFC/TFC_CrystalClock.c **** 
 615:../Sources/TFC/TFC_CrystalClock.c **** int blpe_fbe(int crystal_val)
 616:../Sources/TFC/TFC_CrystalClock.c **** {
 617:../Sources/TFC/TFC_CrystalClock.c ****   short i;
 618:../Sources/TFC/TFC_CrystalClock.c ****   
 619:../Sources/TFC/TFC_CrystalClock.c **** // Check MCG is in BLPE mode
 620:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 621:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 622:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_C2 & MCG_C2_LP_MASK)))                                     // check MCG_C2[LP] bit is se
 623:../Sources/TFC/TFC_CrystalClock.c ****   {
 624:../Sources/TFC/TFC_CrystalClock.c ****     return 0x6;                                                       // return error code
 625:../Sources/TFC/TFC_CrystalClock.c ****   }
 626:../Sources/TFC/TFC_CrystalClock.c ****  
 627:../Sources/TFC/TFC_CrystalClock.c **** // To move from BLPE to FBE the PLLS mux be set to select the FLL output and the LP bit must be cle
 628:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 &= ~MCG_C6_PLLS_MASK; // clear PLLS to select the FLL
 629:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C2 &= ~MCG_C2_LP_MASK; // clear LP bit  
 630:../Sources/TFC/TFC_CrystalClock.c **** 
 631:../Sources/TFC/TFC_CrystalClock.c **** // wait for PLLST status bit to clear
 632:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 633:../Sources/TFC/TFC_CrystalClock.c ****   {
 634:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_PLLST_MASK)) break; // jump out early if PLLST clears before loop finishes
 635:../Sources/TFC/TFC_CrystalClock.c ****   }
 636:../Sources/TFC/TFC_CrystalClock.c ****   if (MCG_S & MCG_S_PLLST_MASK) return 0x15; // check bit is really clear and return with error if 
 637:../Sources/TFC/TFC_CrystalClock.c ****   
 638:../Sources/TFC/TFC_CrystalClock.c **** // now in FBE mode
 639:../Sources/TFC/TFC_CrystalClock.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency     
 640:../Sources/TFC/TFC_CrystalClock.c **** } // blpe_fbe
 641:../Sources/TFC/TFC_CrystalClock.c **** 
 642:../Sources/TFC/TFC_CrystalClock.c **** 
 643:../Sources/TFC/TFC_CrystalClock.c **** int fbe_blpe(int crystal_val)
 644:../Sources/TFC/TFC_CrystalClock.c **** {
 645:../Sources/TFC/TFC_CrystalClock.c **** // Check MCG is in FBE mode
 646:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 647:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 648:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 649:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 650:../Sources/TFC/TFC_CrystalClock.c ****   {
 651:../Sources/TFC/TFC_CrystalClock.c ****     return 0x4;                                                       // return error code
 652:../Sources/TFC/TFC_CrystalClock.c ****   }
 653:../Sources/TFC/TFC_CrystalClock.c ****  
 654:../Sources/TFC/TFC_CrystalClock.c **** // To move from FBE to BLPE the LP bit must be set
 655:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C2 |= MCG_C2_LP_MASK; // set LP bit  
 656:../Sources/TFC/TFC_CrystalClock.c ****  
 657:../Sources/TFC/TFC_CrystalClock.c **** // now in FBE mode
 658:../Sources/TFC/TFC_CrystalClock.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency     
 659:../Sources/TFC/TFC_CrystalClock.c **** } // fbe_blpe
 660:../Sources/TFC/TFC_CrystalClock.c **** 
 661:../Sources/TFC/TFC_CrystalClock.c **** 
 662:../Sources/TFC/TFC_CrystalClock.c **** int fbe_fei(int slow_irc_freq)
 663:../Sources/TFC/TFC_CrystalClock.c **** {
 664:../Sources/TFC/TFC_CrystalClock.c ****   unsigned char temp_reg;
 665:../Sources/TFC/TFC_CrystalClock.c ****   short i;
 666:../Sources/TFC/TFC_CrystalClock.c ****   int mcg_out;
 667:../Sources/TFC/TFC_CrystalClock.c ****   
 668:../Sources/TFC/TFC_CrystalClock.c **** // Check MCG is in FBE mode
 669:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 670:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 671:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 672:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 673:../Sources/TFC/TFC_CrystalClock.c ****   {
 674:../Sources/TFC/TFC_CrystalClock.c ****     return 0x4;                                                       // return error code
 675:../Sources/TFC/TFC_CrystalClock.c ****   }
 676:../Sources/TFC/TFC_CrystalClock.c **** 
 677:../Sources/TFC/TFC_CrystalClock.c **** // Check IRC frequency is within spec.
 678:../Sources/TFC/TFC_CrystalClock.c ****   if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
 679:../Sources/TFC/TFC_CrystalClock.c ****   {
 680:../Sources/TFC/TFC_CrystalClock.c ****     return 0x31;
 681:../Sources/TFC/TFC_CrystalClock.c ****   }
 682:../Sources/TFC/TFC_CrystalClock.c ****   
 683:../Sources/TFC/TFC_CrystalClock.c **** // Check resulting FLL frequency 
 684:../Sources/TFC/TFC_CrystalClock.c ****   mcg_out = fll_freq(slow_irc_freq); 
 685:../Sources/TFC/TFC_CrystalClock.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
 686:../Sources/TFC/TFC_CrystalClock.c **** 
 687:../Sources/TFC/TFC_CrystalClock.c **** // Need to make sure the clockmonitor is disabled before moving to an "internal" clock mode
 688:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 &= ~MCG_C6_CME0_MASK; //This assumes OSC0 is used as the external clock source
 689:../Sources/TFC/TFC_CrystalClock.c ****   
 690:../Sources/TFC/TFC_CrystalClock.c **** // Move to FEI by setting CLKS to 0 and enabling the slow IRC as the FLL reference clock
 691:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C1;
 692:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS to select FLL output
 693:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= MCG_C1_IREFS_MASK; // select internal reference clock
 694:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 = temp_reg; // update MCG_C1 
 695:../Sources/TFC/TFC_CrystalClock.c ****   
 696:../Sources/TFC/TFC_CrystalClock.c **** // wait for Reference clock Status bit to set
 697:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 698:../Sources/TFC/TFC_CrystalClock.c ****   {
 699:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
 700:../Sources/TFC/TFC_CrystalClock.c ****   }
 701:../Sources/TFC/TFC_CrystalClock.c ****   if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error i
 702:../Sources/TFC/TFC_CrystalClock.c ****   
 703:../Sources/TFC/TFC_CrystalClock.c **** // Wait for clock status bits to show clock source is ext ref clk
 704:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 705:../Sources/TFC/TFC_CrystalClock.c ****   {
 706:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST
 707:../Sources/TFC/TFC_CrystalClock.c ****   }
 708:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check EXT CLK is re
 709:../Sources/TFC/TFC_CrystalClock.c **** 
 710:../Sources/TFC/TFC_CrystalClock.c **** // Now in FEI mode
 711:../Sources/TFC/TFC_CrystalClock.c ****   return mcg_out;
 712:../Sources/TFC/TFC_CrystalClock.c **** } // fbe_fei
 713:../Sources/TFC/TFC_CrystalClock.c **** 
 714:../Sources/TFC/TFC_CrystalClock.c **** 
 715:../Sources/TFC/TFC_CrystalClock.c **** /********************************************************************/
 716:../Sources/TFC/TFC_CrystalClock.c **** /* Functon name : fei_fbe
 717:../Sources/TFC/TFC_CrystalClock.c ****  *
 718:../Sources/TFC/TFC_CrystalClock.c ****  * Mode transition: FEI to FBE mode
 719:../Sources/TFC/TFC_CrystalClock.c ****  *
 720:../Sources/TFC/TFC_CrystalClock.c ****  * This function transitions the MCG from FEI mode to FBE mode. This is
 721:../Sources/TFC/TFC_CrystalClock.c ****  * achieved by setting the MCG_C2[LP] bit. There is no status bit to 
 722:../Sources/TFC/TFC_CrystalClock.c ****  * check so 0 is always returned if the function was called with the MCG
 723:../Sources/TFC/TFC_CrystalClock.c ****  * in FBI mode. The MCGCLKOUT frequency does not change
 724:../Sources/TFC/TFC_CrystalClock.c ****  *
 725:../Sources/TFC/TFC_CrystalClock.c ****  * Parameters: crystal_val - external clock frequency in Hz
 726:../Sources/TFC/TFC_CrystalClock.c ****  *             hgo_val     - selects whether low power or high gain mode is selected
 727:../Sources/TFC/TFC_CrystalClock.c ****  *                           for the crystal oscillator. This has no meaning if an 
 728:../Sources/TFC/TFC_CrystalClock.c ****  *                           external clock is used.
 729:../Sources/TFC/TFC_CrystalClock.c ****  *             erefs_val   - selects external clock (=0) or crystal osc (=1)
 730:../Sources/TFC/TFC_CrystalClock.c ****  *
 731:../Sources/TFC/TFC_CrystalClock.c ****  * Return value : MCGCLKOUT frequency (Hz) or error code
 732:../Sources/TFC/TFC_CrystalClock.c ****  */
 733:../Sources/TFC/TFC_CrystalClock.c **** int fei_fbe(int crystal_val, unsigned char hgo_val, unsigned char erefs_val)
 734:../Sources/TFC/TFC_CrystalClock.c **** {
 735:../Sources/TFC/TFC_CrystalClock.c ****   unsigned char frdiv_val;
 736:../Sources/TFC/TFC_CrystalClock.c ****   unsigned char temp_reg;
 737:../Sources/TFC/TFC_CrystalClock.c ****   short i;
 738:../Sources/TFC/TFC_CrystalClock.c ****   
 739:../Sources/TFC/TFC_CrystalClock.c **** // check if in FEI mode
 740:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 741:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 742:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selecte
 743:../Sources/TFC/TFC_CrystalClock.c ****   {
 744:../Sources/TFC/TFC_CrystalClock.c ****     return 0x1;                                                     // return error code
 745:../Sources/TFC/TFC_CrystalClock.c ****   }
 746:../Sources/TFC/TFC_CrystalClock.c **** 
 747:../Sources/TFC/TFC_CrystalClock.c **** // check external frequency is less than the maximum frequency
 748:../Sources/TFC/TFC_CrystalClock.c ****   if  (crystal_val > 50000000) {return 0x21;}
 749:../Sources/TFC/TFC_CrystalClock.c ****   
 750:../Sources/TFC/TFC_CrystalClock.c **** // check crystal frequency is within spec. if crystal osc is being used
 751:../Sources/TFC/TFC_CrystalClock.c ****   if (erefs_val)
 752:../Sources/TFC/TFC_CrystalClock.c ****   {
 753:../Sources/TFC/TFC_CrystalClock.c ****     if ((crystal_val < 30000) ||
 754:../Sources/TFC/TFC_CrystalClock.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 755:../Sources/TFC/TFC_CrystalClock.c ****         (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal op
 756:../Sources/TFC/TFC_CrystalClock.c ****   }
 757:../Sources/TFC/TFC_CrystalClock.c **** 
 758:../Sources/TFC/TFC_CrystalClock.c **** // make sure HGO will never be greater than 1. Could return an error instead if desired.  
 759:../Sources/TFC/TFC_CrystalClock.c ****   if (hgo_val > 0)
 760:../Sources/TFC/TFC_CrystalClock.c ****   {
 761:../Sources/TFC/TFC_CrystalClock.c ****     hgo_val = 1; // force hgo_val to 1 if > 0
 762:../Sources/TFC/TFC_CrystalClock.c ****   }
 763:../Sources/TFC/TFC_CrystalClock.c **** 
 764:../Sources/TFC/TFC_CrystalClock.c **** // configure the MCG_C2 register
 765:../Sources/TFC/TFC_CrystalClock.c **** // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the F
 766:../Sources/TFC/TFC_CrystalClock.c **** // it still needs to be set correctly even if the oscillator is not being used
 767:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C2;
 768:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
 769:../Sources/TFC/TFC_CrystalClock.c ****   if (crystal_val <= 40000)
 770:../Sources/TFC/TFC_CrystalClock.c ****   {
 771:../Sources/TFC/TFC_CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 772:../Sources/TFC/TFC_CrystalClock.c ****   }
 773:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 8000000)
 774:../Sources/TFC/TFC_CrystalClock.c ****   {
 775:../Sources/TFC/TFC_CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 776:../Sources/TFC/TFC_CrystalClock.c ****   }
 777:../Sources/TFC/TFC_CrystalClock.c ****   else
 778:../Sources/TFC/TFC_CrystalClock.c ****   {
 779:../Sources/TFC/TFC_CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 780:../Sources/TFC/TFC_CrystalClock.c ****   }
 781:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C2 = temp_reg;
 782:../Sources/TFC/TFC_CrystalClock.c **** // determine FRDIV based on reference clock frequency
 783:../Sources/TFC/TFC_CrystalClock.c **** // since the external frequency has already been checked only the maximum frequency for each FRDIV 
 784:../Sources/TFC/TFC_CrystalClock.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 785:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
 786:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
 787:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
 788:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
 789:../Sources/TFC/TFC_CrystalClock.c ****   else {frdiv_val = 5;}
 790:../Sources/TFC/TFC_CrystalClock.c ****   
 791:../Sources/TFC/TFC_CrystalClock.c **** // Select external oscilator and Reference Divider and clear IREFS to start ext osc
 792:../Sources/TFC/TFC_CrystalClock.c **** // If IRCLK is required it must be enabled outside of this driver, existing state will be maintaine
 793:../Sources/TFC/TFC_CrystalClock.c **** // CLKS=2, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
 794:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C1;
 795:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these
 796:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
 797:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 = temp_reg;
 798:../Sources/TFC/TFC_CrystalClock.c **** 
 799:../Sources/TFC/TFC_CrystalClock.c **** // if the external oscillator is used need to wait for OSCINIT to set
 800:../Sources/TFC/TFC_CrystalClock.c ****   if (erefs_val)
 801:../Sources/TFC/TFC_CrystalClock.c ****   {
 802:../Sources/TFC/TFC_CrystalClock.c ****     for (i = 0 ; i < 10000 ; i++)
 803:../Sources/TFC/TFC_CrystalClock.c ****     {
 804:../Sources/TFC/TFC_CrystalClock.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 805:../Sources/TFC/TFC_CrystalClock.c ****     }
 806:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with err
 807:../Sources/TFC/TFC_CrystalClock.c ****   }
 808:../Sources/TFC/TFC_CrystalClock.c **** 
 809:../Sources/TFC/TFC_CrystalClock.c **** // wait for Reference clock Status bit to clear
 810:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 811:../Sources/TFC/TFC_CrystalClock.c ****   {
 812:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 813:../Sources/TFC/TFC_CrystalClock.c ****   }
 814:../Sources/TFC/TFC_CrystalClock.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
 815:../Sources/TFC/TFC_CrystalClock.c ****   
 816:../Sources/TFC/TFC_CrystalClock.c **** // Wait for clock status bits to show clock source is ext ref clk
 817:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 818:../Sources/TFC/TFC_CrystalClock.c ****   {
 819:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 820:../Sources/TFC/TFC_CrystalClock.c ****   }
 821:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
 822:../Sources/TFC/TFC_CrystalClock.c ****  
 823:../Sources/TFC/TFC_CrystalClock.c **** // Now in FBE  
 824:../Sources/TFC/TFC_CrystalClock.c **** // It is recommended that the clock monitor is enabled when using an external clock as the clock so
 825:../Sources/TFC/TFC_CrystalClock.c **** // It is enabled here but can be removed if this is not required.
 826:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 |= MCG_C6_CME0_MASK;
 827:../Sources/TFC/TFC_CrystalClock.c ****   
 828:../Sources/TFC/TFC_CrystalClock.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency
 829:../Sources/TFC/TFC_CrystalClock.c **** } // fei_fbe
 830:../Sources/TFC/TFC_CrystalClock.c **** 
 831:../Sources/TFC/TFC_CrystalClock.c **** 
 832:../Sources/TFC/TFC_CrystalClock.c **** int fbe_fee(int crystal_val)
 833:../Sources/TFC/TFC_CrystalClock.c **** {
 834:../Sources/TFC/TFC_CrystalClock.c ****   short i, fll_ref_freq;
 835:../Sources/TFC/TFC_CrystalClock.c ****   int mcg_out;
 836:../Sources/TFC/TFC_CrystalClock.c **** 
 837:../Sources/TFC/TFC_CrystalClock.c **** // Check MCG is in FBE mode
 838:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 839:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 840:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 841:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 842:../Sources/TFC/TFC_CrystalClock.c ****   {
 843:../Sources/TFC/TFC_CrystalClock.c ****     return 0x4;                                                       // return error code
 844:../Sources/TFC/TFC_CrystalClock.c ****   }
 845:../Sources/TFC/TFC_CrystalClock.c ****   
 846:../Sources/TFC/TFC_CrystalClock.c ****   // The FLL ref clk divide value depends on FRDIV and the RANGE value
 847:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
 848:../Sources/TFC/TFC_CrystalClock.c ****   {
 849:../Sources/TFC/TFC_CrystalClock.c ****     fll_ref_freq = (crystal_val / (32 << ((MCG_C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT)));
 850:../Sources/TFC/TFC_CrystalClock.c ****   }
 851:../Sources/TFC/TFC_CrystalClock.c ****   else
 852:../Sources/TFC/TFC_CrystalClock.c ****   {
 853:../Sources/TFC/TFC_CrystalClock.c ****     fll_ref_freq = ((crystal_val) / (1 << (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT)))
 854:../Sources/TFC/TFC_CrystalClock.c ****   }
 855:../Sources/TFC/TFC_CrystalClock.c ****   
 856:../Sources/TFC/TFC_CrystalClock.c **** // Check resulting FLL frequency 
 857:../Sources/TFC/TFC_CrystalClock.c ****   mcg_out = fll_freq(fll_ref_freq); // FLL reference frequency calculated from ext ref freq and FRD
 858:../Sources/TFC/TFC_CrystalClock.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
 859:../Sources/TFC/TFC_CrystalClock.c ****   
 860:../Sources/TFC/TFC_CrystalClock.c **** // Clear CLKS field to switch CLKS mux to select FLL output
 861:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to select FLL output
 862:../Sources/TFC/TFC_CrystalClock.c **** 
 863:../Sources/TFC/TFC_CrystalClock.c **** // Wait for clock status bits to show clock source is FLL
 864:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 865:../Sources/TFC/TFC_CrystalClock.c ****   {
 866:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST
 867:../Sources/TFC/TFC_CrystalClock.c ****   }
 868:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check FLL is really
 869:../Sources/TFC/TFC_CrystalClock.c ****   
 870:../Sources/TFC/TFC_CrystalClock.c **** // Now in FEE mode
 871:../Sources/TFC/TFC_CrystalClock.c ****   return mcg_out;
 872:../Sources/TFC/TFC_CrystalClock.c **** } // fbe_fee
 873:../Sources/TFC/TFC_CrystalClock.c **** 
 874:../Sources/TFC/TFC_CrystalClock.c **** 
 875:../Sources/TFC/TFC_CrystalClock.c **** int fee_fbe(int crystal_val)
 876:../Sources/TFC/TFC_CrystalClock.c **** { 
 877:../Sources/TFC/TFC_CrystalClock.c ****   short i;
 878:../Sources/TFC/TFC_CrystalClock.c ****   
 879:../Sources/TFC/TFC_CrystalClock.c **** // Check MCG is in FEE mode
 880:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 881:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 882:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selecte
 883:../Sources/TFC/TFC_CrystalClock.c ****   {
 884:../Sources/TFC/TFC_CrystalClock.c ****     return 0x2;                                                       // return error code
 885:../Sources/TFC/TFC_CrystalClock.c ****   }
 886:../Sources/TFC/TFC_CrystalClock.c ****   
 887:../Sources/TFC/TFC_CrystalClock.c **** // Set CLKS field to 2 to switch CLKS mux to select ext ref clock
 888:../Sources/TFC/TFC_CrystalClock.c **** // MCG is current in FEE mode so CLKS field = 0 so can just OR in new value
 889:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 |= MCG_C1_CLKS(2); // set CLKS to select ext ref clock
 890:../Sources/TFC/TFC_CrystalClock.c **** 
 891:../Sources/TFC/TFC_CrystalClock.c **** /// Wait for clock status bits to show clock source is ext ref clk
 892:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 893:../Sources/TFC/TFC_CrystalClock.c ****   {
 894:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 895:../Sources/TFC/TFC_CrystalClock.c ****   }
 896:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
 897:../Sources/TFC/TFC_CrystalClock.c ****   
 898:../Sources/TFC/TFC_CrystalClock.c **** // Now in FBE mode
 899:../Sources/TFC/TFC_CrystalClock.c ****   return crystal_val;
 900:../Sources/TFC/TFC_CrystalClock.c **** } // fee_fbe
 901:../Sources/TFC/TFC_CrystalClock.c **** 
 902:../Sources/TFC/TFC_CrystalClock.c **** 
 903:../Sources/TFC/TFC_CrystalClock.c **** int fbe_fbi(int irc_freq, unsigned char irc_select)
 904:../Sources/TFC/TFC_CrystalClock.c **** {
 905:../Sources/TFC/TFC_CrystalClock.c ****   unsigned char temp_reg;
 906:../Sources/TFC/TFC_CrystalClock.c ****   unsigned char fcrdiv_val;
 907:../Sources/TFC/TFC_CrystalClock.c ****   short i;
 908:../Sources/TFC/TFC_CrystalClock.c ****   
 909:../Sources/TFC/TFC_CrystalClock.c **** // Check MCG is in FBE mode
 910:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 911:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 912:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 913:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 914:../Sources/TFC/TFC_CrystalClock.c ****   {
 915:../Sources/TFC/TFC_CrystalClock.c ****     return 0x4;                                                       // return error code
 916:../Sources/TFC/TFC_CrystalClock.c ****   }
 917:../Sources/TFC/TFC_CrystalClock.c **** 
 918:../Sources/TFC/TFC_CrystalClock.c **** // Check that the irc frequency matches the selected IRC 
 919:../Sources/TFC/TFC_CrystalClock.c ****   if (!(irc_select))
 920:../Sources/TFC/TFC_CrystalClock.c ****   {    
 921:../Sources/TFC/TFC_CrystalClock.c ****     if ((irc_freq < 31250) || (irc_freq > 39063)) {return 0x31;}
 922:../Sources/TFC/TFC_CrystalClock.c ****   }
 923:../Sources/TFC/TFC_CrystalClock.c ****   else
 924:../Sources/TFC/TFC_CrystalClock.c ****   {
 925:../Sources/TFC/TFC_CrystalClock.c ****     if ((irc_freq < 3000000) || (irc_freq > 5000000)) {return 0x32;} // Fast IRC freq
 926:../Sources/TFC/TFC_CrystalClock.c ****   }
 927:../Sources/TFC/TFC_CrystalClock.c ****   
 928:../Sources/TFC/TFC_CrystalClock.c **** // Select the required IRC
 929:../Sources/TFC/TFC_CrystalClock.c ****   if (irc_select)
 930:../Sources/TFC/TFC_CrystalClock.c ****   {
 931:../Sources/TFC/TFC_CrystalClock.c ****     MCG_C2 |= MCG_C2_IRCS_MASK; // select fast IRC by setting IRCS
 932:../Sources/TFC/TFC_CrystalClock.c ****   }
 933:../Sources/TFC/TFC_CrystalClock.c ****   else
 934:../Sources/TFC/TFC_CrystalClock.c ****   {
 935:../Sources/TFC/TFC_CrystalClock.c ****     MCG_C2 &= ~MCG_C2_IRCS_MASK; // select slow IRC by clearing IRCS
 936:../Sources/TFC/TFC_CrystalClock.c ****   }
 937:../Sources/TFC/TFC_CrystalClock.c ****   
 938:../Sources/TFC/TFC_CrystalClock.c **** // Make sure the clock monitor is disabled before switching modes otherwise it will trigger
 939:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 &= ~MCG_C6_CME0_MASK;
 940:../Sources/TFC/TFC_CrystalClock.c ****   
 941:../Sources/TFC/TFC_CrystalClock.c **** // Select the IRC as the CLKS mux selection
 942:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C1;
 943:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~MCG_C1_CLKS_MASK;                    // clear CLKS bits 
 944:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= (MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK); // select IRC as MCGOUT and enable IREFS
 945:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 = temp_reg; // update MCG_C1
 946:../Sources/TFC/TFC_CrystalClock.c ****   
 947:../Sources/TFC/TFC_CrystalClock.c **** // wait until internal reference switches to requested irc.
 948:../Sources/TFC/TFC_CrystalClock.c ****   if (!(irc_select))
 949:../Sources/TFC/TFC_CrystalClock.c ****   {
 950:../Sources/TFC/TFC_CrystalClock.c ****     for (i = 0 ; i < 2000 ; i++)
 951:../Sources/TFC/TFC_CrystalClock.c ****     {
 952:../Sources/TFC/TFC_CrystalClock.c ****       if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishe
 953:../Sources/TFC/TFC_CrystalClock.c ****     }
 954:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_IRCST_MASK) return 0x13; // check bit is really clear and return with error i
 955:../Sources/TFC/TFC_CrystalClock.c ****   }
 956:../Sources/TFC/TFC_CrystalClock.c ****   else
 957:../Sources/TFC/TFC_CrystalClock.c ****   {
 958:../Sources/TFC/TFC_CrystalClock.c ****     for (i = 0 ; i < 2000 ; i++)
 959:../Sources/TFC/TFC_CrystalClock.c ****     {
 960:../Sources/TFC/TFC_CrystalClock.c ****       if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
 961:../Sources/TFC/TFC_CrystalClock.c ****     }
 962:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_IRCST_MASK)) return 0x14; // check bit is really set and return with error 
 963:../Sources/TFC/TFC_CrystalClock.c ****   }
 964:../Sources/TFC/TFC_CrystalClock.c ****  
 965:../Sources/TFC/TFC_CrystalClock.c **** // Wait for clock status bits to update
 966:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 967:../Sources/TFC/TFC_CrystalClock.c ****   {
 968:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST
 969:../Sources/TFC/TFC_CrystalClock.c ****   }
 970:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19; // check IRC is really
 971:../Sources/TFC/TFC_CrystalClock.c ****   
 972:../Sources/TFC/TFC_CrystalClock.c ****   // wait for Reference clock Status bit to set
 973:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 974:../Sources/TFC/TFC_CrystalClock.c ****   {
 975:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
 976:../Sources/TFC/TFC_CrystalClock.c ****   }
 977:../Sources/TFC/TFC_CrystalClock.c ****   if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error i
 978:../Sources/TFC/TFC_CrystalClock.c ****   
 979:../Sources/TFC/TFC_CrystalClock.c **** // Now in FBI mode
 980:../Sources/TFC/TFC_CrystalClock.c ****   
 981:../Sources/TFC/TFC_CrystalClock.c ****   if (irc_select)
 982:../Sources/TFC/TFC_CrystalClock.c ****   {
 983:../Sources/TFC/TFC_CrystalClock.c ****     fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fa
 984:../Sources/TFC/TFC_CrystalClock.c ****     return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by FCRDIV
 985:../Sources/TFC/TFC_CrystalClock.c ****   }
 986:../Sources/TFC/TFC_CrystalClock.c ****   else
 987:../Sources/TFC/TFC_CrystalClock.c ****   {
 988:../Sources/TFC/TFC_CrystalClock.c ****     return irc_freq; // MCGOUT frequency equals slow IRC frequency
 989:../Sources/TFC/TFC_CrystalClock.c ****   }
 990:../Sources/TFC/TFC_CrystalClock.c **** } //fbe_fbi
 991:../Sources/TFC/TFC_CrystalClock.c **** 
 992:../Sources/TFC/TFC_CrystalClock.c **** 
 993:../Sources/TFC/TFC_CrystalClock.c **** int fbi_fbe(int crystal_val, unsigned char hgo_val, unsigned char erefs_val)
 994:../Sources/TFC/TFC_CrystalClock.c **** {
 995:../Sources/TFC/TFC_CrystalClock.c ****   unsigned char temp_reg;
 996:../Sources/TFC/TFC_CrystalClock.c ****   unsigned char frdiv_val;
 997:../Sources/TFC/TFC_CrystalClock.c ****   short i;
 998:../Sources/TFC/TFC_CrystalClock.c ****   
 999:../Sources/TFC/TFC_CrystalClock.c **** // check if in FBI mode
1000:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
1001:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
1002:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
1003:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
1004:../Sources/TFC/TFC_CrystalClock.c ****   {  
1005:../Sources/TFC/TFC_CrystalClock.c ****     return 0x3;                                                       // MCG not in correct mode re
1006:../Sources/TFC/TFC_CrystalClock.c ****   }
1007:../Sources/TFC/TFC_CrystalClock.c ****  
1008:../Sources/TFC/TFC_CrystalClock.c **** // check external frequency is less than the maximum frequency
1009:../Sources/TFC/TFC_CrystalClock.c ****   if  (crystal_val > 50000000) {return 0x21;}
1010:../Sources/TFC/TFC_CrystalClock.c ****   
1011:../Sources/TFC/TFC_CrystalClock.c **** // check crystal frequency is within spec. if crystal osc is being used
1012:../Sources/TFC/TFC_CrystalClock.c ****   if (erefs_val)
1013:../Sources/TFC/TFC_CrystalClock.c ****   {
1014:../Sources/TFC/TFC_CrystalClock.c ****     if ((crystal_val < 30000) ||
1015:../Sources/TFC/TFC_CrystalClock.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
1016:../Sources/TFC/TFC_CrystalClock.c ****         (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal op
1017:../Sources/TFC/TFC_CrystalClock.c ****   }
1018:../Sources/TFC/TFC_CrystalClock.c **** 
1019:../Sources/TFC/TFC_CrystalClock.c **** // make sure HGO will never be greater than 1. Could return an error instead if desired.  
1020:../Sources/TFC/TFC_CrystalClock.c ****   if (hgo_val > 0)
1021:../Sources/TFC/TFC_CrystalClock.c ****   {
1022:../Sources/TFC/TFC_CrystalClock.c ****     hgo_val = 1; // force hgo_val to 1 if > 0
1023:../Sources/TFC/TFC_CrystalClock.c ****   }
1024:../Sources/TFC/TFC_CrystalClock.c **** 
1025:../Sources/TFC/TFC_CrystalClock.c **** // configure the MCG_C2 register
1026:../Sources/TFC/TFC_CrystalClock.c **** // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the F
1027:../Sources/TFC/TFC_CrystalClock.c **** // it still needs to be set correctly even if the oscillator is not being used
1028:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C2;
1029:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
1030:../Sources/TFC/TFC_CrystalClock.c ****   if (crystal_val <= 40000)
1031:../Sources/TFC/TFC_CrystalClock.c ****   {
1032:../Sources/TFC/TFC_CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
1033:../Sources/TFC/TFC_CrystalClock.c ****   }
1034:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 8000000)
1035:../Sources/TFC/TFC_CrystalClock.c ****   {
1036:../Sources/TFC/TFC_CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
1037:../Sources/TFC/TFC_CrystalClock.c ****   }
1038:../Sources/TFC/TFC_CrystalClock.c ****   else
1039:../Sources/TFC/TFC_CrystalClock.c ****   {
1040:../Sources/TFC/TFC_CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
1041:../Sources/TFC/TFC_CrystalClock.c ****   }
1042:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C2 = temp_reg;
1043:../Sources/TFC/TFC_CrystalClock.c **** 
1044:../Sources/TFC/TFC_CrystalClock.c **** // determine FRDIV based on reference clock frequency
1045:../Sources/TFC/TFC_CrystalClock.c **** // since the external frequency has already been checked only the maximum frequency for each FRDIV 
1046:../Sources/TFC/TFC_CrystalClock.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
1047:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
1048:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
1049:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
1050:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
1051:../Sources/TFC/TFC_CrystalClock.c ****   else {frdiv_val = 5;}
1052:../Sources/TFC/TFC_CrystalClock.c ****   
1053:../Sources/TFC/TFC_CrystalClock.c **** // Select external oscilator and Reference Divider and clear IREFS to start ext osc
1054:../Sources/TFC/TFC_CrystalClock.c **** // If IRCLK is required it must be enabled outside of this driver, existing state will be maintaine
1055:../Sources/TFC/TFC_CrystalClock.c **** // CLKS=2, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
1056:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C1;
1057:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these
1058:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
1059:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 = temp_reg;
1060:../Sources/TFC/TFC_CrystalClock.c **** 
1061:../Sources/TFC/TFC_CrystalClock.c **** // if the external oscillator is used need to wait for OSCINIT to set
1062:../Sources/TFC/TFC_CrystalClock.c ****   if (erefs_val)
1063:../Sources/TFC/TFC_CrystalClock.c ****   {
1064:../Sources/TFC/TFC_CrystalClock.c ****     for (i = 0 ; i < 10000 ; i++)
1065:../Sources/TFC/TFC_CrystalClock.c ****     {
1066:../Sources/TFC/TFC_CrystalClock.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
1067:../Sources/TFC/TFC_CrystalClock.c ****     }
1068:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with err
1069:../Sources/TFC/TFC_CrystalClock.c ****   }
1070:../Sources/TFC/TFC_CrystalClock.c **** 
1071:../Sources/TFC/TFC_CrystalClock.c **** // wait for Reference clock Status bit to clear
1072:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
1073:../Sources/TFC/TFC_CrystalClock.c ****   {
1074:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
1075:../Sources/TFC/TFC_CrystalClock.c ****   }
1076:../Sources/TFC/TFC_CrystalClock.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
1077:../Sources/TFC/TFC_CrystalClock.c ****   
1078:../Sources/TFC/TFC_CrystalClock.c **** // Wait for clock status bits to show clock source is ext ref clk
1079:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
1080:../Sources/TFC/TFC_CrystalClock.c ****   {
1081:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
1082:../Sources/TFC/TFC_CrystalClock.c ****   }
1083:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
1084:../Sources/TFC/TFC_CrystalClock.c ****  
1085:../Sources/TFC/TFC_CrystalClock.c **** // Now in FBE  
1086:../Sources/TFC/TFC_CrystalClock.c **** // It is recommended that the clock monitor is enabled when using an external clock as the clock so
1087:../Sources/TFC/TFC_CrystalClock.c **** // It is enabled here but can be removed if this is not required.
1088:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 |= MCG_C6_CME0_MASK;
1089:../Sources/TFC/TFC_CrystalClock.c ****   
1090:../Sources/TFC/TFC_CrystalClock.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency  
1091:../Sources/TFC/TFC_CrystalClock.c **** } // fbi_fbe
1092:../Sources/TFC/TFC_CrystalClock.c **** 
1093:../Sources/TFC/TFC_CrystalClock.c **** 
1094:../Sources/TFC/TFC_CrystalClock.c **** /********************************************************************/
1095:../Sources/TFC/TFC_CrystalClock.c **** /* Functon name : fbi_blpi
1096:../Sources/TFC/TFC_CrystalClock.c ****  *
1097:../Sources/TFC/TFC_CrystalClock.c ****  * Mode transition: FBI to BLPI mode
1098:../Sources/TFC/TFC_CrystalClock.c ****  *
1099:../Sources/TFC/TFC_CrystalClock.c ****  * This function transitions the MCG from FBI mode to BLPI mode. This is
1100:../Sources/TFC/TFC_CrystalClock.c ****  * achieved by setting the MCG_C2[LP] bit. There is no status bit to 
1101:../Sources/TFC/TFC_CrystalClock.c ****  * check so 0 is always returned if the function was called with the MCG
1102:../Sources/TFC/TFC_CrystalClock.c ****  * in FBI mode. 
1103:../Sources/TFC/TFC_CrystalClock.c ****  *
1104:../Sources/TFC/TFC_CrystalClock.c ****  * Parameters: irc_freq - internal reference clock frequency
1105:../Sources/TFC/TFC_CrystalClock.c ****  *             ircs_select - 0 if slow irc, 1 if fast irc
1106:../Sources/TFC/TFC_CrystalClock.c ****  *
1107:../Sources/TFC/TFC_CrystalClock.c ****  * Return value : MCGOUT frequency or error code 0x13
1108:../Sources/TFC/TFC_CrystalClock.c ****  */
1109:../Sources/TFC/TFC_CrystalClock.c **** int fbi_blpi(int irc_freq, unsigned char irc_select)
1110:../Sources/TFC/TFC_CrystalClock.c **** {
1111:../Sources/TFC/TFC_CrystalClock.c ****   unsigned char fcrdiv_val;
1112:../Sources/TFC/TFC_CrystalClock.c ****   
1113:../Sources/TFC/TFC_CrystalClock.c **** // check if in FBI mode
1114:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
1115:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
1116:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
1117:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
1118:../Sources/TFC/TFC_CrystalClock.c ****   {  
1119:../Sources/TFC/TFC_CrystalClock.c ****     return 0x3;                                                       // MCG not in correct mode re
1120:../Sources/TFC/TFC_CrystalClock.c ****   }
1121:../Sources/TFC/TFC_CrystalClock.c **** 
1122:../Sources/TFC/TFC_CrystalClock.c **** // Set LP bit to disable the FLL and enter BLPI
1123:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C2 |= MCG_C2_LP_MASK;
1124:../Sources/TFC/TFC_CrystalClock.c ****   
1125:../Sources/TFC/TFC_CrystalClock.c **** // Now in BLPI
1126:../Sources/TFC/TFC_CrystalClock.c ****   if (irc_select)
1127:../Sources/TFC/TFC_CrystalClock.c ****   {
1128:../Sources/TFC/TFC_CrystalClock.c ****     fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fa
1129:../Sources/TFC/TFC_CrystalClock.c ****     return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
1130:../Sources/TFC/TFC_CrystalClock.c ****   }
1131:../Sources/TFC/TFC_CrystalClock.c ****   else
1132:../Sources/TFC/TFC_CrystalClock.c ****   {
1133:../Sources/TFC/TFC_CrystalClock.c ****     return irc_freq; // MCGOUT frequency equals slow IRC frequency
1134:../Sources/TFC/TFC_CrystalClock.c ****   }   
1135:../Sources/TFC/TFC_CrystalClock.c **** } // fbi_blpi
1136:../Sources/TFC/TFC_CrystalClock.c **** 
1137:../Sources/TFC/TFC_CrystalClock.c **** 
1138:../Sources/TFC/TFC_CrystalClock.c **** 
1139:../Sources/TFC/TFC_CrystalClock.c **** /********************************************************************/
1140:../Sources/TFC/TFC_CrystalClock.c **** /* Functon name : blpi_fbi
1141:../Sources/TFC/TFC_CrystalClock.c ****  *
1142:../Sources/TFC/TFC_CrystalClock.c ****  * Mode transition: BLPI to FBI mode
1143:../Sources/TFC/TFC_CrystalClock.c ****  *
1144:../Sources/TFC/TFC_CrystalClock.c ****  * This function transitions the MCG from BLPI mode to FBI mode. This is
1145:../Sources/TFC/TFC_CrystalClock.c ****  * achieved by clearing the MCG_C2[LP] bit. There is no status bit to 
1146:../Sources/TFC/TFC_CrystalClock.c ****  * check so 0 is always returned if the function was called with the MCG
1147:../Sources/TFC/TFC_CrystalClock.c ****  * in BLPI mode. 
1148:../Sources/TFC/TFC_CrystalClock.c ****  *
1149:../Sources/TFC/TFC_CrystalClock.c ****  * Parameters: irc_freq - internal reference clock frequency
1150:../Sources/TFC/TFC_CrystalClock.c ****  *             ircs_select - 0 if slow irc, 1 if fast irc
1151:../Sources/TFC/TFC_CrystalClock.c ****  *
1152:../Sources/TFC/TFC_CrystalClock.c ****  * Return value : MCGOUT frequency or error code 0x15
1153:../Sources/TFC/TFC_CrystalClock.c ****  */
1154:../Sources/TFC/TFC_CrystalClock.c **** int blpi_fbi(int irc_freq, unsigned char irc_select)
1155:../Sources/TFC/TFC_CrystalClock.c **** {
1156:../Sources/TFC/TFC_CrystalClock.c ****   unsigned char fcrdiv_val;
1157:../Sources/TFC/TFC_CrystalClock.c ****   // check if in BLPI mode
1158:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
1159:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
1160:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
1161:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_C2 & MCG_C2_LP_MASK)))                                     // check LP bit is set
1162:../Sources/TFC/TFC_CrystalClock.c ****   {
1163:../Sources/TFC/TFC_CrystalClock.c ****     return 0x5;                                                       // MCG not in correct mode re
1164:../Sources/TFC/TFC_CrystalClock.c ****   }
1165:../Sources/TFC/TFC_CrystalClock.c **** 
1166:../Sources/TFC/TFC_CrystalClock.c **** // Clear LP bit to enable the FLL and enter FBI mode   
1167:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C2 &= ~MCG_C2_LP_MASK;
1168:../Sources/TFC/TFC_CrystalClock.c ****   
1169:../Sources/TFC/TFC_CrystalClock.c **** // Now in FBI mode
1170:../Sources/TFC/TFC_CrystalClock.c ****   if (irc_select)
1171:../Sources/TFC/TFC_CrystalClock.c ****   {
1172:../Sources/TFC/TFC_CrystalClock.c ****     fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fa
1173:../Sources/TFC/TFC_CrystalClock.c ****     return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
1174:../Sources/TFC/TFC_CrystalClock.c ****   }
1175:../Sources/TFC/TFC_CrystalClock.c ****   else
1176:../Sources/TFC/TFC_CrystalClock.c ****   {
1177:../Sources/TFC/TFC_CrystalClock.c ****     return irc_freq; // MCGOUT frequency equals slow IRC frequency
1178:../Sources/TFC/TFC_CrystalClock.c ****   }
1179:../Sources/TFC/TFC_CrystalClock.c **** } // blpi_fbi
1180:../Sources/TFC/TFC_CrystalClock.c **** 
1181:../Sources/TFC/TFC_CrystalClock.c **** 
1182:../Sources/TFC/TFC_CrystalClock.c **** int fbi_fee(int crystal_val, unsigned char hgo_val, unsigned char erefs_val)
1183:../Sources/TFC/TFC_CrystalClock.c **** {
1184:../Sources/TFC/TFC_CrystalClock.c ****   unsigned char temp_reg;
1185:../Sources/TFC/TFC_CrystalClock.c ****   unsigned char frdiv_val;
1186:../Sources/TFC/TFC_CrystalClock.c ****   short i;
1187:../Sources/TFC/TFC_CrystalClock.c ****   int mcg_out, fll_ref_freq;
1188:../Sources/TFC/TFC_CrystalClock.c **** 
1189:../Sources/TFC/TFC_CrystalClock.c **** // check if in FBI mode
1190:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
1191:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
1192:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
1193:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
1194:../Sources/TFC/TFC_CrystalClock.c ****   {  
1195:../Sources/TFC/TFC_CrystalClock.c ****     return 0x3;                                                       // MCG not in correct mode re
1196:../Sources/TFC/TFC_CrystalClock.c ****   }
1197:../Sources/TFC/TFC_CrystalClock.c ****   
1198:../Sources/TFC/TFC_CrystalClock.c **** // check external frequency is less than the maximum frequency
1199:../Sources/TFC/TFC_CrystalClock.c ****   if  (crystal_val > 50000000) {return 0x21;}
1200:../Sources/TFC/TFC_CrystalClock.c ****   
1201:../Sources/TFC/TFC_CrystalClock.c **** // check crystal frequency is within spec. if crystal osc is being used
1202:../Sources/TFC/TFC_CrystalClock.c ****   if (erefs_val)
1203:../Sources/TFC/TFC_CrystalClock.c ****   {
1204:../Sources/TFC/TFC_CrystalClock.c ****     if ((crystal_val < 30000) ||
1205:../Sources/TFC/TFC_CrystalClock.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
1206:../Sources/TFC/TFC_CrystalClock.c ****         (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal op
1207:../Sources/TFC/TFC_CrystalClock.c ****   }
1208:../Sources/TFC/TFC_CrystalClock.c **** 
1209:../Sources/TFC/TFC_CrystalClock.c **** // make sure HGO will never be greater than 1. Could return an error instead if desired.  
1210:../Sources/TFC/TFC_CrystalClock.c ****   if (hgo_val > 0)
1211:../Sources/TFC/TFC_CrystalClock.c ****   {
1212:../Sources/TFC/TFC_CrystalClock.c ****     hgo_val = 1; // force hgo_val to 1 if > 0
1213:../Sources/TFC/TFC_CrystalClock.c ****   }
1214:../Sources/TFC/TFC_CrystalClock.c **** 
1215:../Sources/TFC/TFC_CrystalClock.c **** // configure the MCG_C2 register
1216:../Sources/TFC/TFC_CrystalClock.c **** // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the F
1217:../Sources/TFC/TFC_CrystalClock.c **** // it still needs to be set correctly even if the oscillator is not being used
1218:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C2;
1219:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
1220:../Sources/TFC/TFC_CrystalClock.c ****   if (crystal_val <= 40000)
1221:../Sources/TFC/TFC_CrystalClock.c ****   {
1222:../Sources/TFC/TFC_CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
1223:../Sources/TFC/TFC_CrystalClock.c ****   }
1224:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 8000000)
1225:../Sources/TFC/TFC_CrystalClock.c ****   {
1226:../Sources/TFC/TFC_CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
1227:../Sources/TFC/TFC_CrystalClock.c ****   }
1228:../Sources/TFC/TFC_CrystalClock.c ****   else
1229:../Sources/TFC/TFC_CrystalClock.c ****   {
1230:../Sources/TFC/TFC_CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
1231:../Sources/TFC/TFC_CrystalClock.c ****   }
1232:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C2 = temp_reg;
1233:../Sources/TFC/TFC_CrystalClock.c **** 
1234:../Sources/TFC/TFC_CrystalClock.c **** // determine FRDIV based on reference clock frequency
1235:../Sources/TFC/TFC_CrystalClock.c **** // since the external frequency has already been checked only the maximum frequency for each FRDIV 
1236:../Sources/TFC/TFC_CrystalClock.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
1237:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
1238:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
1239:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
1240:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
1241:../Sources/TFC/TFC_CrystalClock.c ****   else {frdiv_val = 5;}
1242:../Sources/TFC/TFC_CrystalClock.c **** // The FLL ref clk divide value depends on FRDIV and the RANGE value
1243:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
1244:../Sources/TFC/TFC_CrystalClock.c ****   {
1245:../Sources/TFC/TFC_CrystalClock.c ****     fll_ref_freq = ((crystal_val) / (32 << frdiv_val));
1246:../Sources/TFC/TFC_CrystalClock.c ****   }
1247:../Sources/TFC/TFC_CrystalClock.c ****   else
1248:../Sources/TFC/TFC_CrystalClock.c ****   {
1249:../Sources/TFC/TFC_CrystalClock.c ****     fll_ref_freq = ((crystal_val) / (1 << frdiv_val));
1250:../Sources/TFC/TFC_CrystalClock.c ****   }
1251:../Sources/TFC/TFC_CrystalClock.c ****   
1252:../Sources/TFC/TFC_CrystalClock.c **** // Check resulting FLL frequency 
1253:../Sources/TFC/TFC_CrystalClock.c ****   mcg_out = fll_freq(fll_ref_freq); // FLL reference frequency calculated from ext ref freq and FRD
1254:../Sources/TFC/TFC_CrystalClock.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
1255:../Sources/TFC/TFC_CrystalClock.c ****   
1256:../Sources/TFC/TFC_CrystalClock.c **** // Select external oscilator and Reference Divider and clear IREFS to start ext osc
1257:../Sources/TFC/TFC_CrystalClock.c **** // If IRCLK is required it must be enabled outside of this driver, existing state will be maintaine
1258:../Sources/TFC/TFC_CrystalClock.c **** // CLKS=0, FRDIV=frdiv_val, IREFS=0, IRCLKEN=?, IREFSTEN=?
1259:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C1;
1260:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear CLKS, FRDIV and
1261:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= (MCG_C1_CLKS(0) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
1262:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 = temp_reg;
1263:../Sources/TFC/TFC_CrystalClock.c **** 
1264:../Sources/TFC/TFC_CrystalClock.c **** // if the external oscillator is used need to wait for OSCINIT to set
1265:../Sources/TFC/TFC_CrystalClock.c ****   if (erefs_val)
1266:../Sources/TFC/TFC_CrystalClock.c ****   {
1267:../Sources/TFC/TFC_CrystalClock.c ****     for (i = 0 ; i < 10000 ; i++)
1268:../Sources/TFC/TFC_CrystalClock.c ****     {
1269:../Sources/TFC/TFC_CrystalClock.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
1270:../Sources/TFC/TFC_CrystalClock.c ****     }
1271:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with err
1272:../Sources/TFC/TFC_CrystalClock.c ****   }
1273:../Sources/TFC/TFC_CrystalClock.c **** 
1274:../Sources/TFC/TFC_CrystalClock.c **** // wait for Reference clock Status bit to clear
1275:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
1276:../Sources/TFC/TFC_CrystalClock.c ****   {
1277:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
1278:../Sources/TFC/TFC_CrystalClock.c ****   }
1279:../Sources/TFC/TFC_CrystalClock.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
1280:../Sources/TFC/TFC_CrystalClock.c ****   
1281:../Sources/TFC/TFC_CrystalClock.c **** // Wait for clock status bits to show clock source is ext ref clk
1282:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
1283:../Sources/TFC/TFC_CrystalClock.c ****   {
1284:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST
1285:../Sources/TFC/TFC_CrystalClock.c ****   }
1286:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check FLLK is reall
1287:../Sources/TFC/TFC_CrystalClock.c ****  
1288:../Sources/TFC/TFC_CrystalClock.c **** // Now in FEE  
1289:../Sources/TFC/TFC_CrystalClock.c **** // It is recommended that the clock monitor is enabled when using an external clock as the clock so
1290:../Sources/TFC/TFC_CrystalClock.c **** // It is enabled here but can be removed if this is not required.
1291:../Sources/TFC/TFC_CrystalClock.c **** // The clock monitor MUST be disabled when returning to a non-external clock mode (FEI, FBI and BLP
1292:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 |= MCG_C6_CME0_MASK;
1293:../Sources/TFC/TFC_CrystalClock.c ****   
1294:../Sources/TFC/TFC_CrystalClock.c ****   return mcg_out; // MCGOUT frequency equals FLL frequency
1295:../Sources/TFC/TFC_CrystalClock.c **** } //fbi_fee
1296:../Sources/TFC/TFC_CrystalClock.c **** 
1297:../Sources/TFC/TFC_CrystalClock.c **** 
1298:../Sources/TFC/TFC_CrystalClock.c **** int fee_fbi(int irc_freq, unsigned char irc_select)
1299:../Sources/TFC/TFC_CrystalClock.c **** { 
1300:../Sources/TFC/TFC_CrystalClock.c ****   unsigned char fcrdiv_val;
1301:../Sources/TFC/TFC_CrystalClock.c ****   short i;
1302:../Sources/TFC/TFC_CrystalClock.c ****   
1303:../Sources/TFC/TFC_CrystalClock.c **** // Check MCG is in FEE mode
1304:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
1305:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                             // check FLL ref is external re
1306:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                               // check PLLS mux has selected 
1307:../Sources/TFC/TFC_CrystalClock.c ****   {
1308:../Sources/TFC/TFC_CrystalClock.c ****     return 0x2;                                                     // return error code
1309:../Sources/TFC/TFC_CrystalClock.c ****   }
1310:../Sources/TFC/TFC_CrystalClock.c ****   
1311:../Sources/TFC/TFC_CrystalClock.c ****   // Check that the irc frequency matches the selected IRC 
1312:../Sources/TFC/TFC_CrystalClock.c ****   if (!(irc_select))
1313:../Sources/TFC/TFC_CrystalClock.c ****   {    
1314:../Sources/TFC/TFC_CrystalClock.c ****     if ((irc_freq < 31250) || (irc_freq > 39063)) {return 0x31;}
1315:../Sources/TFC/TFC_CrystalClock.c ****   }
1316:../Sources/TFC/TFC_CrystalClock.c ****   else
1317:../Sources/TFC/TFC_CrystalClock.c ****   {
1318:../Sources/TFC/TFC_CrystalClock.c ****     if ((irc_freq < 3000000) || (irc_freq > 5000000)) {return 0x32;} // Fast IRC freq
1319:../Sources/TFC/TFC_CrystalClock.c ****   }
1320:../Sources/TFC/TFC_CrystalClock.c ****   
1321:../Sources/TFC/TFC_CrystalClock.c **** // Select the required IRC
1322:../Sources/TFC/TFC_CrystalClock.c ****   if (irc_select)
1323:../Sources/TFC/TFC_CrystalClock.c ****   {
1324:../Sources/TFC/TFC_CrystalClock.c ****     MCG_C2 |= MCG_C2_IRCS_MASK; // select fast IRC by setting IRCS
1325:../Sources/TFC/TFC_CrystalClock.c ****   }
1326:../Sources/TFC/TFC_CrystalClock.c ****   else
1327:../Sources/TFC/TFC_CrystalClock.c ****   {
1328:../Sources/TFC/TFC_CrystalClock.c ****     MCG_C2 &= ~MCG_C2_IRCS_MASK; // select slow IRC by clearing IRCS
1329:../Sources/TFC/TFC_CrystalClock.c ****   }
1330:../Sources/TFC/TFC_CrystalClock.c ****   
1331:../Sources/TFC/TFC_CrystalClock.c **** // Make sure the clock monitor is disabled before switching modes otherwise it will trigger
1332:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 &= ~MCG_C6_CME0_MASK;
1333:../Sources/TFC/TFC_CrystalClock.c ****   
1334:../Sources/TFC/TFC_CrystalClock.c **** // Select the IRC as the CLKS mux selection
1335:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 |= MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK; // set IREFS and select IRC as MCGOUT
1336:../Sources/TFC/TFC_CrystalClock.c ****  
1337:../Sources/TFC/TFC_CrystalClock.c **** // wait until internal reference switches to requested irc.
1338:../Sources/TFC/TFC_CrystalClock.c ****   if (!(irc_select))
1339:../Sources/TFC/TFC_CrystalClock.c ****   {
1340:../Sources/TFC/TFC_CrystalClock.c ****     for (i = 0 ; i < 2000 ; i++)
1341:../Sources/TFC/TFC_CrystalClock.c ****     {
1342:../Sources/TFC/TFC_CrystalClock.c ****       if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishe
1343:../Sources/TFC/TFC_CrystalClock.c ****     }
1344:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_IRCST_MASK) return 0x13; // check bit is really clear and return with error i
1345:../Sources/TFC/TFC_CrystalClock.c ****   }
1346:../Sources/TFC/TFC_CrystalClock.c ****   else
1347:../Sources/TFC/TFC_CrystalClock.c ****   {
1348:../Sources/TFC/TFC_CrystalClock.c ****     for (i = 0 ; i < 2000 ; i++)
1349:../Sources/TFC/TFC_CrystalClock.c ****     {
1350:../Sources/TFC/TFC_CrystalClock.c ****       if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
1351:../Sources/TFC/TFC_CrystalClock.c ****     }
1352:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_IRCST_MASK)) return 0x14; // check bit is really set and return with error 
1353:../Sources/TFC/TFC_CrystalClock.c ****   }
1354:../Sources/TFC/TFC_CrystalClock.c ****   
1355:../Sources/TFC/TFC_CrystalClock.c **** // Wait for clock status bits to update
1356:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
1357:../Sources/TFC/TFC_CrystalClock.c ****   {
1358:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST
1359:../Sources/TFC/TFC_CrystalClock.c ****   }
1360:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19; // check IRC is really
1361:../Sources/TFC/TFC_CrystalClock.c ****   
1362:../Sources/TFC/TFC_CrystalClock.c **** // wait for Reference clock Status bit to set
1363:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
1364:../Sources/TFC/TFC_CrystalClock.c ****   {
1365:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
1366:../Sources/TFC/TFC_CrystalClock.c ****   }
1367:../Sources/TFC/TFC_CrystalClock.c ****   if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error i
1368:../Sources/TFC/TFC_CrystalClock.c ****   
1369:../Sources/TFC/TFC_CrystalClock.c **** // Now in FBI mode
1370:../Sources/TFC/TFC_CrystalClock.c ****   if (irc_select)
1371:../Sources/TFC/TFC_CrystalClock.c ****   {
1372:../Sources/TFC/TFC_CrystalClock.c ****     fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fa
1373:../Sources/TFC/TFC_CrystalClock.c ****     return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
1374:../Sources/TFC/TFC_CrystalClock.c ****   }
1375:../Sources/TFC/TFC_CrystalClock.c ****   else
1376:../Sources/TFC/TFC_CrystalClock.c ****   {
1377:../Sources/TFC/TFC_CrystalClock.c ****     return irc_freq; // MCGOUT frequency equals slow IRC frequency
1378:../Sources/TFC/TFC_CrystalClock.c ****   }
1379:../Sources/TFC/TFC_CrystalClock.c **** } // fee_fbi 
1380:../Sources/TFC/TFC_CrystalClock.c **** 
1381:../Sources/TFC/TFC_CrystalClock.c **** 
1382:../Sources/TFC/TFC_CrystalClock.c **** int fbi_fei(int slow_irc_freq)
1383:../Sources/TFC/TFC_CrystalClock.c **** {
1384:../Sources/TFC/TFC_CrystalClock.c ****   unsigned char temp_reg;
1385:../Sources/TFC/TFC_CrystalClock.c ****   short i;
1386:../Sources/TFC/TFC_CrystalClock.c ****   int mcg_out;
1387:../Sources/TFC/TFC_CrystalClock.c **** 
1388:../Sources/TFC/TFC_CrystalClock.c **** // check if in FBI mode
1389:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
1390:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
1391:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
1392:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
1393:../Sources/TFC/TFC_CrystalClock.c ****   {  
1394:../Sources/TFC/TFC_CrystalClock.c ****     return 0x3;                                                       // MCG not in correct mode re
1395:../Sources/TFC/TFC_CrystalClock.c ****   }
1396:../Sources/TFC/TFC_CrystalClock.c **** 
1397:../Sources/TFC/TFC_CrystalClock.c **** // Check IRC frequency is within spec.
1398:../Sources/TFC/TFC_CrystalClock.c ****   if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
1399:../Sources/TFC/TFC_CrystalClock.c ****   {
1400:../Sources/TFC/TFC_CrystalClock.c ****     return 0x31;
1401:../Sources/TFC/TFC_CrystalClock.c ****   }
1402:../Sources/TFC/TFC_CrystalClock.c **** 
1403:../Sources/TFC/TFC_CrystalClock.c **** // Check resulting FLL frequency 
1404:../Sources/TFC/TFC_CrystalClock.c ****   mcg_out = fll_freq(slow_irc_freq); 
1405:../Sources/TFC/TFC_CrystalClock.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
1406:../Sources/TFC/TFC_CrystalClock.c ****   
1407:../Sources/TFC/TFC_CrystalClock.c **** // Change the CLKS mux to select the FLL output as MCGOUT  
1408:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C1;
1409:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS field
1410:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= MCG_C1_CLKS(0); // select FLL as MCGOUT
1411:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= MCG_C1_IREFS_MASK; // make sure IRC is FLL reference
1412:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 = temp_reg; // update MCG_C1
1413:../Sources/TFC/TFC_CrystalClock.c ****   
1414:../Sources/TFC/TFC_CrystalClock.c **** // wait for Reference clock Status bit to clear
1415:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
1416:../Sources/TFC/TFC_CrystalClock.c ****   {
1417:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST clears before loop finishes
1418:../Sources/TFC/TFC_CrystalClock.c ****   }
1419:../Sources/TFC/TFC_CrystalClock.c ****   if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error i
1420:../Sources/TFC/TFC_CrystalClock.c ****   
1421:../Sources/TFC/TFC_CrystalClock.c **** // Wait for clock status bits to show clock source is ext ref clk
1422:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
1423:../Sources/TFC/TFC_CrystalClock.c ****   {
1424:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST
1425:../Sources/TFC/TFC_CrystalClock.c ****   }
1426:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check FLL is really
1427:../Sources/TFC/TFC_CrystalClock.c **** 
1428:../Sources/TFC/TFC_CrystalClock.c **** // Now in FEI mode
1429:../Sources/TFC/TFC_CrystalClock.c ****   return mcg_out;  
1430:../Sources/TFC/TFC_CrystalClock.c **** } // fbi_fei
1431:../Sources/TFC/TFC_CrystalClock.c **** 
1432:../Sources/TFC/TFC_CrystalClock.c **** 
1433:../Sources/TFC/TFC_CrystalClock.c **** int fei_fbi(int irc_freq, unsigned char irc_select)
1434:../Sources/TFC/TFC_CrystalClock.c **** {
1435:../Sources/TFC/TFC_CrystalClock.c ****   unsigned char temp_reg;
1436:../Sources/TFC/TFC_CrystalClock.c ****   unsigned char fcrdiv_val;
1437:../Sources/TFC/TFC_CrystalClock.c ****   short i;
1438:../Sources/TFC/TFC_CrystalClock.c ****   
1439:../Sources/TFC/TFC_CrystalClock.c **** // Check MCG is in FEI mode
1440:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
1441:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
1442:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selecte
1443:../Sources/TFC/TFC_CrystalClock.c ****   {
1444:../Sources/TFC/TFC_CrystalClock.c ****     return 0x1;                                                       // return error code
1445:../Sources/TFC/TFC_CrystalClock.c ****   } 
1446:../Sources/TFC/TFC_CrystalClock.c **** 
1447:../Sources/TFC/TFC_CrystalClock.c **** // Check that the irc frequency matches the selected IRC 
1448:../Sources/TFC/TFC_CrystalClock.c ****   if (!(irc_select))
1449:../Sources/TFC/TFC_CrystalClock.c ****   {    
1450:../Sources/TFC/TFC_CrystalClock.c ****     if ((irc_freq < 31250) || (irc_freq > 39063)) {return 0x31;}
1451:../Sources/TFC/TFC_CrystalClock.c ****   }
1452:../Sources/TFC/TFC_CrystalClock.c ****   else
1453:../Sources/TFC/TFC_CrystalClock.c ****   {
1454:../Sources/TFC/TFC_CrystalClock.c ****     if ((irc_freq < 3000000) || (irc_freq > 5000000)) {return 0x32;} // Fast IRC freq
1455:../Sources/TFC/TFC_CrystalClock.c ****   }
1456:../Sources/TFC/TFC_CrystalClock.c ****   
1457:../Sources/TFC/TFC_CrystalClock.c **** // Select the desired IRC
1458:../Sources/TFC/TFC_CrystalClock.c ****   if (irc_select)
1459:../Sources/TFC/TFC_CrystalClock.c ****   {
1460:../Sources/TFC/TFC_CrystalClock.c ****     MCG_C2 |= MCG_C2_IRCS_MASK; // select fast IRCS
1461:../Sources/TFC/TFC_CrystalClock.c ****   }
1462:../Sources/TFC/TFC_CrystalClock.c ****   else
1463:../Sources/TFC/TFC_CrystalClock.c ****   {
1464:../Sources/TFC/TFC_CrystalClock.c ****     MCG_C2 &= ~MCG_C2_IRCS_MASK; // select slow IRCS
1465:../Sources/TFC/TFC_CrystalClock.c ****   }
1466:../Sources/TFC/TFC_CrystalClock.c ****   
1467:../Sources/TFC/TFC_CrystalClock.c **** // Change the CLKS mux to select the IRC as the MCGOUT
1468:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C1;
1469:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS
1470:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= MCG_C1_CLKS(1); // select IRC as the MCG clock sourse
1471:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 = temp_reg;
1472:../Sources/TFC/TFC_CrystalClock.c **** 
1473:../Sources/TFC/TFC_CrystalClock.c **** // wait until internal reference switches to requested irc.
1474:../Sources/TFC/TFC_CrystalClock.c ****   if (!(irc_select))
1475:../Sources/TFC/TFC_CrystalClock.c ****   {
1476:../Sources/TFC/TFC_CrystalClock.c ****     for (i = 0 ; i < 2000 ; i++)
1477:../Sources/TFC/TFC_CrystalClock.c ****     {
1478:../Sources/TFC/TFC_CrystalClock.c ****       if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishe
1479:../Sources/TFC/TFC_CrystalClock.c ****     }
1480:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_IRCST_MASK) return 0x13; // check bit is really clear and return with error i
1481:../Sources/TFC/TFC_CrystalClock.c ****   }
1482:../Sources/TFC/TFC_CrystalClock.c ****   else
1483:../Sources/TFC/TFC_CrystalClock.c ****   {
1484:../Sources/TFC/TFC_CrystalClock.c ****     for (i = 0 ; i < 2000 ; i++)
1485:../Sources/TFC/TFC_CrystalClock.c ****     {
1486:../Sources/TFC/TFC_CrystalClock.c ****       if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
1487:../Sources/TFC/TFC_CrystalClock.c ****     }
1488:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_IRCST_MASK)) return 0x14; // check bit is really set and return with error 
1489:../Sources/TFC/TFC_CrystalClock.c ****   }
1490:../Sources/TFC/TFC_CrystalClock.c ****   
1491:../Sources/TFC/TFC_CrystalClock.c **** // Wait for clock status bits to update
1492:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
1493:../Sources/TFC/TFC_CrystalClock.c ****   {
1494:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST
1495:../Sources/TFC/TFC_CrystalClock.c ****   }
1496:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19; // check IRC is really
1497:../Sources/TFC/TFC_CrystalClock.c ****   
1498:../Sources/TFC/TFC_CrystalClock.c **** // Now in FBI mode
1499:../Sources/TFC/TFC_CrystalClock.c ****   if (irc_select)
1500:../Sources/TFC/TFC_CrystalClock.c ****   {
1501:../Sources/TFC/TFC_CrystalClock.c ****     fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fa
1502:../Sources/TFC/TFC_CrystalClock.c ****     return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
1503:../Sources/TFC/TFC_CrystalClock.c ****   }
1504:../Sources/TFC/TFC_CrystalClock.c ****   else
1505:../Sources/TFC/TFC_CrystalClock.c ****   {
1506:../Sources/TFC/TFC_CrystalClock.c ****     return irc_freq; // MCGOUT frequency equals slow IRC frequency
1507:../Sources/TFC/TFC_CrystalClock.c ****   }   
1508:../Sources/TFC/TFC_CrystalClock.c **** } // fei_fbi
1509:../Sources/TFC/TFC_CrystalClock.c **** 
1510:../Sources/TFC/TFC_CrystalClock.c **** 
1511:../Sources/TFC/TFC_CrystalClock.c **** /********************************************************************/
1512:../Sources/TFC/TFC_CrystalClock.c **** /* Functon name : fei_fee
1513:../Sources/TFC/TFC_CrystalClock.c ****  *
1514:../Sources/TFC/TFC_CrystalClock.c ****  * Mode transition: FEI to FEE mode
1515:../Sources/TFC/TFC_CrystalClock.c ****  *
1516:../Sources/TFC/TFC_CrystalClock.c ****  * This function transitions the MCG from FEI mode to FEE mode. This is
1517:../Sources/TFC/TFC_CrystalClock.c ****  * achieved by setting the MCG_C2[LP] bit. There is no status bit to 
1518:../Sources/TFC/TFC_CrystalClock.c ****  * check so 0 is always returned if the function was called with the MCG
1519:../Sources/TFC/TFC_CrystalClock.c ****  * in FBI mode. The MCGCLKOUT frequency does not change
1520:../Sources/TFC/TFC_CrystalClock.c ****  *
1521:../Sources/TFC/TFC_CrystalClock.c ****  * Parameters: crystal_val - external clock frequency in Hz
1522:../Sources/TFC/TFC_CrystalClock.c ****  *             hgo_val     - selects whether low power or high gain mode is selected
1523:../Sources/TFC/TFC_CrystalClock.c ****  *                           for the crystal oscillator. This has no meaning if an 
1524:../Sources/TFC/TFC_CrystalClock.c ****  *                           external clock is used.
1525:../Sources/TFC/TFC_CrystalClock.c ****  *             erefs_val   - selects external clock (=0) or crystal osc (=1)
1526:../Sources/TFC/TFC_CrystalClock.c ****  *
1527:../Sources/TFC/TFC_CrystalClock.c ****  * Return value : MCGCLKOUT frequency (Hz) or error code
1528:../Sources/TFC/TFC_CrystalClock.c ****  */
1529:../Sources/TFC/TFC_CrystalClock.c **** int fei_fee(int crystal_val, unsigned char hgo_val, unsigned char erefs_val)
1530:../Sources/TFC/TFC_CrystalClock.c **** {
1531:../Sources/TFC/TFC_CrystalClock.c ****   unsigned char frdiv_val;
1532:../Sources/TFC/TFC_CrystalClock.c ****   unsigned char temp_reg;
1533:../Sources/TFC/TFC_CrystalClock.c ****  // short i;
1534:../Sources/TFC/TFC_CrystalClock.c ****   int mcg_out, fll_ref_freq, i;
1535:../Sources/TFC/TFC_CrystalClock.c ****   
1536:../Sources/TFC/TFC_CrystalClock.c **** // check if in FEI mode
1537:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
1538:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
1539:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selecte
1540:../Sources/TFC/TFC_CrystalClock.c ****   {
1541:../Sources/TFC/TFC_CrystalClock.c ****     return 0x1;                                                     // return error code
1542:../Sources/TFC/TFC_CrystalClock.c ****   }
1543:../Sources/TFC/TFC_CrystalClock.c **** 
1544:../Sources/TFC/TFC_CrystalClock.c **** // check external frequency is less than the maximum frequency
1545:../Sources/TFC/TFC_CrystalClock.c ****   if  (crystal_val > 50000000) {return 0x21;}
1546:../Sources/TFC/TFC_CrystalClock.c ****   
1547:../Sources/TFC/TFC_CrystalClock.c **** // check crystal frequency is within spec. if crystal osc is being used
1548:../Sources/TFC/TFC_CrystalClock.c ****   if (erefs_val)
1549:../Sources/TFC/TFC_CrystalClock.c ****   {
1550:../Sources/TFC/TFC_CrystalClock.c ****     if ((crystal_val < 30000) ||
1551:../Sources/TFC/TFC_CrystalClock.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
1552:../Sources/TFC/TFC_CrystalClock.c ****         (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal op
1553:../Sources/TFC/TFC_CrystalClock.c ****   }
1554:../Sources/TFC/TFC_CrystalClock.c **** 
1555:../Sources/TFC/TFC_CrystalClock.c **** // make sure HGO will never be greater than 1. Could return an error instead if desired.  
1556:../Sources/TFC/TFC_CrystalClock.c ****   if (hgo_val > 0)
1557:../Sources/TFC/TFC_CrystalClock.c ****   {
1558:../Sources/TFC/TFC_CrystalClock.c ****     hgo_val = 1; // force hgo_val to 1 if > 0
1559:../Sources/TFC/TFC_CrystalClock.c ****   }
1560:../Sources/TFC/TFC_CrystalClock.c **** 
1561:../Sources/TFC/TFC_CrystalClock.c **** // configure the MCG_C2 register
1562:../Sources/TFC/TFC_CrystalClock.c **** // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the F
1563:../Sources/TFC/TFC_CrystalClock.c **** // it still needs to be set correctly even if the oscillator is not being used
1564:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C2;
1565:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
1566:../Sources/TFC/TFC_CrystalClock.c ****   if (crystal_val <= 40000)
1567:../Sources/TFC/TFC_CrystalClock.c ****   {
1568:../Sources/TFC/TFC_CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
1569:../Sources/TFC/TFC_CrystalClock.c ****   }
1570:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 8000000)
1571:../Sources/TFC/TFC_CrystalClock.c ****   {
1572:../Sources/TFC/TFC_CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
1573:../Sources/TFC/TFC_CrystalClock.c ****   }
1574:../Sources/TFC/TFC_CrystalClock.c ****   else
1575:../Sources/TFC/TFC_CrystalClock.c ****   {
1576:../Sources/TFC/TFC_CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
1577:../Sources/TFC/TFC_CrystalClock.c ****   }
1578:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C2 = temp_reg;
1579:../Sources/TFC/TFC_CrystalClock.c **** 
1580:../Sources/TFC/TFC_CrystalClock.c **** // determine FRDIV based on reference clock frequency
1581:../Sources/TFC/TFC_CrystalClock.c **** // since the external frequency has already been checked only the maximum frequency for each FRDIV 
1582:../Sources/TFC/TFC_CrystalClock.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
1583:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
1584:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
1585:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
1586:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
1587:../Sources/TFC/TFC_CrystalClock.c ****   else {frdiv_val = 5;}
1588:../Sources/TFC/TFC_CrystalClock.c ****    
1589:../Sources/TFC/TFC_CrystalClock.c ****   // The FLL ref clk divide value depends on FRDIV and the RANGE value
1590:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
1591:../Sources/TFC/TFC_CrystalClock.c ****   {
1592:../Sources/TFC/TFC_CrystalClock.c ****     fll_ref_freq = ((crystal_val) / (32 << frdiv_val));
1593:../Sources/TFC/TFC_CrystalClock.c ****   }
1594:../Sources/TFC/TFC_CrystalClock.c ****   else
1595:../Sources/TFC/TFC_CrystalClock.c ****   {
1596:../Sources/TFC/TFC_CrystalClock.c ****     fll_ref_freq = ((crystal_val) / (1 << frdiv_val));
1597:../Sources/TFC/TFC_CrystalClock.c ****   }
1598:../Sources/TFC/TFC_CrystalClock.c ****   
1599:../Sources/TFC/TFC_CrystalClock.c **** // Check resulting FLL frequency 
1600:../Sources/TFC/TFC_CrystalClock.c ****   mcg_out = fll_freq(fll_ref_freq); // FLL reference frequency calculated from ext ref freq and FRD
1601:../Sources/TFC/TFC_CrystalClock.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
1602:../Sources/TFC/TFC_CrystalClock.c ****   
1603:../Sources/TFC/TFC_CrystalClock.c **** // Select external oscilator and Reference Divider and clear IREFS to start ext osc
1604:../Sources/TFC/TFC_CrystalClock.c **** // If IRCLK is required it must be enabled outside of this driver, existing state will be maintaine
1605:../Sources/TFC/TFC_CrystalClock.c **** // CLKS=0, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
1606:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C1;
1607:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these
1608:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= (MCG_C1_CLKS(0) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
1609:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 = temp_reg;
1610:../Sources/TFC/TFC_CrystalClock.c **** 
1611:../Sources/TFC/TFC_CrystalClock.c **** // if the external oscillator is used need to wait for OSCINIT to set
1612:../Sources/TFC/TFC_CrystalClock.c ****   if (erefs_val)
1613:../Sources/TFC/TFC_CrystalClock.c ****   {
1614:../Sources/TFC/TFC_CrystalClock.c ****     for (i = 0 ; i < 20000000 ; i++)
1615:../Sources/TFC/TFC_CrystalClock.c ****     {
1616:../Sources/TFC/TFC_CrystalClock.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
1617:../Sources/TFC/TFC_CrystalClock.c ****     }
1618:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with err
1619:../Sources/TFC/TFC_CrystalClock.c ****   }
1620:../Sources/TFC/TFC_CrystalClock.c **** 
1621:../Sources/TFC/TFC_CrystalClock.c **** // wait for Reference clock Status bit to clear
1622:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
1623:../Sources/TFC/TFC_CrystalClock.c ****   {
1624:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
1625:../Sources/TFC/TFC_CrystalClock.c ****   }
1626:../Sources/TFC/TFC_CrystalClock.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
1627:../Sources/TFC/TFC_CrystalClock.c ****   
1628:../Sources/TFC/TFC_CrystalClock.c **** // Now in FBE  
1629:../Sources/TFC/TFC_CrystalClock.c **** // It is recommended that the clock monitor is enabled when using an external clock as the clock so
1630:../Sources/TFC/TFC_CrystalClock.c **** // It is enabled here but can be removed if this is not required.
1631:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 |= MCG_C6_CME0_MASK;
1632:../Sources/TFC/TFC_CrystalClock.c ****   
1633:../Sources/TFC/TFC_CrystalClock.c ****   return mcg_out; // MCGOUT frequency equals FLL frequency
1634:../Sources/TFC/TFC_CrystalClock.c **** } // fei_fee
1635:../Sources/TFC/TFC_CrystalClock.c **** 
1636:../Sources/TFC/TFC_CrystalClock.c **** 
1637:../Sources/TFC/TFC_CrystalClock.c **** int fee_fei(int slow_irc_freq)
1638:../Sources/TFC/TFC_CrystalClock.c **** {
1639:../Sources/TFC/TFC_CrystalClock.c ****   short i;
1640:../Sources/TFC/TFC_CrystalClock.c ****   int mcg_out;
1641:../Sources/TFC/TFC_CrystalClock.c **** 
1642:../Sources/TFC/TFC_CrystalClock.c **** // Check MCG is in FEE mode
1643:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
1644:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                             // check FLL ref is external re
1645:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                               // check PLLS mux has selected 
1646:../Sources/TFC/TFC_CrystalClock.c ****   {
1647:../Sources/TFC/TFC_CrystalClock.c ****     return 0x2;                                                     // return error code
1648:../Sources/TFC/TFC_CrystalClock.c ****   } 
1649:../Sources/TFC/TFC_CrystalClock.c ****       
1650:../Sources/TFC/TFC_CrystalClock.c **** // Check IRC frequency is within spec.
1651:../Sources/TFC/TFC_CrystalClock.c ****   if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
1652:../Sources/TFC/TFC_CrystalClock.c ****   {
1653:../Sources/TFC/TFC_CrystalClock.c ****     return 0x31;
1654:../Sources/TFC/TFC_CrystalClock.c ****   }
1655:../Sources/TFC/TFC_CrystalClock.c **** 
1656:../Sources/TFC/TFC_CrystalClock.c ****   // Check resulting FLL frequency 
1657:../Sources/TFC/TFC_CrystalClock.c ****   mcg_out = fll_freq(slow_irc_freq); 
1658:../Sources/TFC/TFC_CrystalClock.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
1659:../Sources/TFC/TFC_CrystalClock.c ****   
1660:../Sources/TFC/TFC_CrystalClock.c **** // Ensure clock monitor is disabled before switching to FEI otherwise a loss of clock will trigger
1661:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 &= ~MCG_C6_CME0_MASK;
1662:../Sources/TFC/TFC_CrystalClock.c **** 
1663:../Sources/TFC/TFC_CrystalClock.c **** // Change FLL reference clock from external to internal by setting IREFS bit
1664:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 |= MCG_C1_IREFS_MASK; // select internal reference
1665:../Sources/TFC/TFC_CrystalClock.c ****   
1666:../Sources/TFC/TFC_CrystalClock.c **** // wait for Reference clock to switch to internal reference 
1667:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
1668:../Sources/TFC/TFC_CrystalClock.c ****   {
1669:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
1670:../Sources/TFC/TFC_CrystalClock.c ****   }
1671:../Sources/TFC/TFC_CrystalClock.c ****   if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error i
1672:../Sources/TFC/TFC_CrystalClock.c ****   
1673:../Sources/TFC/TFC_CrystalClock.c **** // Now in FEI mode  
1674:../Sources/TFC/TFC_CrystalClock.c ****   return mcg_out;  
1675:../Sources/TFC/TFC_CrystalClock.c **** } // fee_fei
1676:../Sources/TFC/TFC_CrystalClock.c **** 
1677:../Sources/TFC/TFC_CrystalClock.c **** 
1678:../Sources/TFC/TFC_CrystalClock.c **** 
1679:../Sources/TFC/TFC_CrystalClock.c **** unsigned char atc(unsigned char irc_select, int irc_freq, int mcg_out_freq)
1680:../Sources/TFC/TFC_CrystalClock.c **** {
1681:../Sources/TFC/TFC_CrystalClock.c ****   unsigned char mcg_mode;
1682:../Sources/TFC/TFC_CrystalClock.c ****   unsigned short atcv;
1683:../Sources/TFC/TFC_CrystalClock.c ****   int bus_clock_freq;
1684:../Sources/TFC/TFC_CrystalClock.c ****   int  bus_clk_div_val;
1685:../Sources/TFC/TFC_CrystalClock.c ****   int orig_div;
1686:../Sources/TFC/TFC_CrystalClock.c ****   int temp_reg;
1687:../Sources/TFC/TFC_CrystalClock.c ****   
1688:../Sources/TFC/TFC_CrystalClock.c ****   if (irc_select > 0) // force irc to 1 if greater than 0
1689:../Sources/TFC/TFC_CrystalClock.c ****   {
1690:../Sources/TFC/TFC_CrystalClock.c ****     irc_select = 1;
1691:../Sources/TFC/TFC_CrystalClock.c ****   }
1692:../Sources/TFC/TFC_CrystalClock.c ****   
1693:../Sources/TFC/TFC_CrystalClock.c ****   mcg_mode = what_mcg_mode(); // get present MCG mode
1694:../Sources/TFC/TFC_CrystalClock.c ****   if ((mcg_mode != PEE) && (mcg_mode != PBE) && (mcg_mode != FBE))
1695:../Sources/TFC/TFC_CrystalClock.c ****   {
1696:../Sources/TFC/TFC_CrystalClock.c ****     return 1; // return error code if not in PEE, PBE or FBE modes
1697:../Sources/TFC/TFC_CrystalClock.c ****   }
1698:../Sources/TFC/TFC_CrystalClock.c ****   
1699:../Sources/TFC/TFC_CrystalClock.c ****   orig_div = SIM_CLKDIV1; //store present clock divider values
1700:../Sources/TFC/TFC_CrystalClock.c ****   
1701:../Sources/TFC/TFC_CrystalClock.c ****   bus_clk_div_val = mcg_out_freq / 16000000; // calculate bus clock divider to generate fastest all
1702:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = SIM_CLKDIV1;
1703:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~SIM_CLKDIV1_OUTDIV4_MASK; // clear dividers except core
1704:../Sources/TFC/TFC_CrystalClock.c ****   // set all bus and flash dividers to same value to ensure clocking restrictions are met
1705:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= SIM_CLKDIV1_OUTDIV4(bus_clk_div_val);
1706:../Sources/TFC/TFC_CrystalClock.c ****   SIM_CLKDIV1 = temp_reg; // set actual dividers
1707:../Sources/TFC/TFC_CrystalClock.c ****   
1708:../Sources/TFC/TFC_CrystalClock.c ****   bus_clock_freq = mcg_out_freq / (((SIM_CLKDIV1) >> 16)+ 1);//For KL25, flash and bus use the same
1709:../Sources/TFC/TFC_CrystalClock.c ****   if ((bus_clock_freq < 8000000) || (bus_clock_freq > 16000000))
1710:../Sources/TFC/TFC_CrystalClock.c ****   {
1711:../Sources/TFC/TFC_CrystalClock.c ****     SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
1712:../Sources/TFC/TFC_CrystalClock.c ****     return 3; // error, bus clock frequency is not within 8MHz to 16MHz
1713:../Sources/TFC/TFC_CrystalClock.c ****   }
1714:../Sources/TFC/TFC_CrystalClock.c ****                 
1715:../Sources/TFC/TFC_CrystalClock.c ****   if(!irc_select) //determine if slow or fast IRC to be trimmed
1716:../Sources/TFC/TFC_CrystalClock.c ****   {
1717:../Sources/TFC/TFC_CrystalClock.c ****     if (irc_freq < 31250) // check frequency is above min spec.
1718:../Sources/TFC/TFC_CrystalClock.c ****     {
1719:../Sources/TFC/TFC_CrystalClock.c ****       SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
1720:../Sources/TFC/TFC_CrystalClock.c ****       return 4;
1721:../Sources/TFC/TFC_CrystalClock.c ****     }
1722:../Sources/TFC/TFC_CrystalClock.c ****     if (irc_freq > 39062) // check frequency is below max spec.
1723:../Sources/TFC/TFC_CrystalClock.c ****     {
1724:../Sources/TFC/TFC_CrystalClock.c ****       SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
1725:../Sources/TFC/TFC_CrystalClock.c ****       return 5;
1726:../Sources/TFC/TFC_CrystalClock.c ****     }         
1727:../Sources/TFC/TFC_CrystalClock.c ****   }
1728:../Sources/TFC/TFC_CrystalClock.c ****   else
1729:../Sources/TFC/TFC_CrystalClock.c ****   {
1730:../Sources/TFC/TFC_CrystalClock.c ****     if (irc_freq < 3000000) // check frequency is above min spec.
1731:../Sources/TFC/TFC_CrystalClock.c ****     {
1732:../Sources/TFC/TFC_CrystalClock.c ****       SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
1733:../Sources/TFC/TFC_CrystalClock.c ****       return 6;
1734:../Sources/TFC/TFC_CrystalClock.c ****     }
1735:../Sources/TFC/TFC_CrystalClock.c ****     if (irc_freq > 5000000) // check frequency is below max spec.
1736:../Sources/TFC/TFC_CrystalClock.c ****     {
1737:../Sources/TFC/TFC_CrystalClock.c ****       SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
1738:../Sources/TFC/TFC_CrystalClock.c ****       return 7;
1739:../Sources/TFC/TFC_CrystalClock.c ****     }            
1740:../Sources/TFC/TFC_CrystalClock.c ****   } // if
1741:../Sources/TFC/TFC_CrystalClock.c ****         
1742:../Sources/TFC/TFC_CrystalClock.c **** // Set up autocal registers, must use floating point calculation
1743:../Sources/TFC/TFC_CrystalClock.c ****   if (irc_select) 
1744:../Sources/TFC/TFC_CrystalClock.c ****     atcv = (unsigned short)(128.0f * (21.0f * (bus_clock_freq / (float)irc_freq)));
1745:../Sources/TFC/TFC_CrystalClock.c ****   else
1746:../Sources/TFC/TFC_CrystalClock.c ****     atcv = (unsigned short)(21.0f * (bus_clock_freq / (float)irc_freq));
1747:../Sources/TFC/TFC_CrystalClock.c ****         
1748:../Sources/TFC/TFC_CrystalClock.c ****   MCG_ATCVL = (atcv & 0xFF); //Set ATCVL to lower 8 bits of count value
1749:../Sources/TFC/TFC_CrystalClock.c ****   MCG_ATCVH = ((atcv & 0xFF00) >> 8); // Set ATCVH to upper 8 bits of count value
1750:../Sources/TFC/TFC_CrystalClock.c **** 
1751:../Sources/TFC/TFC_CrystalClock.c **** // Enable autocal
1752:../Sources/TFC/TFC_CrystalClock.c ****   MCG_SC &= ~(MCG_SC_ATME_MASK | MCG_SC_ATMS_MASK |MCG_SC_ATMF_MASK); // clear auto trim settings
1753:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = (MCG_SC_ATME_MASK | (irc_select << MCG_SC_ATMS_SHIFT)); //Select IRC to trim and enabl
1754:../Sources/TFC/TFC_CrystalClock.c ****   MCG_SC |= temp_reg;
1755:../Sources/TFC/TFC_CrystalClock.c ****         
1756:../Sources/TFC/TFC_CrystalClock.c ****   while (MCG_SC & MCG_SC_ATME_MASK) {}; //poll for ATME bit to clear
1757:../Sources/TFC/TFC_CrystalClock.c ****         
1758:../Sources/TFC/TFC_CrystalClock.c ****   if (MCG_SC & MCG_SC_ATMF_MASK) // check if error flag set
1759:../Sources/TFC/TFC_CrystalClock.c ****   {
1760:../Sources/TFC/TFC_CrystalClock.c ****     SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
1761:../Sources/TFC/TFC_CrystalClock.c ****     return 8;
1762:../Sources/TFC/TFC_CrystalClock.c ****   } 
1763:../Sources/TFC/TFC_CrystalClock.c ****   else 
1764:../Sources/TFC/TFC_CrystalClock.c ****   {      
1765:../Sources/TFC/TFC_CrystalClock.c ****     if (!irc_select)
1766:../Sources/TFC/TFC_CrystalClock.c ****     {
1767:../Sources/TFC/TFC_CrystalClock.c ****       if ((MCG_C3 == 0xFF) || (MCG_C3 == 0))
1768:../Sources/TFC/TFC_CrystalClock.c ****       {
1769:../Sources/TFC/TFC_CrystalClock.c ****         SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
1770:../Sources/TFC/TFC_CrystalClock.c ****         return 9;
1771:../Sources/TFC/TFC_CrystalClock.c ****       }
1772:../Sources/TFC/TFC_CrystalClock.c ****     }
1773:../Sources/TFC/TFC_CrystalClock.c ****     else
1774:../Sources/TFC/TFC_CrystalClock.c ****     {
1775:../Sources/TFC/TFC_CrystalClock.c ****       if ((((MCG_C4 & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT) == 0xF) ||
1776:../Sources/TFC/TFC_CrystalClock.c ****           (((MCG_C4 & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT) == 0))
1777:../Sources/TFC/TFC_CrystalClock.c ****       {
1778:../Sources/TFC/TFC_CrystalClock.c ****         SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
1779:../Sources/TFC/TFC_CrystalClock.c ****         return 10;
1780:../Sources/TFC/TFC_CrystalClock.c ****       }
1781:../Sources/TFC/TFC_CrystalClock.c ****     }
1782:../Sources/TFC/TFC_CrystalClock.c ****   }
1783:../Sources/TFC/TFC_CrystalClock.c ****   SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
1784:../Sources/TFC/TFC_CrystalClock.c ****   return 0;
1785:../Sources/TFC/TFC_CrystalClock.c **** }// atc
1786:../Sources/TFC/TFC_CrystalClock.c **** 
1787:../Sources/TFC/TFC_CrystalClock.c **** 
1788:../Sources/TFC/TFC_CrystalClock.c **** 
1789:../Sources/TFC/TFC_CrystalClock.c **** 
1790:../Sources/TFC/TFC_CrystalClock.c **** int fll_freq(int fll_ref)
  25              		.loc 1 1790 0
  26              		.cfi_startproc
  27              	.LVL0:
  28 0000 00B5     		push	{lr}
  29              	.LCFI0:
  30              		.cfi_def_cfa_offset 4
  31              		.cfi_offset 14, -4
1791:../Sources/TFC/TFC_CrystalClock.c **** {
1792:../Sources/TFC/TFC_CrystalClock.c ****   int fll_freq_hz = 0;
1793:../Sources/TFC/TFC_CrystalClock.c ****   
1794:../Sources/TFC/TFC_CrystalClock.c ****   // Check that only allowed ranges have been selected
1795:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) > 0x1) 
1796:../Sources/TFC/TFC_CrystalClock.c ****   {
1797:../Sources/TFC/TFC_CrystalClock.c ****     return 0x3B; // return error code if DRS range 2 or 3 selected
1798:../Sources/TFC/TFC_CrystalClock.c ****   }
1799:../Sources/TFC/TFC_CrystalClock.c ****   
1800:../Sources/TFC/TFC_CrystalClock.c ****   if (MCG_C4 & MCG_C4_DMX32_MASK) // if DMX32 set
  32              		.loc 1 1800 0
  33 0002 2F4B     		ldr	r3, .L34
  34 0004 DA78     		ldrb	r2, [r3, #3]
1801:../Sources/TFC/TFC_CrystalClock.c ****   {
1802:../Sources/TFC/TFC_CrystalClock.c ****     switch ((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) // determine multiplier based
  35              		.loc 1 1802 0
  36 0006 DB78     		ldrb	r3, [r3, #3]
1800:../Sources/TFC/TFC_CrystalClock.c ****   if (MCG_C4 & MCG_C4_DMX32_MASK) // if DMX32 set
  37              		.loc 1 1800 0
  38 0008 51B2     		sxtb	r1, r2
  39              		.loc 1 1802 0
  40 000a 5A06     		lsl	r2, r3, #25
  41 000c 930F     		lsr	r3, r2, #30
1800:../Sources/TFC/TFC_CrystalClock.c ****   if (MCG_C4 & MCG_C4_DMX32_MASK) // if DMX32 set
  42              		.loc 1 1800 0
  43 000e 0029     		cmp	r1, #0
  44 0010 0DDB     		blt	.L33
1803:../Sources/TFC/TFC_CrystalClock.c ****     {
1804:../Sources/TFC/TFC_CrystalClock.c ****     case 0:
1805:../Sources/TFC/TFC_CrystalClock.c ****       fll_freq_hz = (fll_ref * 732);
1806:../Sources/TFC/TFC_CrystalClock.c ****       if (fll_freq_hz < 20000000) {return 0x33;}
1807:../Sources/TFC/TFC_CrystalClock.c ****       else if (fll_freq_hz > 25000000) {return 0x34;}
1808:../Sources/TFC/TFC_CrystalClock.c ****       break;
1809:../Sources/TFC/TFC_CrystalClock.c ****     case 1:
1810:../Sources/TFC/TFC_CrystalClock.c ****       fll_freq_hz = (fll_ref * 1464);
1811:../Sources/TFC/TFC_CrystalClock.c ****       if (fll_freq_hz < 40000000) {return 0x35;}
1812:../Sources/TFC/TFC_CrystalClock.c ****       else if (fll_freq_hz > 50000000) {return 0x36;}
1813:../Sources/TFC/TFC_CrystalClock.c ****       break;
1814:../Sources/TFC/TFC_CrystalClock.c ****     case 2:
1815:../Sources/TFC/TFC_CrystalClock.c ****       fll_freq_hz = (fll_ref * 2197);
1816:../Sources/TFC/TFC_CrystalClock.c ****       if (fll_freq_hz < 60000000) {return 0x37;}
1817:../Sources/TFC/TFC_CrystalClock.c ****       else if (fll_freq_hz > 75000000) {return 0x38;}
1818:../Sources/TFC/TFC_CrystalClock.c ****       break;
1819:../Sources/TFC/TFC_CrystalClock.c ****     case 3:
1820:../Sources/TFC/TFC_CrystalClock.c ****       fll_freq_hz = (fll_ref * 2929);
1821:../Sources/TFC/TFC_CrystalClock.c ****       if (fll_freq_hz < 80000000) {return 0x39;}
1822:../Sources/TFC/TFC_CrystalClock.c ****       else if (fll_freq_hz > 100000000) {return 0x3A;}
1823:../Sources/TFC/TFC_CrystalClock.c ****       break;
1824:../Sources/TFC/TFC_CrystalClock.c ****     }
1825:../Sources/TFC/TFC_CrystalClock.c ****   }
1826:../Sources/TFC/TFC_CrystalClock.c ****   else // if DMX32 = 0
1827:../Sources/TFC/TFC_CrystalClock.c ****   {
1828:../Sources/TFC/TFC_CrystalClock.c ****     switch ((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) // determine multiplier based
  45              		.loc 1 1828 0
  46 0012 022B     		cmp	r3, #2
  47 0014 35D0     		beq	.L10
  48 0016 032B     		cmp	r3, #3
  49 0018 1AD0     		beq	.L11
  50 001a 012B     		cmp	r3, #1
  51 001c 3CD0     		beq	.L9
1829:../Sources/TFC/TFC_CrystalClock.c ****     {
1830:../Sources/TFC/TFC_CrystalClock.c ****     case 0:
1831:../Sources/TFC/TFC_CrystalClock.c ****       fll_freq_hz = (fll_ref * 640);
  52              		.loc 1 1831 0
  53 001e 8100     		lsl	r1, r0, #2
1832:../Sources/TFC/TFC_CrystalClock.c ****       if (fll_freq_hz < 20000000) {return 0x33;}
  54              		.loc 1 1832 0
  55 0020 284A     		ldr	r2, .L34+4
1831:../Sources/TFC/TFC_CrystalClock.c ****       fll_freq_hz = (fll_ref * 640);
  56              		.loc 1 1831 0
  57 0022 0818     		add	r0, r1, r0
  58              	.LVL1:
  59 0024 C001     		lsl	r0, r0, #7
  60              	.LVL2:
  61              		.loc 1 1832 0
  62 0026 9042     		cmp	r0, r2
  63 0028 0DDC     		bgt	.L25
  64              	.L16:
1806:../Sources/TFC/TFC_CrystalClock.c ****       if (fll_freq_hz < 20000000) {return 0x33;}
  65              		.loc 1 1806 0
  66 002a 3320     		mov	r0, #51
  67              	.LVL3:
  68 002c 17E0     		b	.L7
  69              	.LVL4:
  70              	.L33:
1802:../Sources/TFC/TFC_CrystalClock.c ****     switch ((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) // determine multiplier based
  71              		.loc 1 1802 0
  72 002e 022B     		cmp	r3, #2
  73 0030 16D0     		beq	.L5
  74 0032 032B     		cmp	r3, #3
  75 0034 1BD0     		beq	.L6
  76 0036 012B     		cmp	r3, #1
  77 0038 36D0     		beq	.L4
1805:../Sources/TFC/TFC_CrystalClock.c ****       fll_freq_hz = (fll_ref * 732);
  78              		.loc 1 1805 0
  79 003a B722     		mov	r2, #183
  80 003c 9300     		lsl	r3, r2, #2
  81 003e 5843     		mul	r0, r3
  82              	.LVL5:
1806:../Sources/TFC/TFC_CrystalClock.c ****       if (fll_freq_hz < 20000000) {return 0x33;}
  83              		.loc 1 1806 0
  84 0040 2049     		ldr	r1, .L34+4
  85 0042 8842     		cmp	r0, r1
  86 0044 F1DD     		ble	.L16
  87              	.L25:
1833:../Sources/TFC/TFC_CrystalClock.c ****       else if (fll_freq_hz > 25000000) {return 0x34;}
  88              		.loc 1 1833 0
  89 0046 204A     		ldr	r2, .L34+8
  90 0048 9042     		cmp	r0, r2
  91 004a 08DD     		ble	.L7
1807:../Sources/TFC/TFC_CrystalClock.c ****       else if (fll_freq_hz > 25000000) {return 0x34;}
  92              		.loc 1 1807 0
  93 004c 3420     		mov	r0, #52
  94              	.LVL6:
  95 004e 06E0     		b	.L7
  96              	.LVL7:
  97              	.L11:
1834:../Sources/TFC/TFC_CrystalClock.c ****       break;
1835:../Sources/TFC/TFC_CrystalClock.c ****     case 1:
1836:../Sources/TFC/TFC_CrystalClock.c ****       fll_freq_hz = (fll_ref * 1280);
1837:../Sources/TFC/TFC_CrystalClock.c ****       if (fll_freq_hz < 40000000) {return 0x35;}
1838:../Sources/TFC/TFC_CrystalClock.c ****       else if (fll_freq_hz > 50000000) {return 0x36;}
1839:../Sources/TFC/TFC_CrystalClock.c ****       break;
1840:../Sources/TFC/TFC_CrystalClock.c ****     case 2:
1841:../Sources/TFC/TFC_CrystalClock.c ****       fll_freq_hz = (fll_ref * 1920);
1842:../Sources/TFC/TFC_CrystalClock.c ****       if (fll_freq_hz < 60000000) {return 0x37;}
1843:../Sources/TFC/TFC_CrystalClock.c ****       else if (fll_freq_hz > 75000000) {return 0x38;}
1844:../Sources/TFC/TFC_CrystalClock.c ****       break;
1845:../Sources/TFC/TFC_CrystalClock.c ****     case 3:
1846:../Sources/TFC/TFC_CrystalClock.c ****       fll_freq_hz = (fll_ref * 2560);
  98              		.loc 1 1846 0
  99 0050 8300     		lsl	r3, r0, #2
1847:../Sources/TFC/TFC_CrystalClock.c ****       if (fll_freq_hz < 80000000) {return 0x39;}
 100              		.loc 1 1847 0
 101 0052 1E49     		ldr	r1, .L34+12
1846:../Sources/TFC/TFC_CrystalClock.c ****       fll_freq_hz = (fll_ref * 2560);
 102              		.loc 1 1846 0
 103 0054 1818     		add	r0, r3, r0
 104              	.LVL8:
 105 0056 4002     		lsl	r0, r0, #9
 106              	.LVL9:
 107              		.loc 1 1847 0
 108 0058 8842     		cmp	r0, r1
 109 005a 0DDC     		bgt	.L31
 110              	.L19:
1821:../Sources/TFC/TFC_CrystalClock.c ****       if (fll_freq_hz < 80000000) {return 0x39;}
 111              		.loc 1 1821 0
 112 005c 3920     		mov	r0, #57
 113              	.LVL10:
 114              	.L7:
1848:../Sources/TFC/TFC_CrystalClock.c ****       else if (fll_freq_hz > 100000000) {return 0x3A;}
1849:../Sources/TFC/TFC_CrystalClock.c ****       break;
1850:../Sources/TFC/TFC_CrystalClock.c ****     }
1851:../Sources/TFC/TFC_CrystalClock.c ****   }    
1852:../Sources/TFC/TFC_CrystalClock.c ****   return fll_freq_hz;
1853:../Sources/TFC/TFC_CrystalClock.c **** } // fll_freq
 115              		.loc 1 1853 0
 116              		@ sp needed for prologue
 117 005e 00BD     		pop	{pc}
 118              	.LVL11:
 119              	.L5:
1815:../Sources/TFC/TFC_CrystalClock.c ****       fll_freq_hz = (fll_ref * 2197);
 120              		.loc 1 1815 0
 121 0060 1B49     		ldr	r1, .L34+16
1816:../Sources/TFC/TFC_CrystalClock.c ****       if (fll_freq_hz < 60000000) {return 0x37;}
 122              		.loc 1 1816 0
 123 0062 1C4A     		ldr	r2, .L34+20
1815:../Sources/TFC/TFC_CrystalClock.c ****       fll_freq_hz = (fll_ref * 2197);
 124              		.loc 1 1815 0
 125 0064 4843     		mul	r0, r1
 126              	.LVL12:
1816:../Sources/TFC/TFC_CrystalClock.c ****       if (fll_freq_hz < 60000000) {return 0x37;}
 127              		.loc 1 1816 0
 128 0066 9042     		cmp	r0, r2
 129 0068 11DC     		bgt	.L29
 130              	.L18:
 131 006a 3720     		mov	r0, #55
 132              	.LVL13:
 133 006c F7E7     		b	.L7
 134              	.LVL14:
 135              	.L6:
1820:../Sources/TFC/TFC_CrystalClock.c ****       fll_freq_hz = (fll_ref * 2929);
 136              		.loc 1 1820 0
 137 006e 1A49     		ldr	r1, .L34+24
1821:../Sources/TFC/TFC_CrystalClock.c ****       if (fll_freq_hz < 80000000) {return 0x39;}
 138              		.loc 1 1821 0
 139 0070 164A     		ldr	r2, .L34+12
1820:../Sources/TFC/TFC_CrystalClock.c ****       fll_freq_hz = (fll_ref * 2929);
 140              		.loc 1 1820 0
 141 0072 4843     		mul	r0, r1
 142              	.LVL15:
1821:../Sources/TFC/TFC_CrystalClock.c ****       if (fll_freq_hz < 80000000) {return 0x39;}
 143              		.loc 1 1821 0
 144 0074 9042     		cmp	r0, r2
 145 0076 F1DD     		ble	.L19
 146              	.L31:
1848:../Sources/TFC/TFC_CrystalClock.c ****       else if (fll_freq_hz > 100000000) {return 0x3A;}
 147              		.loc 1 1848 0
 148 0078 184B     		ldr	r3, .L34+28
 149 007a 9842     		cmp	r0, r3
 150 007c EFDD     		ble	.L7
1822:../Sources/TFC/TFC_CrystalClock.c ****       else if (fll_freq_hz > 100000000) {return 0x3A;}
 151              		.loc 1 1822 0
 152 007e 3A20     		mov	r0, #58
 153              	.LVL16:
 154 0080 EDE7     		b	.L7
 155              	.LVL17:
 156              	.L10:
1841:../Sources/TFC/TFC_CrystalClock.c ****       fll_freq_hz = (fll_ref * 1920);
 157              		.loc 1 1841 0
 158 0082 0201     		lsl	r2, r0, #4
1842:../Sources/TFC/TFC_CrystalClock.c ****       if (fll_freq_hz < 60000000) {return 0x37;}
 159              		.loc 1 1842 0
 160 0084 1349     		ldr	r1, .L34+20
1841:../Sources/TFC/TFC_CrystalClock.c ****       fll_freq_hz = (fll_ref * 1920);
 161              		.loc 1 1841 0
 162 0086 131A     		sub	r3, r2, r0
 163 0088 D801     		lsl	r0, r3, #7
 164              	.LVL18:
1842:../Sources/TFC/TFC_CrystalClock.c ****       if (fll_freq_hz < 60000000) {return 0x37;}
 165              		.loc 1 1842 0
 166 008a 8842     		cmp	r0, r1
 167 008c EDDD     		ble	.L18
 168              	.L29:
1843:../Sources/TFC/TFC_CrystalClock.c ****       else if (fll_freq_hz > 75000000) {return 0x38;}
 169              		.loc 1 1843 0
 170 008e 144B     		ldr	r3, .L34+32
 171 0090 9842     		cmp	r0, r3
 172 0092 E4DD     		ble	.L7
1817:../Sources/TFC/TFC_CrystalClock.c ****       else if (fll_freq_hz > 75000000) {return 0x38;}
 173              		.loc 1 1817 0
 174 0094 3820     		mov	r0, #56
 175              	.LVL19:
 176 0096 E2E7     		b	.L7
 177              	.LVL20:
 178              	.L9:
1836:../Sources/TFC/TFC_CrystalClock.c ****       fll_freq_hz = (fll_ref * 1280);
 179              		.loc 1 1836 0
 180 0098 8300     		lsl	r3, r0, #2
1837:../Sources/TFC/TFC_CrystalClock.c ****       if (fll_freq_hz < 40000000) {return 0x35;}
 181              		.loc 1 1837 0
 182 009a 124A     		ldr	r2, .L34+36
1836:../Sources/TFC/TFC_CrystalClock.c ****       fll_freq_hz = (fll_ref * 1280);
 183              		.loc 1 1836 0
 184 009c 1918     		add	r1, r3, r0
 185 009e 0802     		lsl	r0, r1, #8
 186              	.LVL21:
1837:../Sources/TFC/TFC_CrystalClock.c ****       if (fll_freq_hz < 40000000) {return 0x35;}
 187              		.loc 1 1837 0
 188 00a0 9042     		cmp	r0, r2
 189 00a2 07DC     		bgt	.L27
 190              	.L17:
1811:../Sources/TFC/TFC_CrystalClock.c ****       if (fll_freq_hz < 40000000) {return 0x35;}
 191              		.loc 1 1811 0
 192 00a4 3520     		mov	r0, #53
 193              	.LVL22:
 194 00a6 DAE7     		b	.L7
 195              	.LVL23:
 196              	.L4:
1810:../Sources/TFC/TFC_CrystalClock.c ****       fll_freq_hz = (fll_ref * 1464);
 197              		.loc 1 1810 0
 198 00a8 B723     		mov	r3, #183
 199 00aa D900     		lsl	r1, r3, #3
 200 00ac 4843     		mul	r0, r1
 201              	.LVL24:
1811:../Sources/TFC/TFC_CrystalClock.c ****       if (fll_freq_hz < 40000000) {return 0x35;}
 202              		.loc 1 1811 0
 203 00ae 0D4A     		ldr	r2, .L34+36
 204 00b0 9042     		cmp	r0, r2
 205 00b2 F7DD     		ble	.L17
 206              	.L27:
1838:../Sources/TFC/TFC_CrystalClock.c ****       else if (fll_freq_hz > 50000000) {return 0x36;}
 207              		.loc 1 1838 0
 208 00b4 0C4B     		ldr	r3, .L34+40
 209 00b6 9842     		cmp	r0, r3
 210 00b8 D1DD     		ble	.L7
1812:../Sources/TFC/TFC_CrystalClock.c ****       else if (fll_freq_hz > 50000000) {return 0x36;}
 211              		.loc 1 1812 0
 212 00ba 3620     		mov	r0, #54
 213              	.LVL25:
 214 00bc CFE7     		b	.L7
 215              	.L35:
 216 00be C046     		.align	2
 217              	.L34:
 218 00c0 00400640 		.word	1074151424
 219 00c4 FF2C3101 		.word	19999999
 220 00c8 40787D01 		.word	25000000
 221 00cc FFB3C404 		.word	79999999
 222 00d0 95080000 		.word	2197
 223 00d4 FF869303 		.word	59999999
 224 00d8 710B0000 		.word	2929
 225 00dc 00E1F505 		.word	100000000
 226 00e0 C0687804 		.word	75000000
 227 00e4 FF596202 		.word	39999999
 228 00e8 80F0FA02 		.word	50000000
 229              		.cfi_endproc
 230              	.LFE28:
 232              		.global	__aeabi_idiv
 233              		.section	.text.pll_init,"ax",%progbits
 234              		.align	2
 235              		.global	pll_init
 236              		.code	16
 237              		.thumb_func
 239              	pll_init:
 240              	.LFB1:
 183:../Sources/TFC/TFC_CrystalClock.c **** {
 241              		.loc 1 183 0
 242              		.cfi_startproc
 243              	.LVL26:
 244 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 245              	.LCFI1:
 246              		.cfi_def_cfa_offset 24
 247              		.cfi_offset 3, -24
 248              		.cfi_offset 4, -20
 249              		.cfi_offset 5, -16
 250              		.cfi_offset 6, -12
 251              		.cfi_offset 7, -8
 252              		.cfi_offset 14, -4
 253 0002 5746     		mov	r7, sl
 254 0004 4E46     		mov	r6, r9
 255 0006 C0B4     		push	{r6, r7}
 256              	.LCFI2:
 257              		.cfi_def_cfa_offset 32
 258              		.cfi_offset 9, -32
 259              		.cfi_offset 10, -28
 192:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 260              		.loc 1 192 0
 261 0008 924C     		ldr	r4, .L124
 183:../Sources/TFC/TFC_CrystalClock.c **** {
 262              		.loc 1 183 0
 263 000a 151C     		mov	r5, r2
 264 000c 08AA     		add	r2, sp, #32
 265              	.LVL27:
 266 000e 071C     		mov	r7, r0
 192:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 267              		.loc 1 192 0
 268 0010 A679     		ldrb	r6, [r4, #6]
 183:../Sources/TFC/TFC_CrystalClock.c **** {
 269              		.loc 1 183 0
 270 0012 1078     		ldrb	r0, [r2]
 271              	.LVL28:
 272 0014 8A46     		mov	sl, r1
 192:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 273              		.loc 1 192 0
 274 0016 3207     		lsl	r2, r6, #28
 183:../Sources/TFC/TFC_CrystalClock.c **** {
 275              		.loc 1 183 0
 276 0018 41B2     		sxtb	r1, r0
 277              	.LVL29:
 278 001a 8946     		mov	r9, r1
 196:../Sources/TFC/TFC_CrystalClock.c ****     return 0x1;                                                     // return error code
 279              		.loc 1 196 0
 280 001c 0120     		mov	r0, #1
 192:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 281              		.loc 1 192 0
 282 001e 910F     		lsr	r1, r2, #30
 283 0020 09D1     		bne	.L37
 193:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 284              		.loc 1 193 0
 285 0022 A679     		ldrb	r6, [r4, #6]
 192:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 286              		.loc 1 192 0
 287 0024 F106     		lsl	r1, r6, #27
 288 0026 06D5     		bpl	.L37
 194:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selecte
 289              		.loc 1 194 0
 290 0028 A479     		ldrb	r4, [r4, #6]
 192:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 291              		.loc 1 192 0
 292 002a A106     		lsl	r1, r4, #26
 293 002c 03D4     		bmi	.L37
 200:../Sources/TFC/TFC_CrystalClock.c ****   if  (crystal_val > 50000000) {return 0x21;}
 294              		.loc 1 200 0
 295 002e 8A4A     		ldr	r2, .L124+4
 296 0030 2120     		mov	r0, #33
 297 0032 9742     		cmp	r7, r2
 298 0034 03DD     		ble	.L116
 299              	.LVL30:
 300              	.L37:
 337:../Sources/TFC/TFC_CrystalClock.c **** } // pll_init
 301              		.loc 1 337 0
 302              		@ sp needed for prologue
 303              	.LVL31:
 304 0036 0CBC     		pop	{r2, r3}
 305 0038 9146     		mov	r9, r2
 306 003a 9A46     		mov	sl, r3
 307 003c F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 308              	.LVL32:
 309              	.L116:
 203:../Sources/TFC/TFC_CrystalClock.c ****   if (erefs_val)
 310              		.loc 1 203 0
 311 003e 002D     		cmp	r5, #0
 312 0040 00D0     		beq	.LCB308
 313 0042 E0E0     		b	.L117	@long jump
 314              	.LCB308:
 315              	.L38:
 316              	.LVL33:
 215:../Sources/TFC/TFC_CrystalClock.c ****   if ((prdiv_val < 1) || (prdiv_val > 25)) {return 0x41;}
 317              		.loc 1 215 0
 318 0044 5C1E     		sub	r4, r3, #1
 319 0046 E4B2     		uxtb	r4, r4
 320 0048 4120     		mov	r0, #65
 321 004a 182C     		cmp	r4, #24
 322 004c F3D8     		bhi	.L37
 216:../Sources/TFC/TFC_CrystalClock.c ****   if ((vdiv_val < 24) || (vdiv_val > 50)) {return 0x42;}
 323              		.loc 1 216 0
 324 004e 4A46     		mov	r2, r9
 325 0050 183A     		sub	r2, r2, #24
 326 0052 D6B2     		uxtb	r6, r2
 327 0054 4220     		mov	r0, #66
 328 0056 1A2E     		cmp	r6, #26
 329 0058 EDD8     		bhi	.L37
 219:../Sources/TFC/TFC_CrystalClock.c ****   ref_freq = crystal_val / prdiv_val;
 330              		.loc 1 219 0
 331 005a 191C     		mov	r1, r3
 332 005c 381C     		mov	r0, r7
 333 005e FFF7FEFF 		bl	__aeabi_idiv
 334              	.LVL34:
 220:../Sources/TFC/TFC_CrystalClock.c ****   if ((ref_freq < 2000000) || (ref_freq > 4000000)) {return 0x43;}
 335              		.loc 1 220 0
 336 0062 7E4B     		ldr	r3, .L124+8
 219:../Sources/TFC/TFC_CrystalClock.c ****   ref_freq = crystal_val / prdiv_val;
 337              		.loc 1 219 0
 338 0064 011C     		mov	r1, r0
 339              	.LVL35:
 220:../Sources/TFC/TFC_CrystalClock.c ****   if ((ref_freq < 2000000) || (ref_freq > 4000000)) {return 0x43;}
 340              		.loc 1 220 0
 341 0066 C218     		add	r2, r0, r3
 342 0068 7D4B     		ldr	r3, .L124+12
 343 006a 4320     		mov	r0, #67
 344              	.LVL36:
 345 006c 9A42     		cmp	r2, r3
 346 006e E2D8     		bhi	.L37
 347              	.LVL37:
 223:../Sources/TFC/TFC_CrystalClock.c ****   pll_freq = (crystal_val / prdiv_val) * vdiv_val;
 348              		.loc 1 223 0
 349 0070 4846     		mov	r0, r9
 350 0072 4843     		mul	r0, r1
 224:../Sources/TFC/TFC_CrystalClock.c ****   if ((pll_freq < 48000000) || (pll_freq > 100000000)) {return 0x45;}
 351              		.loc 1 224 0
 352 0074 7B49     		ldr	r1, .L124+16
 353              	.LVL38:
 354 0076 7C4B     		ldr	r3, .L124+20
 355 0078 4218     		add	r2, r0, r1
 356              	.LVL39:
 357 007a 4520     		mov	r0, #69
 358 007c 9A42     		cmp	r2, r3
 359 007e DAD8     		bhi	.L37
 211:../Sources/TFC/TFC_CrystalClock.c ****     hgo_val = 1; // force hgo_val to 1 if > 0
 360              		.loc 1 211 0
 361 0080 5246     		mov	r2, sl
 362 0082 531E     		sub	r3, r2, #1
 363 0084 9A41     		sbc	r2, r2, r3
 230:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C2;
 364              		.loc 1 230 0
 365 0086 734B     		ldr	r3, .L124
 231:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
 366              		.loc 1 231 0
 367 0088 3C20     		mov	r0, #60
 230:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C2;
 368              		.loc 1 230 0
 369 008a 5978     		ldrb	r1, [r3, #1]
 370              	.LVL40:
 231:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
 371              		.loc 1 231 0
 372 008c 8143     		bic	r1, r0
 373              	.LVL41:
 233:../Sources/TFC/TFC_CrystalClock.c ****   if (crystal_val <= 8000000)
 374              		.loc 1 233 0
 375 008e 7748     		ldr	r0, .L124+24
 376 0090 8742     		cmp	r7, r0
 377 0092 00DD     		ble	.LCB365
 378 0094 BFE0     		b	.L39	@long jump
 379              	.LCB365:
 235:../Sources/TFC/TFC_CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 380              		.loc 1 235 0
 381 0096 1020     		mov	r0, #16
 382 0098 0143     		orr	r1, r0
 383              	.LVL42:
 384 009a A800     		lsl	r0, r5, #2
 385 009c 0143     		orr	r1, r0
 386 009e C9B2     		uxtb	r1, r1
 387 00a0 D200     		lsl	r2, r2, #3
 245:../Sources/TFC/TFC_CrystalClock.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 388              		.loc 1 245 0
 389 00a2 7348     		ldr	r0, .L124+28
 235:../Sources/TFC/TFC_CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 390              		.loc 1 235 0
 391 00a4 0A43     		orr	r2, r1
 392              	.LVL43:
 241:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C2 = temp_reg;
 393              		.loc 1 241 0
 394 00a6 5A70     		strb	r2, [r3, #1]
 245:../Sources/TFC/TFC_CrystalClock.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 395              		.loc 1 245 0
 396 00a8 0023     		mov	r3, #0
 397 00aa 8742     		cmp	r7, r0
 398 00ac 00DD     		ble	.LCB380
 399 00ae CBE0     		b	.L118	@long jump
 400              	.LCB380:
 401              	.LVL44:
 402              	.L40:
 255:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C1;
 403              		.loc 1 255 0
 404 00b0 6849     		ldr	r1, .L124
 256:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these
 405              		.loc 1 256 0
 406 00b2 0322     		mov	r2, #3
 255:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C1;
 407              		.loc 1 255 0
 408 00b4 0878     		ldrb	r0, [r1]
 409              	.LVL45:
 257:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
 410              		.loc 1 257 0
 411 00b6 DB00     		lsl	r3, r3, #3
 412              	.LVL46:
 256:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these
 413              		.loc 1 256 0
 414 00b8 1040     		and	r0, r2
 415              	.LVL47:
 257:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
 416              		.loc 1 257 0
 417 00ba 8022     		mov	r2, #128
 418 00bc 0243     		orr	r2, r0
 419 00be 1343     		orr	r3, r2
 420              	.LVL48:
 258:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 = temp_reg;
 421              		.loc 1 258 0
 422 00c0 0B70     		strb	r3, [r1]
 261:../Sources/TFC/TFC_CrystalClock.c ****   if (erefs_val)
 423              		.loc 1 261 0
 424 00c2 002D     		cmp	r5, #0
 425 00c4 13D0     		beq	.L43
 426 00c6 6B4A     		ldr	r2, .L124+32
 265:../Sources/TFC/TFC_CrystalClock.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 427              		.loc 1 265 0
 428 00c8 0225     		mov	r5, #2
 429 00ca 08E0     		b	.L45
 430              	.LVL49:
 431              	.L119:
 432 00cc 8B79     		ldrb	r3, [r1, #6]
 433 00ce 013A     		sub	r2, r2, #1
 434 00d0 92B2     		uxth	r2, r2
 435 00d2 1D42     		tst	r5, r3
 436 00d4 06D1     		bne	.L44
 437 00d6 013A     		sub	r2, r2, #1
 438 00d8 92B2     		uxth	r2, r2
 263:../Sources/TFC/TFC_CrystalClock.c ****     for (i = 0 ; i < 20000 ; i++)
 439              		.loc 1 263 0
 440 00da 002A     		cmp	r2, #0
 441 00dc 02D0     		beq	.L44
 442              	.L45:
 265:../Sources/TFC/TFC_CrystalClock.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 443              		.loc 1 265 0
 444 00de 8879     		ldrb	r0, [r1, #6]
 445 00e0 0542     		tst	r5, r0
 446 00e2 F3D0     		beq	.L119
 447              	.L44:
 267:../Sources/TFC/TFC_CrystalClock.c ****   if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with error
 448              		.loc 1 267 0
 449 00e4 5B49     		ldr	r1, .L124
 450 00e6 2320     		mov	r0, #35
 451 00e8 8D79     		ldrb	r5, [r1, #6]
 452 00ea AA07     		lsl	r2, r5, #30
 453 00ec A3D5     		bpl	.L37
 454              	.L43:
 273:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 455              		.loc 1 273 0
 456 00ee 594A     		ldr	r2, .L124
 457 00f0 1021     		mov	r1, #16
 458 00f2 9079     		ldrb	r0, [r2, #6]
 459 00f4 0142     		tst	r1, r0
 460 00f6 11D0     		beq	.L46
 461 00f8 9579     		ldrb	r5, [r2, #6]
 462 00fa 5F4B     		ldr	r3, .L124+36
 463 00fc 2942     		tst	r1, r5
 464 00fe 0DD0     		beq	.L46
 465 0100 013B     		sub	r3, r3, #1
 466 0102 08E0     		b	.L84
 467              	.L120:
 468 0104 9579     		ldrb	r5, [r2, #6]
 469 0106 013B     		sub	r3, r3, #1
 470 0108 9BB2     		uxth	r3, r3
 471 010a 2942     		tst	r1, r5
 472 010c 06D0     		beq	.L46
 473 010e 013B     		sub	r3, r3, #1
 474 0110 9BB2     		uxth	r3, r3
 271:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 475              		.loc 1 271 0
 476 0112 002B     		cmp	r3, #0
 477 0114 02D0     		beq	.L46
 478              	.L84:
 273:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 479              		.loc 1 273 0
 480 0116 9079     		ldrb	r0, [r2, #6]
 481 0118 0142     		tst	r1, r0
 482 011a F3D1     		bne	.L120
 483              	.L46:
 275:../Sources/TFC/TFC_CrystalClock.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
 484              		.loc 1 275 0
 485 011c 4D49     		ldr	r1, .L124
 486 011e 1120     		mov	r0, #17
 487 0120 8A79     		ldrb	r2, [r1, #6]
 488 0122 D206     		lsl	r2, r2, #27
 489 0124 00D5     		bpl	.LCB514
 490 0126 86E7     		b	.L37	@long jump
 491              	.LCB514:
 492 0128 FA20     		mov	r0, #250
 493 012a C300     		lsl	r3, r0, #3
 280:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 494              		.loc 1 280 0
 495 012c 0C25     		mov	r5, #12
 496 012e 09E0     		b	.L48
 497              	.L121:
 498 0130 8879     		ldrb	r0, [r1, #6]
 499 0132 013B     		sub	r3, r3, #1
 500 0134 9BB2     		uxth	r3, r3
 501 0136 2840     		and	r0, r5
 502 0138 0828     		cmp	r0, #8
 503 013a 07D0     		beq	.L47
 504 013c 013B     		sub	r3, r3, #1
 505 013e 9BB2     		uxth	r3, r3
 278:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 506              		.loc 1 278 0
 507 0140 002B     		cmp	r3, #0
 508 0142 03D0     		beq	.L47
 509              	.L48:
 280:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 510              		.loc 1 280 0
 511 0144 8A79     		ldrb	r2, [r1, #6]
 512 0146 2A40     		and	r2, r5
 513 0148 082A     		cmp	r2, #8
 514 014a F1D1     		bne	.L121
 515              	.L47:
 282:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
 516              		.loc 1 282 0
 517 014c 414D     		ldr	r5, .L124
 518 014e 1A20     		mov	r0, #26
 519 0150 A979     		ldrb	r1, [r5, #6]
 520 0152 0A07     		lsl	r2, r1, #28
 521 0154 930F     		lsr	r3, r2, #30
 522 0156 022B     		cmp	r3, #2
 523 0158 00D0     		beq	.LCB559
 524 015a 6CE7     		b	.L37	@long jump
 525              	.LCB559:
 287:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 |= MCG_C6_CME0_MASK;
 526              		.loc 1 287 0
 527 015c 6879     		ldrb	r0, [r5, #5]
 528 015e 2021     		mov	r1, #32
 529 0160 0843     		orr	r0, r1
 530 0162 6871     		strb	r0, [r5, #5]
 292:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C5;
 531              		.loc 1 292 0
 532 0164 2B79     		ldrb	r3, [r5, #4]
 533              	.LVL50:
 293:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~MCG_C5_PRDIV0_MASK;
 534              		.loc 1 293 0
 535 0166 1F22     		mov	r2, #31
 536 0168 9343     		bic	r3, r2
 537              	.LVL51:
 294:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);    //set PLL ref divider
 538              		.loc 1 294 0
 539 016a 1C43     		orr	r4, r3
 540              	.LVL52:
 295:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C5 = temp_reg;
 541              		.loc 1 295 0
 542 016c 2C71     		strb	r4, [r5, #4]
 300:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C6; // store present C6 value
 543              		.loc 1 300 0
 544 016e 6C79     		ldrb	r4, [r5, #5]
 545              	.LVL53:
 302:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 546              		.loc 1 302 0
 547 0170 4020     		mov	r0, #64
 301:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 548              		.loc 1 301 0
 549 0172 9443     		bic	r4, r2
 550              	.LVL54:
 551 0174 231C     		mov	r3, r4
 302:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 552              		.loc 1 302 0
 553 0176 0343     		orr	r3, r0
 554 0178 1E43     		orr	r6, r3
 555              	.LVL55:
 303:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 = temp_reg; // update MCG_C6
 556              		.loc 1 303 0
 557 017a 6E71     		strb	r6, [r5, #5]
 558              	.LVL56:
 559 017c FA26     		mov	r6, #250
 560              	.LVL57:
 561 017e F200     		lsl	r2, r6, #3
 562 0180 03E0     		b	.L50
 563              	.LVL58:
 564              	.L122:
 565 0182 013A     		sub	r2, r2, #1
 566 0184 92B2     		uxth	r2, r2
 306:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 567              		.loc 1 306 0
 568 0186 002A     		cmp	r2, #0
 569 0188 02D0     		beq	.L49
 570              	.L50:
 308:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 571              		.loc 1 308 0
 572 018a AC79     		ldrb	r4, [r5, #6]
 573 018c 0C42     		tst	r4, r1
 574 018e F8D0     		beq	.L122
 575              	.L49:
 310:../Sources/TFC/TFC_CrystalClock.c ****   if (!(MCG_S & MCG_S_PLLST_MASK)) return 0x16; // check bit is really set and return with error if
 576              		.loc 1 310 0
 577 0190 304D     		ldr	r5, .L124
 578 0192 1620     		mov	r0, #22
 579 0194 A979     		ldrb	r1, [r5, #6]
 580 0196 8906     		lsl	r1, r1, #26
 581 0198 00D4     		bmi	.LCB630
 582 019a 4CE7     		b	.L37	@long jump
 583              	.LCB630:
 584 019c FA23     		mov	r3, #250
 585              	.LVL59:
 586 019e 1C01     		lsl	r4, r3, #4
 315:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 587              		.loc 1 315 0
 588 01a0 4026     		mov	r6, #64
 589 01a2 03E0     		b	.L52
 590              	.L123:
 591 01a4 013C     		sub	r4, r4, #1
 592 01a6 A4B2     		uxth	r4, r4
 313:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 4000 ; i++)
 593              		.loc 1 313 0
 594 01a8 002C     		cmp	r4, #0
 595 01aa 02D0     		beq	.L51
 596              	.L52:
 315:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 597              		.loc 1 315 0
 598 01ac A879     		ldrb	r0, [r5, #6]
 599 01ae 3042     		tst	r0, r6
 600 01b0 F8D0     		beq	.L123
 601              	.L51:
 317:../Sources/TFC/TFC_CrystalClock.c ****   if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if
 602              		.loc 1 317 0
 603 01b2 284B     		ldr	r3, .L124
 604 01b4 4420     		mov	r0, #68
 605 01b6 9A79     		ldrb	r2, [r3, #6]
 606 01b8 5106     		lsl	r1, r2, #25
 607 01ba 00D4     		bmi	.LCB665
 608 01bc 3BE7     		b	.L37	@long jump
 609              	.LCB665:
 320:../Sources/TFC/TFC_CrystalClock.c ****   prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 610              		.loc 1 320 0
 611 01be 1979     		ldrb	r1, [r3, #4]
 321:../Sources/TFC/TFC_CrystalClock.c ****   vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 612              		.loc 1 321 0
 613 01c0 5E79     		ldrb	r6, [r3, #5]
 320:../Sources/TFC/TFC_CrystalClock.c ****   prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 614              		.loc 1 320 0
 615 01c2 1F25     		mov	r5, #31
 325:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to switch CLKS mux to select PLL as MCG_OUT
 616              		.loc 1 325 0
 617 01c4 1878     		ldrb	r0, [r3]
 320:../Sources/TFC/TFC_CrystalClock.c ****   prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 618              		.loc 1 320 0
 619 01c6 2940     		and	r1, r5
 325:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to switch CLKS mux to select PLL as MCG_OUT
 620              		.loc 1 325 0
 621 01c8 3F22     		mov	r2, #63
 321:../Sources/TFC/TFC_CrystalClock.c ****   vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 622              		.loc 1 321 0
 623 01ca 3540     		and	r5, r6
 624 01cc 2C1C     		mov	r4, r5
 325:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to switch CLKS mux to select PLL as MCG_OUT
 625              		.loc 1 325 0
 626 01ce 0240     		and	r2, r0
 627 01d0 FA25     		mov	r5, #250
 628 01d2 1A70     		strb	r2, [r3]
 320:../Sources/TFC/TFC_CrystalClock.c ****   prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 629              		.loc 1 320 0
 630 01d4 0131     		add	r1, r1, #1
 631              	.LVL60:
 321:../Sources/TFC/TFC_CrystalClock.c ****   vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 632              		.loc 1 321 0
 633 01d6 1834     		add	r4, r4, #24
 634              	.LVL61:
 325:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to switch CLKS mux to select PLL as MCG_OUT
 635              		.loc 1 325 0
 636 01d8 EA00     		lsl	r2, r5, #3
 330:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break; // jump out early if CLKST
 637              		.loc 1 330 0
 638 01da 0C26     		mov	r6, #12
 639              	.LVL62:
 640              	.L54:
 641 01dc 9879     		ldrb	r0, [r3, #6]
 642 01de 3040     		and	r0, r6
 643 01e0 0C28     		cmp	r0, #12
 644 01e2 03D0     		beq	.L53
 645 01e4 013A     		sub	r2, r2, #1
 646 01e6 92B2     		uxth	r2, r2
 328:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 647              		.loc 1 328 0
 648 01e8 002A     		cmp	r2, #0
 649 01ea F7D1     		bne	.L54
 650              	.L53:
 332:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) return 0x1B; // check CLKST is set 
 651              		.loc 1 332 0
 652 01ec 194B     		ldr	r3, .L124
 653 01ee 1B20     		mov	r0, #27
 654 01f0 9D79     		ldrb	r5, [r3, #6]
 655 01f2 2E07     		lsl	r6, r5, #28
 656 01f4 B20F     		lsr	r2, r6, #30
 657 01f6 032A     		cmp	r2, #3
 658 01f8 00D0     		beq	.LCB723
 659 01fa 1CE7     		b	.L37	@long jump
 660              	.LCB723:
 336:../Sources/TFC/TFC_CrystalClock.c ****   return ((crystal_val / prdiv) * vdiv); //MCGOUT equals PLL output frequency
 661              		.loc 1 336 0
 662 01fc 381C     		mov	r0, r7
 663 01fe FFF7FEFF 		bl	__aeabi_idiv
 664              	.LVL63:
 665 0202 6043     		mul	r0, r4
 666 0204 17E7     		b	.L37
 667              	.LVL64:
 668              	.L117:
 205:../Sources/TFC/TFC_CrystalClock.c ****     if ((crystal_val < 3000000) || (crystal_val > 32000000)) {return 0x22;} // return 1 if one of t
 669              		.loc 1 205 0
 670 0206 1D48     		ldr	r0, .L124+40
 671 0208 1D4E     		ldr	r6, .L124+44
 672 020a 3918     		add	r1, r7, r0
 673 020c 2220     		mov	r0, #34
 674 020e B142     		cmp	r1, r6
 675 0210 00D9     		bls	.LCB749
 676 0212 10E7     		b	.L37	@long jump
 677              	.LCB749:
 678 0214 16E7     		b	.L38
 679              	.LVL65:
 680              	.L39:
 239:../Sources/TFC/TFC_CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 681              		.loc 1 239 0
 682 0216 2020     		mov	r0, #32
 683 0218 0143     		orr	r1, r0
 684              	.LVL66:
 685 021a A800     		lsl	r0, r5, #2
 686 021c 0143     		orr	r1, r0
 687 021e C9B2     		uxtb	r1, r1
 688 0220 D200     		lsl	r2, r2, #3
 689 0222 0A43     		orr	r2, r1
 690              	.LVL67:
 241:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C2 = temp_reg;
 691              		.loc 1 241 0
 692 0224 5A70     		strb	r2, [r3, #1]
 693              	.LVL68:
 694              	.L42:
 247:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
 695              		.loc 1 247 0
 696 0226 174A     		ldr	r2, .L124+48
 697 0228 0223     		mov	r3, #2
 698 022a 9742     		cmp	r7, r2
 699 022c 00DC     		bgt	.LCB779
 700 022e 3FE7     		b	.L40	@long jump
 701              	.LCB779:
 248:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
 702              		.loc 1 248 0
 703 0230 1548     		ldr	r0, .L124+52
 704 0232 0323     		mov	r3, #3
 705 0234 8742     		cmp	r7, r0
 706 0236 00DC     		bgt	.LCB783
 707 0238 3AE7     		b	.L40	@long jump
 708              	.LCB783:
 249:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
 709              		.loc 1 249 0
 710 023a 1449     		ldr	r1, .L124+56
 250:../Sources/TFC/TFC_CrystalClock.c ****   else {frdiv_val = 5;}
 711              		.loc 1 250 0
 712 023c 0523     		mov	r3, #5
 249:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
 713              		.loc 1 249 0
 714 023e 8F42     		cmp	r7, r1
 715 0240 00DD     		ble	.LCB787
 716 0242 35E7     		b	.L40	@long jump
 717              	.LCB787:
 718 0244 0423     		mov	r3, #4
 719 0246 33E7     		b	.L40
 720              	.LVL69:
 721              	.L118:
 246:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
 722              		.loc 1 246 0
 723 0248 1149     		ldr	r1, .L124+60
 724 024a 0123     		mov	r3, #1
 725 024c 8F42     		cmp	r7, r1
 726 024e 00DC     		bgt	.LCB797
 727 0250 2EE7     		b	.L40	@long jump
 728              	.LCB797:
 729 0252 E8E7     		b	.L42
 730              	.L125:
 731              		.align	2
 732              	.L124:
 733 0254 00400640 		.word	1074151424
 734 0258 80F0FA02 		.word	50000000
 735 025c 807BE1FF 		.word	-2000000
 736 0260 80841E00 		.word	2000000
 737 0264 009423FD 		.word	-48000000
 738 0268 00751903 		.word	52000000
 739 026c 00127A00 		.word	8000000
 740 0270 D0121300 		.word	1250000
 741 0274 204E0000 		.word	20000
 742 0278 CF070000 		.word	1999
 743 027c 4039D2FF 		.word	-3000000
 744 0280 4081BA01 		.word	29000000
 745 0284 404B4C00 		.word	5000000
 746 0288 80969800 		.word	10000000
 747 028c 002D3101 		.word	20000000
 748 0290 A0252600 		.word	2500000
 749              		.cfi_endproc
 750              	.LFE1:
 752              		.section	.text.TFC_InitClock,"ax",%progbits
 753              		.align	2
 754              		.global	TFC_InitClock
 755              		.code	16
 756              		.thumb_func
 758              	TFC_InitClock:
 759              	.LFB0:
 106:../Sources/TFC/TFC_CrystalClock.c **** {
 760              		.loc 1 106 0
 761              		.cfi_startproc
 762 0000 00B5     		push	{lr}
 763              	.LCFI3:
 764              		.cfi_def_cfa_offset 4
 765              		.cfi_offset 14, -4
 107:../Sources/TFC/TFC_CrystalClock.c **** 	pll_init(8000000, LOW_POWER, CRYSTAL, 4, 24, MCGOUT);
 766              		.loc 1 107 0
 767 0002 1823     		mov	r3, #24
 106:../Sources/TFC/TFC_CrystalClock.c **** {
 768              		.loc 1 106 0
 769 0004 83B0     		sub	sp, sp, #12
 770              	.LCFI4:
 771              		.cfi_def_cfa_offset 16
 107:../Sources/TFC/TFC_CrystalClock.c **** 	pll_init(8000000, LOW_POWER, CRYSTAL, 4, 24, MCGOUT);
 772              		.loc 1 107 0
 773 0006 0120     		mov	r0, #1
 774 0008 0093     		str	r3, [sp]
 775 000a 0190     		str	r0, [sp, #4]
 776 000c 0021     		mov	r1, #0
 777 000e 0122     		mov	r2, #1
 778 0010 0423     		mov	r3, #4
 779 0012 0248     		ldr	r0, .L127
 780 0014 FFF7FEFF 		bl	pll_init
 781              	.LVL70:
 132:../Sources/TFC/TFC_CrystalClock.c **** }
 782              		.loc 1 132 0
 783 0018 03B0     		add	sp, sp, #12
 784              		@ sp needed for prologue
 785 001a 00BD     		pop	{pc}
 786              	.L128:
 787              		.align	2
 788              	.L127:
 789 001c 00127A00 		.word	8000000
 790              		.cfi_endproc
 791              	.LFE0:
 793              		.section	.text.pee_pbe,"ax",%progbits
 794              		.align	2
 795              		.global	pee_pbe
 796              		.code	16
 797              		.thumb_func
 799              	pee_pbe:
 800              	.LFB2:
 345:../Sources/TFC/TFC_CrystalClock.c **** {
 801              		.loc 1 345 0
 802              		.cfi_startproc
 803              	.LVL71:
 804 0000 10B5     		push	{r4, lr}
 805              	.LCFI5:
 806              		.cfi_def_cfa_offset 8
 807              		.cfi_offset 4, -8
 808              		.cfi_offset 14, -4
 349:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selcted
 809              		.loc 1 349 0
 810 0002 164B     		ldr	r3, .L148
 811 0004 9A79     		ldrb	r2, [r3, #6]
 812 0006 1107     		lsl	r1, r2, #28
 813 0008 8C0F     		lsr	r4, r1, #30
 814 000a 032C     		cmp	r4, #3
 815 000c 01D0     		beq	.L146
 816              	.L135:
 353:../Sources/TFC/TFC_CrystalClock.c ****     return 0x8;                                                       // return error code
 817              		.loc 1 353 0
 818 000e 0820     		mov	r0, #8
 819              	.LVL72:
 820              	.L130:
 370:../Sources/TFC/TFC_CrystalClock.c **** } // pee_pbe
 821              		.loc 1 370 0
 822              		@ sp needed for prologue
 823 0010 10BD     		pop	{r4, pc}
 824              	.LVL73:
 825              	.L146:
 350:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 826              		.loc 1 350 0
 827 0012 9A79     		ldrb	r2, [r3, #6]
 349:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selcted
 828              		.loc 1 349 0
 829 0014 D106     		lsl	r1, r2, #27
 830 0016 FAD4     		bmi	.L135
 351:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_PLLST_MASK)))                                    // check PLLS mux has selecte
 831              		.loc 1 351 0
 832 0018 9979     		ldrb	r1, [r3, #6]
 349:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selcted
 833              		.loc 1 349 0
 834 001a 8906     		lsl	r1, r1, #26
 835 001c F7D5     		bpl	.L135
 359:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 |= MCG_C1_CLKS(2); // switch CLKS mux to select external reference clock as MCG_OUT
 836              		.loc 1 359 0
 837 001e 1C78     		ldrb	r4, [r3]
 838 0020 8022     		mov	r2, #128
 839 0022 2243     		orr	r2, r4
 840 0024 FA21     		mov	r1, #250
 841 0026 1A70     		strb	r2, [r3]
 842              	.LVL74:
 843 0028 CA00     		lsl	r2, r1, #3
 364:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 844              		.loc 1 364 0
 845 002a 0C21     		mov	r1, #12
 846 002c 09E0     		b	.L132
 847              	.LVL75:
 848              	.L147:
 849 002e 9C79     		ldrb	r4, [r3, #6]
 850 0030 013A     		sub	r2, r2, #1
 851 0032 92B2     		uxth	r2, r2
 852 0034 0C40     		and	r4, r1
 853 0036 082C     		cmp	r4, #8
 854 0038 07D0     		beq	.L131
 855 003a 013A     		sub	r2, r2, #1
 856 003c 92B2     		uxth	r2, r2
 362:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 857              		.loc 1 362 0
 858 003e 002A     		cmp	r2, #0
 859 0040 03D0     		beq	.L131
 860              	.L132:
 364:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 861              		.loc 1 364 0
 862 0042 9C79     		ldrb	r4, [r3, #6]
 863 0044 0C40     		and	r4, r1
 864 0046 082C     		cmp	r4, #8
 865 0048 F1D1     		bne	.L147
 866              	.L131:
 366:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
 867              		.loc 1 366 0
 868 004a 044B     		ldr	r3, .L148
 869 004c 9979     		ldrb	r1, [r3, #6]
 870 004e 0C07     		lsl	r4, r1, #28
 871 0050 A20F     		lsr	r2, r4, #30
 872 0052 022A     		cmp	r2, #2
 873 0054 DCD0     		beq	.L130
 874 0056 1A20     		mov	r0, #26
 875              	.LVL76:
 876 0058 DAE7     		b	.L130
 877              	.L149:
 878 005a C046     		.align	2
 879              	.L148:
 880 005c 00400640 		.word	1074151424
 881              		.cfi_endproc
 882              	.LFE2:
 884              		.section	.text.pbe_pee,"ax",%progbits
 885              		.align	2
 886              		.global	pbe_pee
 887              		.code	16
 888              		.thumb_func
 890              	pbe_pee:
 891              	.LFB3:
 374:../Sources/TFC/TFC_CrystalClock.c **** {
 892              		.loc 1 374 0
 893              		.cfi_startproc
 894              	.LVL77:
 895 0000 70B5     		push	{r4, r5, r6, lr}
 896              	.LCFI6:
 897              		.cfi_def_cfa_offset 16
 898              		.cfi_offset 4, -16
 899              		.cfi_offset 5, -12
 900              		.cfi_offset 6, -8
 901              		.cfi_offset 14, -4
 379:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 902              		.loc 1 379 0
 903 0002 294B     		ldr	r3, .L177
 904 0004 9A79     		ldrb	r2, [r3, #6]
 905 0006 1107     		lsl	r1, r2, #28
 906 0008 8E0F     		lsr	r6, r1, #30
 384:../Sources/TFC/TFC_CrystalClock.c ****     return 0x7;                                                       // return error code
 907              		.loc 1 384 0
 908 000a 0721     		mov	r1, #7
 379:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 909              		.loc 1 379 0
 910 000c 022E     		cmp	r6, #2
 911 000e 01D0     		beq	.L174
 912              	.LVL78:
 913              	.L151:
 414:../Sources/TFC/TFC_CrystalClock.c **** }  // pbe_pee
 914              		.loc 1 414 0
 915 0010 081C     		mov	r0, r1
 916              		@ sp needed for prologue
 917 0012 70BD     		pop	{r4, r5, r6, pc}
 918              	.LVL79:
 919              	.L174:
 380:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 920              		.loc 1 380 0
 921 0014 9C79     		ldrb	r4, [r3, #6]
 379:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 922              		.loc 1 379 0
 923 0016 E506     		lsl	r5, r4, #27
 924 0018 FAD4     		bmi	.L151
 381:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_PLLST_MASK) &&                                   // check PLLS mux has selecte
 925              		.loc 1 381 0
 926 001a 9D79     		ldrb	r5, [r3, #6]
 380:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 927              		.loc 1 380 0
 928 001c AD06     		lsl	r5, r5, #26
 929 001e F7D5     		bpl	.L151
 382:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 930              		.loc 1 382 0
 931 0020 5A78     		ldrb	r2, [r3, #1]
 379:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 932              		.loc 1 379 0
 933 0022 1642     		tst	r6, r2
 934 0024 F4D1     		bne	.L151
 935 0026 FA21     		mov	r1, #250
 936 0028 C900     		lsl	r1, r1, #3
 395:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 937              		.loc 1 395 0
 938 002a 4026     		mov	r6, #64
 939 002c 08E0     		b	.L153
 940              	.L175:
 941              	.LVL80:
 942 002e 9A79     		ldrb	r2, [r3, #6]
 943 0030 0139     		sub	r1, r1, #1
 944 0032 8DB2     		uxth	r5, r1
 945 0034 1642     		tst	r6, r2
 946 0036 06D1     		bne	.L152
 947 0038 013D     		sub	r5, r5, #1
 948 003a A9B2     		uxth	r1, r5
 393:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 949              		.loc 1 393 0
 950 003c 0029     		cmp	r1, #0
 951 003e 02D0     		beq	.L152
 952              	.L153:
 395:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 953              		.loc 1 395 0
 954 0040 9C79     		ldrb	r4, [r3, #6]
 955 0042 2642     		tst	r6, r4
 956 0044 F3D0     		beq	.L175
 957              	.L152:
 397:../Sources/TFC/TFC_CrystalClock.c ****   if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if
 958              		.loc 1 397 0
 959 0046 184A     		ldr	r2, .L177
 960 0048 4421     		mov	r1, #68
 961 004a 9379     		ldrb	r3, [r2, #6]
 962 004c 5C06     		lsl	r4, r3, #25
 963 004e DFD5     		bpl	.L151
 399:../Sources/TFC/TFC_CrystalClock.c ****   prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 964              		.loc 1 399 0
 965 0050 1679     		ldrb	r6, [r2, #4]
 966              	.LVL81:
 400:../Sources/TFC/TFC_CrystalClock.c ****   vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 967              		.loc 1 400 0
 968 0052 5579     		ldrb	r5, [r2, #5]
 969              	.LVL82:
 402:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to switch CLKS mux to select PLL as MCG_OUT
 970              		.loc 1 402 0
 971 0054 1478     		ldrb	r4, [r2]
 972 0056 3F21     		mov	r1, #63
 973 0058 0C40     		and	r4, r1
 974 005a FA23     		mov	r3, #250
 975 005c 1470     		strb	r4, [r2]
 976              	.LVL83:
 407:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break; // jump out early if CLKST
 977              		.loc 1 407 0
 978 005e 111C     		mov	r1, r2
 402:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to switch CLKS mux to select PLL as MCG_OUT
 979              		.loc 1 402 0
 980 0060 DB00     		lsl	r3, r3, #3
 407:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break; // jump out early if CLKST
 981              		.loc 1 407 0
 982 0062 0C22     		mov	r2, #12
 983 0064 09E0     		b	.L155
 984              	.LVL84:
 985              	.L176:
 986 0066 8C79     		ldrb	r4, [r1, #6]
 987 0068 013B     		sub	r3, r3, #1
 988 006a 9BB2     		uxth	r3, r3
 989 006c 1440     		and	r4, r2
 990 006e 0C2C     		cmp	r4, #12
 991 0070 07D0     		beq	.L154
 992 0072 013B     		sub	r3, r3, #1
 993 0074 9BB2     		uxth	r3, r3
 405:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 994              		.loc 1 405 0
 995 0076 002B     		cmp	r3, #0
 996 0078 03D0     		beq	.L154
 997              	.L155:
 407:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break; // jump out early if CLKST
 998              		.loc 1 407 0
 999 007a 8C79     		ldrb	r4, [r1, #6]
 1000 007c 1440     		and	r4, r2
 1001 007e 0C2C     		cmp	r4, #12
 1002 0080 F1D1     		bne	.L176
 1003              	.L154:
 409:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) return 0x1B; // check CLKST is set 
 1004              		.loc 1 409 0
 1005 0082 0949     		ldr	r1, .L177
 1006 0084 8A79     		ldrb	r2, [r1, #6]
 1007 0086 1B21     		mov	r1, #27
 1008 0088 1407     		lsl	r4, r2, #28
 1009 008a A30F     		lsr	r3, r4, #30
 1010 008c 032B     		cmp	r3, #3
 1011 008e BFD1     		bne	.L151
 399:../Sources/TFC/TFC_CrystalClock.c ****   prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 1012              		.loc 1 399 0
 1013 0090 1F24     		mov	r4, #31
 1014 0092 311C     		mov	r1, r6
 1015 0094 2140     		and	r1, r4
 412:../Sources/TFC/TFC_CrystalClock.c ****   return ((crystal_val / prdiv) * vdiv); //MCGOUT equals PLL output frequency
 1016              		.loc 1 412 0
 1017 0096 0131     		add	r1, r1, #1
 1018 0098 FFF7FEFF 		bl	__aeabi_idiv
 1019              	.LVL85:
 400:../Sources/TFC/TFC_CrystalClock.c ****   vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 1020              		.loc 1 400 0
 1021 009c 291C     		mov	r1, r5
 1022 009e 2140     		and	r1, r4
 412:../Sources/TFC/TFC_CrystalClock.c ****   return ((crystal_val / prdiv) * vdiv); //MCGOUT equals PLL output frequency
 1023              		.loc 1 412 0
 1024 00a0 1831     		add	r1, r1, #24
 1025 00a2 4143     		mul	r1, r0
 1026 00a4 B4E7     		b	.L151
 1027              	.L178:
 1028 00a6 C046     		.align	2
 1029              	.L177:
 1030 00a8 00400640 		.word	1074151424
 1031              		.cfi_endproc
 1032              	.LFE3:
 1034              		.section	.text.pbe_fbe,"ax",%progbits
 1035              		.align	2
 1036              		.global	pbe_fbe
 1037              		.code	16
 1038              		.thumb_func
 1040              	pbe_fbe:
 1041              	.LFB4:
 418:../Sources/TFC/TFC_CrystalClock.c **** {
 1042              		.loc 1 418 0
 1043              		.cfi_startproc
 1044              	.LVL86:
 1045 0000 10B5     		push	{r4, lr}
 1046              	.LCFI7:
 1047              		.cfi_def_cfa_offset 8
 1048              		.cfi_offset 4, -8
 1049              		.cfi_offset 14, -4
 422:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1050              		.loc 1 422 0
 1051 0002 154B     		ldr	r3, .L199
 1052 0004 9A79     		ldrb	r2, [r3, #6]
 1053 0006 1107     		lsl	r1, r2, #28
 1054 0008 8A0F     		lsr	r2, r1, #30
 1055 000a 022A     		cmp	r2, #2
 1056 000c 01D0     		beq	.L197
 1057              	.L186:
 427:../Sources/TFC/TFC_CrystalClock.c ****     return 0x7;                                                       // return error code
 1058              		.loc 1 427 0
 1059 000e 0720     		mov	r0, #7
 1060              	.LVL87:
 1061              	.L180:
 444:../Sources/TFC/TFC_CrystalClock.c **** } // pbe_fbe
 1062              		.loc 1 444 0
 1063              		@ sp needed for prologue
 1064 0010 10BD     		pop	{r4, pc}
 1065              	.LVL88:
 1066              	.L197:
 423:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1067              		.loc 1 423 0
 1068 0012 9C79     		ldrb	r4, [r3, #6]
 422:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1069              		.loc 1 422 0
 1070 0014 E406     		lsl	r4, r4, #27
 1071 0016 FAD4     		bmi	.L186
 424:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_PLLST_MASK) &&                                   // check PLLS mux has selecte
 1072              		.loc 1 424 0
 1073 0018 9979     		ldrb	r1, [r3, #6]
 423:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1074              		.loc 1 423 0
 1075 001a 8C06     		lsl	r4, r1, #26
 1076 001c F7D5     		bpl	.L186
 425:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 1077              		.loc 1 425 0
 1078 001e 5C78     		ldrb	r4, [r3, #1]
 422:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1079              		.loc 1 422 0
 1080 0020 2242     		tst	r2, r4
 1081 0022 F4D1     		bne	.L186
 433:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 &= ~MCG_C6_PLLS_MASK; // clear PLLS to disable PLL, still clocked from ext ref clk
 1082              		.loc 1 433 0
 1083 0024 5A79     		ldrb	r2, [r3, #5]
 1084 0026 4021     		mov	r1, #64
 1085 0028 8A43     		bic	r2, r1
 1086 002a FA24     		mov	r4, #250
 1087 002c 5A71     		strb	r2, [r3, #5]
 1088              	.LVL89:
 438:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_PLLST_MASK)) break; // jump out early if PLLST clears before loop finishes
 1089              		.loc 1 438 0
 1090 002e 2021     		mov	r1, #32
 433:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 &= ~MCG_C6_PLLS_MASK; // clear PLLS to disable PLL, still clocked from ext ref clk
 1091              		.loc 1 433 0
 1092 0030 E200     		lsl	r2, r4, #3
 1093 0032 08E0     		b	.L182
 1094              	.LVL90:
 1095              	.L198:
 438:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_PLLST_MASK)) break; // jump out early if PLLST clears before loop finishes
 1096              		.loc 1 438 0
 1097 0034 9C79     		ldrb	r4, [r3, #6]
 1098 0036 013A     		sub	r2, r2, #1
 1099 0038 92B2     		uxth	r2, r2
 1100 003a 2142     		tst	r1, r4
 1101 003c 06D0     		beq	.L181
 1102 003e 013A     		sub	r2, r2, #1
 1103 0040 92B2     		uxth	r2, r2
 436:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 1104              		.loc 1 436 0
 1105 0042 002A     		cmp	r2, #0
 1106 0044 02D0     		beq	.L181
 1107              	.L182:
 438:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_PLLST_MASK)) break; // jump out early if PLLST clears before loop finishes
 1108              		.loc 1 438 0
 1109 0046 9C79     		ldrb	r4, [r3, #6]
 1110 0048 2142     		tst	r1, r4
 1111 004a F3D1     		bne	.L198
 1112              	.L181:
 440:../Sources/TFC/TFC_CrystalClock.c ****   if (MCG_S & MCG_S_PLLST_MASK) return 0x15; // check bit is really clear and return with error if 
 1113              		.loc 1 440 0
 1114 004c 024B     		ldr	r3, .L199
 1115 004e 9979     		ldrb	r1, [r3, #6]
 1116 0050 8A06     		lsl	r2, r1, #26
 1117 0052 DDD5     		bpl	.L180
 1118 0054 1520     		mov	r0, #21
 1119              	.LVL91:
 1120 0056 DBE7     		b	.L180
 1121              	.L200:
 1122              		.align	2
 1123              	.L199:
 1124 0058 00400640 		.word	1074151424
 1125              		.cfi_endproc
 1126              	.LFE4:
 1128              		.section	.text.fbe_pbe,"ax",%progbits
 1129              		.align	2
 1130              		.global	fbe_pbe
 1131              		.code	16
 1132              		.thumb_func
 1134              	fbe_pbe:
 1135              	.LFB5:
 465:../Sources/TFC/TFC_CrystalClock.c **** {
 1136              		.loc 1 465 0
 1137              		.cfi_startproc
 1138              	.LVL92:
 1139 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1140              	.LCFI8:
 1141              		.cfi_def_cfa_offset 20
 1142              		.cfi_offset 4, -20
 1143              		.cfi_offset 5, -16
 1144              		.cfi_offset 6, -12
 1145              		.cfi_offset 7, -8
 1146              		.cfi_offset 14, -4
 1147 0002 4746     		mov	r7, r8
 1148 0004 80B4     		push	{r7}
 1149              	.LCFI9:
 1150              		.cfi_def_cfa_offset 24
 1151              		.cfi_offset 8, -24
 471:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1152              		.loc 1 471 0
 1153 0006 354D     		ldr	r5, .L228
 465:../Sources/TFC/TFC_CrystalClock.c **** {
 1154              		.loc 1 465 0
 1155 0008 041C     		mov	r4, r0
 471:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1156              		.loc 1 471 0
 1157 000a AB79     		ldrb	r3, [r5, #6]
 465:../Sources/TFC/TFC_CrystalClock.c **** {
 1158              		.loc 1 465 0
 1159 000c 161C     		mov	r6, r2
 471:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1160              		.loc 1 471 0
 1161 000e 1807     		lsl	r0, r3, #28
 1162              	.LVL93:
 1163 0010 870F     		lsr	r7, r0, #30
 1164 0012 022F     		cmp	r7, #2
 1165 0014 04D0     		beq	.L220
 1166              	.LVL94:
 1167              	.L210:
 476:../Sources/TFC/TFC_CrystalClock.c ****     return 0x4;                                                       // return error code
 1168              		.loc 1 476 0
 1169 0016 0424     		mov	r4, #4
 1170              	.LVL95:
 1171              	.L202:
 525:../Sources/TFC/TFC_CrystalClock.c **** } // fbe_pbe
 1172              		.loc 1 525 0
 1173 0018 201C     		mov	r0, r4
 1174              		@ sp needed for prologue
 1175 001a 04BC     		pop	{r2}
 1176 001c 9046     		mov	r8, r2
 1177 001e F0BD     		pop	{r4, r5, r6, r7, pc}
 1178              	.LVL96:
 1179              	.L220:
 472:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1180              		.loc 1 472 0
 1181 0020 AA79     		ldrb	r2, [r5, #6]
 1182              	.LVL97:
 471:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1183              		.loc 1 471 0
 1184 0022 D006     		lsl	r0, r2, #27
 1185 0024 F7D4     		bmi	.L210
 473:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 1186              		.loc 1 473 0
 1187 0026 AB79     		ldrb	r3, [r5, #6]
 472:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1188              		.loc 1 472 0
 1189 0028 9806     		lsl	r0, r3, #26
 1190 002a F4D4     		bmi	.L210
 474:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 1191              		.loc 1 474 0
 1192 002c 6878     		ldrb	r0, [r5, #1]
 471:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1193              		.loc 1 471 0
 1194 002e 0742     		tst	r7, r0
 1195 0030 F1D1     		bne	.L210
 482:../Sources/TFC/TFC_CrystalClock.c ****   if ((prdiv_val < 1) || (prdiv_val > 25)) {return 0x41;}
 1196              		.loc 1 482 0
 1197 0032 4F1E     		sub	r7, r1, #1
 1198 0034 FFB2     		uxtb	r7, r7
 1199 0036 182F     		cmp	r7, #24
 1200 0038 01D9     		bls	.L221
 1201 003a 4124     		mov	r4, #65
 1202              	.LVL98:
 1203 003c ECE7     		b	.L202
 1204              	.LVL99:
 1205              	.L221:
 483:../Sources/TFC/TFC_CrystalClock.c ****   if ((vdiv_val < 24) || (vdiv_val > 50)) {return 0x42;} 
 1206              		.loc 1 483 0
 1207 003e 321C     		mov	r2, r6
 1208 0040 183A     		sub	r2, r2, #24
 1209 0042 D3B2     		uxtb	r3, r2
 1210 0044 9846     		mov	r8, r3
 1211 0046 1A2B     		cmp	r3, #26
 1212 0048 01D9     		bls	.L222
 1213 004a 4224     		mov	r4, #66
 1214              	.LVL100:
 1215 004c E4E7     		b	.L202
 1216              	.LVL101:
 1217              	.L222:
 486:../Sources/TFC/TFC_CrystalClock.c ****   if (((crystal_val / prdiv_val) < 2000000) || ((crystal_val / prdiv_val) > 4000000)) {return 0x43;
 1218              		.loc 1 486 0
 1219 004e 201C     		mov	r0, r4
 1220 0050 FFF7FEFF 		bl	__aeabi_idiv
 1221              	.LVL102:
 1222 0054 2249     		ldr	r1, .L228+4
 1223 0056 234B     		ldr	r3, .L228+8
 1224 0058 4218     		add	r2, r0, r1
 1225 005a 9A42     		cmp	r2, r3
 1226 005c 01D9     		bls	.L223
 1227 005e 4324     		mov	r4, #67
 1228              	.LVL103:
 1229 0060 DAE7     		b	.L202
 1230              	.LVL104:
 1231              	.L223:
 489:../Sources/TFC/TFC_CrystalClock.c ****   pll_freq = (crystal_val / prdiv_val) * vdiv_val;
 1232              		.loc 1 489 0
 1233 0062 7043     		mul	r0, r6
 1234              	.LVL105:
 490:../Sources/TFC/TFC_CrystalClock.c ****   if ((pll_freq < 48000000) || (pll_freq > 100000000)) {return 0x45;}
 1235              		.loc 1 490 0
 1236 0064 204E     		ldr	r6, .L228+12
 1237              	.LVL106:
 1238 0066 2149     		ldr	r1, .L228+16
 1239 0068 8019     		add	r0, r0, r6
 1240 006a 8842     		cmp	r0, r1
 1241 006c 01D9     		bls	.L224
 1242 006e 4524     		mov	r4, #69
 1243              	.LVL107:
 1244 0070 D2E7     		b	.L202
 1245              	.LVL108:
 1246              	.L224:
 494:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C5;
 1247              		.loc 1 494 0
 1248 0072 2A79     		ldrb	r2, [r5, #4]
 1249              	.LVL109:
 495:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~MCG_C5_PRDIV0_MASK;
 1250              		.loc 1 495 0
 1251 0074 1F23     		mov	r3, #31
 1252 0076 9A43     		bic	r2, r3
 1253              	.LVL110:
 496:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);    //set PLL ref divider
 1254              		.loc 1 496 0
 1255 0078 1743     		orr	r7, r2
 1256              	.LVL111:
 497:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C5 = temp_reg;
 1257              		.loc 1 497 0
 1258 007a 2F71     		strb	r7, [r5, #4]
 504:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C6; // store present C6 value
 1259              		.loc 1 504 0
 1260 007c 6F79     		ldrb	r7, [r5, #5]
 1261              	.LVL112:
 506:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 1262              		.loc 1 506 0
 1263 007e 4020     		mov	r0, #64
 505:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 1264              		.loc 1 505 0
 1265 0080 9F43     		bic	r7, r3
 1266              	.LVL113:
 1267 0082 3E1C     		mov	r6, r7
 506:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 1268              		.loc 1 506 0
 1269 0084 4146     		mov	r1, r8
 1270 0086 0643     		orr	r6, r0
 1271 0088 0E43     		orr	r6, r1
 1272              	.LVL114:
 507:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 = temp_reg; // update MCG_C6
 1273              		.loc 1 507 0
 1274 008a FA22     		mov	r2, #250
 1275 008c 6E71     		strb	r6, [r5, #5]
 1276              	.LVL115:
 1277 008e D100     		lsl	r1, r2, #3
 512:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 1278              		.loc 1 512 0
 1279 0090 2027     		mov	r7, #32
 1280 0092 08E0     		b	.L204
 1281              	.LVL116:
 1282              	.L225:
 1283 0094 A879     		ldrb	r0, [r5, #6]
 1284 0096 0139     		sub	r1, r1, #1
 1285 0098 8BB2     		uxth	r3, r1
 1286 009a 0742     		tst	r7, r0
 1287 009c 06D1     		bne	.L203
 1288 009e 013B     		sub	r3, r3, #1
 1289 00a0 99B2     		uxth	r1, r3
 510:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 1290              		.loc 1 510 0
 1291 00a2 0029     		cmp	r1, #0
 1292 00a4 02D0     		beq	.L203
 1293              	.L204:
 512:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 1294              		.loc 1 512 0
 1295 00a6 AE79     		ldrb	r6, [r5, #6]
 1296 00a8 3742     		tst	r7, r6
 1297 00aa F3D0     		beq	.L225
 1298              	.L203:
 514:../Sources/TFC/TFC_CrystalClock.c ****   if (!(MCG_S & MCG_S_PLLST_MASK)) return 0x16; // check bit is really set and return with error if
 1299              		.loc 1 514 0
 1300 00ac 0B4D     		ldr	r5, .L228
 1301 00ae AA79     		ldrb	r2, [r5, #6]
 1302 00b0 9106     		lsl	r1, r2, #26
 1303 00b2 01D4     		bmi	.L226
 1304 00b4 1624     		mov	r4, #22
 1305              	.LVL117:
 1306 00b6 AFE7     		b	.L202
 1307              	.LVL118:
 1308              	.L226:
 1309 00b8 FA27     		mov	r7, #250
 1310 00ba FB00     		lsl	r3, r7, #3
 519:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 1311              		.loc 1 519 0
 1312 00bc 4026     		mov	r6, #64
 1313 00be 03E0     		b	.L206
 1314              	.L227:
 1315 00c0 013B     		sub	r3, r3, #1
 1316 00c2 9BB2     		uxth	r3, r3
 517:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 1317              		.loc 1 517 0
 1318 00c4 002B     		cmp	r3, #0
 1319 00c6 02D0     		beq	.L205
 1320              	.L206:
 519:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 1321              		.loc 1 519 0
 1322 00c8 A879     		ldrb	r0, [r5, #6]
 1323 00ca 3042     		tst	r0, r6
 1324 00cc F8D0     		beq	.L227
 1325              	.L205:
 521:../Sources/TFC/TFC_CrystalClock.c ****   if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if
 1326              		.loc 1 521 0
 1327 00ce 0349     		ldr	r1, .L228
 1328 00d0 8D79     		ldrb	r5, [r1, #6]
 1329 00d2 6A06     		lsl	r2, r5, #25
 1330 00d4 A0D4     		bmi	.L202
 1331 00d6 4424     		mov	r4, #68
 1332              	.LVL119:
 1333 00d8 9EE7     		b	.L202
 1334              	.L229:
 1335 00da C046     		.align	2
 1336              	.L228:
 1337 00dc 00400640 		.word	1074151424
 1338 00e0 807BE1FF 		.word	-2000000
 1339 00e4 80841E00 		.word	2000000
 1340 00e8 009423FD 		.word	-48000000
 1341 00ec 00751903 		.word	52000000
 1342              		.cfi_endproc
 1343              	.LFE5:
 1345              		.section	.text.pbe_blpe,"ax",%progbits
 1346              		.align	2
 1347              		.global	pbe_blpe
 1348              		.code	16
 1349              		.thumb_func
 1351              	pbe_blpe:
 1352              	.LFB6:
 529:../Sources/TFC/TFC_CrystalClock.c **** {
 1353              		.loc 1 529 0
 1354              		.cfi_startproc
 1355              	.LVL120:
 1356 0000 10B5     		push	{r4, lr}
 1357              	.LCFI10:
 1358              		.cfi_def_cfa_offset 8
 1359              		.cfi_offset 4, -8
 1360              		.cfi_offset 14, -4
 531:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1361              		.loc 1 531 0
 1362 0002 0B4B     		ldr	r3, .L237
 1363 0004 9A79     		ldrb	r2, [r3, #6]
 1364 0006 1107     		lsl	r1, r2, #28
 1365 0008 8A0F     		lsr	r2, r1, #30
 1366 000a 022A     		cmp	r2, #2
 1367 000c 01D0     		beq	.L236
 1368              	.L235:
 536:../Sources/TFC/TFC_CrystalClock.c ****     return 0x7;                                                       // return error code
 1369              		.loc 1 536 0
 1370 000e 0720     		mov	r0, #7
 1371              	.LVL121:
 1372              	.L231:
 544:../Sources/TFC/TFC_CrystalClock.c **** } // pbe_blpe
 1373              		.loc 1 544 0
 1374              		@ sp needed for prologue
 1375 0010 10BD     		pop	{r4, pc}
 1376              	.LVL122:
 1377              	.L236:
 532:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1378              		.loc 1 532 0
 1379 0012 9C79     		ldrb	r4, [r3, #6]
 531:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1380              		.loc 1 531 0
 1381 0014 E406     		lsl	r4, r4, #27
 1382 0016 FAD4     		bmi	.L235
 533:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_PLLST_MASK) &&                                   // check PLLS mux has selecte
 1383              		.loc 1 533 0
 1384 0018 9979     		ldrb	r1, [r3, #6]
 532:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1385              		.loc 1 532 0
 1386 001a 8C06     		lsl	r4, r1, #26
 1387 001c F7D5     		bpl	.L235
 534:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 1388              		.loc 1 534 0
 1389 001e 5C78     		ldrb	r4, [r3, #1]
 531:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1390              		.loc 1 531 0
 1391 0020 2242     		tst	r2, r4
 1392 0022 F4D1     		bne	.L235
 540:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C2 |= MCG_C2_LP_MASK;
 1393              		.loc 1 540 0
 1394 0024 5978     		ldrb	r1, [r3, #1]
 1395 0026 0A43     		orr	r2, r1
 1396 0028 D2B2     		uxtb	r2, r2
 1397 002a 5A70     		strb	r2, [r3, #1]
 543:../Sources/TFC/TFC_CrystalClock.c ****   return crystal_val;  
 1398              		.loc 1 543 0
 1399 002c F0E7     		b	.L231
 1400              	.L238:
 1401 002e C046     		.align	2
 1402              	.L237:
 1403 0030 00400640 		.word	1074151424
 1404              		.cfi_endproc
 1405              	.LFE6:
 1407              		.section	.text.blpe_pbe,"ax",%progbits
 1408              		.align	2
 1409              		.global	blpe_pbe
 1410              		.code	16
 1411              		.thumb_func
 1413              	blpe_pbe:
 1414              	.LFB7:
 553:../Sources/TFC/TFC_CrystalClock.c **** {
 1415              		.loc 1 553 0
 1416              		.cfi_startproc
 1417              	.LVL123:
 1418 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1419              	.LCFI11:
 1420              		.cfi_def_cfa_offset 20
 1421              		.cfi_offset 4, -20
 1422              		.cfi_offset 5, -16
 1423              		.cfi_offset 6, -12
 1424              		.cfi_offset 7, -8
 1425              		.cfi_offset 14, -4
 1426 0002 4746     		mov	r7, r8
 1427 0004 80B4     		push	{r7}
 1428              	.LCFI12:
 1429              		.cfi_def_cfa_offset 24
 1430              		.cfi_offset 8, -24
 558:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1431              		.loc 1 558 0
 1432 0006 324D     		ldr	r5, .L265
 553:../Sources/TFC/TFC_CrystalClock.c **** {
 1433              		.loc 1 553 0
 1434 0008 041C     		mov	r4, r0
 558:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1435              		.loc 1 558 0
 1436 000a AE79     		ldrb	r6, [r5, #6]
 1437 000c 3007     		lsl	r0, r6, #28
 1438              	.LVL124:
 1439 000e 860F     		lsr	r6, r0, #30
 1440 0010 022E     		cmp	r6, #2
 1441 0012 04D0     		beq	.L258
 1442              	.L247:
 562:../Sources/TFC/TFC_CrystalClock.c ****     return 0x6;                                                       // return error code
 1443              		.loc 1 562 0
 1444 0014 0624     		mov	r4, #6
 1445              	.LVL125:
 1446              	.L240:
 612:../Sources/TFC/TFC_CrystalClock.c **** } // blpe_pbe
 1447              		.loc 1 612 0
 1448 0016 201C     		mov	r0, r4
 1449              		@ sp needed for prologue
 1450 0018 04BC     		pop	{r2}
 1451 001a 9046     		mov	r8, r2
 1452 001c F0BD     		pop	{r4, r5, r6, r7, pc}
 1453              	.LVL126:
 1454              	.L258:
 559:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1455              		.loc 1 559 0
 1456 001e AB79     		ldrb	r3, [r5, #6]
 558:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1457              		.loc 1 558 0
 1458 0020 D806     		lsl	r0, r3, #27
 1459 0022 F7D4     		bmi	.L247
 560:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_C2 & MCG_C2_LP_MASK)))                                     // check MCG_C2[LP] bit is se
 1460              		.loc 1 560 0
 1461 0024 6F78     		ldrb	r7, [r5, #1]
 558:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1462              		.loc 1 558 0
 1463 0026 3E42     		tst	r6, r7
 1464 0028 F4D0     		beq	.L247
 568:../Sources/TFC/TFC_CrystalClock.c ****   if ((prdiv_val < 1) || (prdiv_val > 25)) {return 0x41;}
 1465              		.loc 1 568 0
 1466 002a 481E     		sub	r0, r1, #1
 1467 002c C7B2     		uxtb	r7, r0
 1468 002e 182F     		cmp	r7, #24
 1469 0030 01D9     		bls	.L259
 1470 0032 4124     		mov	r4, #65
 1471              	.LVL127:
 1472 0034 EFE7     		b	.L240
 1473              	.LVL128:
 1474              	.L259:
 569:../Sources/TFC/TFC_CrystalClock.c ****   if ((vdiv_val < 24) || (vdiv_val > 50)) {return 0x42;} 
 1475              		.loc 1 569 0
 1476 0036 183A     		sub	r2, r2, #24
 1477              	.LVL129:
 1478 0038 D2B2     		uxtb	r2, r2
 1479 003a 9046     		mov	r8, r2
 1480 003c 1A2A     		cmp	r2, #26
 1481 003e 01D9     		bls	.L260
 1482 0040 4224     		mov	r4, #66
 1483              	.LVL130:
 1484 0042 E8E7     		b	.L240
 1485              	.LVL131:
 1486              	.L260:
 572:../Sources/TFC/TFC_CrystalClock.c ****   if (((crystal_val / prdiv_val) < 2000000) || ((crystal_val / prdiv_val) > 4000000)) {return 0x43;
 1487              		.loc 1 572 0
 1488 0044 201C     		mov	r0, r4
 1489 0046 FFF7FEFF 		bl	__aeabi_idiv
 1490              	.LVL132:
 1491 004a 2249     		ldr	r1, .L265+4
 1492 004c 224B     		ldr	r3, .L265+8
 1493 004e 4018     		add	r0, r0, r1
 1494 0050 9842     		cmp	r0, r3
 1495 0052 01D9     		bls	.L261
 1496 0054 4324     		mov	r4, #67
 1497              	.LVL133:
 1498 0056 DEE7     		b	.L240
 1499              	.LVL134:
 1500              	.L261:
 578:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C5;
 1501              		.loc 1 578 0
 1502 0058 2A79     		ldrb	r2, [r5, #4]
 1503              	.LVL135:
 579:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~MCG_C5_PRDIV0_MASK;
 1504              		.loc 1 579 0
 1505 005a 1F21     		mov	r1, #31
 1506 005c 8A43     		bic	r2, r1
 1507              	.LVL136:
 580:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);    //set PLL ref divider
 1508              		.loc 1 580 0
 1509 005e 1743     		orr	r7, r2
 1510              	.LVL137:
 581:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C5 = temp_reg;
 1511              		.loc 1 581 0
 1512 0060 2F71     		strb	r7, [r5, #4]
 588:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C6; // store present C6 value
 1513              		.loc 1 588 0
 1514 0062 6F79     		ldrb	r7, [r5, #5]
 1515              	.LVL138:
 590:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 1516              		.loc 1 590 0
 1517 0064 4023     		mov	r3, #64
 589:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 1518              		.loc 1 589 0
 1519 0066 8F43     		bic	r7, r1
 1520              	.LVL139:
 1521 0068 381C     		mov	r0, r7
 590:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 1522              		.loc 1 590 0
 1523 006a 1843     		orr	r0, r3
 1524 006c 4246     		mov	r2, r8
 1525 006e 1043     		orr	r0, r2
 1526              	.LVL140:
 591:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 = temp_reg; // update MCG_C6
 1527              		.loc 1 591 0
 1528 0070 6871     		strb	r0, [r5, #5]
 594:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C2 &= ~MCG_C2_LP_MASK;
 1529              		.loc 1 594 0
 1530 0072 6978     		ldrb	r1, [r5, #1]
 599:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 1531              		.loc 1 599 0
 1532 0074 2027     		mov	r7, #32
 594:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C2 &= ~MCG_C2_LP_MASK;
 1533              		.loc 1 594 0
 1534 0076 B143     		bic	r1, r6
 1535 0078 FA26     		mov	r6, #250
 1536 007a 6970     		strb	r1, [r5, #1]
 1537              	.LVL141:
 1538 007c F100     		lsl	r1, r6, #3
 1539 007e 08E0     		b	.L242
 1540              	.LVL142:
 1541              	.L262:
 599:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 1542              		.loc 1 599 0
 1543 0080 AA79     		ldrb	r2, [r5, #6]
 1544 0082 0139     		sub	r1, r1, #1
 1545 0084 8BB2     		uxth	r3, r1
 1546 0086 1742     		tst	r7, r2
 1547 0088 06D1     		bne	.L241
 1548 008a 013B     		sub	r3, r3, #1
 1549 008c 99B2     		uxth	r1, r3
 597:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 1550              		.loc 1 597 0
 1551 008e 0029     		cmp	r1, #0
 1552 0090 02D0     		beq	.L241
 1553              	.L242:
 599:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 1554              		.loc 1 599 0
 1555 0092 A879     		ldrb	r0, [r5, #6]
 1556 0094 0742     		tst	r7, r0
 1557 0096 F3D0     		beq	.L262
 1558              	.L241:
 601:../Sources/TFC/TFC_CrystalClock.c ****   if (!(MCG_S & MCG_S_PLLST_MASK)) return 0x16; // check bit is really set and return with error if
 1559              		.loc 1 601 0
 1560 0098 0D4D     		ldr	r5, .L265
 1561 009a AE79     		ldrb	r6, [r5, #6]
 1562 009c B006     		lsl	r0, r6, #26
 1563 009e 01D4     		bmi	.L263
 1564 00a0 1624     		mov	r4, #22
 1565              	.LVL143:
 1566 00a2 B8E7     		b	.L240
 1567              	.LVL144:
 1568              	.L263:
 1569 00a4 FA27     		mov	r7, #250
 1570 00a6 FE00     		lsl	r6, r7, #3
 606:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 1571              		.loc 1 606 0
 1572 00a8 4023     		mov	r3, #64
 1573 00aa 08E0     		b	.L244
 1574              	.L264:
 1575 00ac A979     		ldrb	r1, [r5, #6]
 1576 00ae 013E     		sub	r6, r6, #1
 1577 00b0 B2B2     		uxth	r2, r6
 1578 00b2 0B42     		tst	r3, r1
 1579 00b4 06D1     		bne	.L243
 1580 00b6 013A     		sub	r2, r2, #1
 1581 00b8 96B2     		uxth	r6, r2
 604:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 1582              		.loc 1 604 0
 1583 00ba 002E     		cmp	r6, #0
 1584 00bc 02D0     		beq	.L243
 1585              	.L244:
 606:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 1586              		.loc 1 606 0
 1587 00be A879     		ldrb	r0, [r5, #6]
 1588 00c0 0342     		tst	r3, r0
 1589 00c2 F3D0     		beq	.L264
 1590              	.L243:
 608:../Sources/TFC/TFC_CrystalClock.c ****   if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if
 1591              		.loc 1 608 0
 1592 00c4 024D     		ldr	r5, .L265
 1593 00c6 AF79     		ldrb	r7, [r5, #6]
 1594 00c8 7906     		lsl	r1, r7, #25
 1595 00ca A4D4     		bmi	.L240
 1596 00cc 4424     		mov	r4, #68
 1597              	.LVL145:
 1598 00ce A2E7     		b	.L240
 1599              	.L266:
 1600              		.align	2
 1601              	.L265:
 1602 00d0 00400640 		.word	1074151424
 1603 00d4 807BE1FF 		.word	-2000000
 1604 00d8 80841E00 		.word	2000000
 1605              		.cfi_endproc
 1606              	.LFE7:
 1608              		.section	.text.blpe_fbe,"ax",%progbits
 1609              		.align	2
 1610              		.global	blpe_fbe
 1611              		.code	16
 1612              		.thumb_func
 1614              	blpe_fbe:
 1615              	.LFB8:
 616:../Sources/TFC/TFC_CrystalClock.c **** {
 1616              		.loc 1 616 0
 1617              		.cfi_startproc
 1618              	.LVL146:
 1619 0000 10B5     		push	{r4, lr}
 1620              	.LCFI13:
 1621              		.cfi_def_cfa_offset 8
 1622              		.cfi_offset 4, -8
 1623              		.cfi_offset 14, -4
 620:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1624              		.loc 1 620 0
 1625 0002 154B     		ldr	r3, .L286
 1626 0004 9A79     		ldrb	r2, [r3, #6]
 1627 0006 1107     		lsl	r1, r2, #28
 1628 0008 8A0F     		lsr	r2, r1, #30
 1629 000a 022A     		cmp	r2, #2
 1630 000c 01D0     		beq	.L284
 1631              	.L273:
 624:../Sources/TFC/TFC_CrystalClock.c ****     return 0x6;                                                       // return error code
 1632              		.loc 1 624 0
 1633 000e 0620     		mov	r0, #6
 1634              	.LVL147:
 1635              	.L268:
 640:../Sources/TFC/TFC_CrystalClock.c **** } // blpe_fbe
 1636              		.loc 1 640 0
 1637              		@ sp needed for prologue
 1638 0010 10BD     		pop	{r4, pc}
 1639              	.LVL148:
 1640              	.L284:
 621:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1641              		.loc 1 621 0
 1642 0012 9C79     		ldrb	r4, [r3, #6]
 620:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1643              		.loc 1 620 0
 1644 0014 E406     		lsl	r4, r4, #27
 1645 0016 FAD4     		bmi	.L273
 622:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_C2 & MCG_C2_LP_MASK)))                                     // check MCG_C2[LP] bit is se
 1646              		.loc 1 622 0
 1647 0018 5978     		ldrb	r1, [r3, #1]
 620:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1648              		.loc 1 620 0
 1649 001a 0A42     		tst	r2, r1
 1650 001c F7D0     		beq	.L273
 628:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 &= ~MCG_C6_PLLS_MASK; // clear PLLS to select the FLL
 1651              		.loc 1 628 0
 1652 001e 5979     		ldrb	r1, [r3, #5]
 1653 0020 4024     		mov	r4, #64
 1654 0022 A143     		bic	r1, r4
 1655 0024 5971     		strb	r1, [r3, #5]
 629:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C2 &= ~MCG_C2_LP_MASK; // clear LP bit  
 1656              		.loc 1 629 0
 1657 0026 5978     		ldrb	r1, [r3, #1]
 1658 0028 FA24     		mov	r4, #250
 1659 002a 9143     		bic	r1, r2
 1660 002c 5970     		strb	r1, [r3, #1]
 1661              	.LVL149:
 1662 002e E200     		lsl	r2, r4, #3
 634:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_PLLST_MASK)) break; // jump out early if PLLST clears before loop finishes
 1663              		.loc 1 634 0
 1664 0030 2021     		mov	r1, #32
 1665 0032 08E0     		b	.L270
 1666              	.LVL150:
 1667              	.L285:
 1668 0034 9C79     		ldrb	r4, [r3, #6]
 1669 0036 013A     		sub	r2, r2, #1
 1670 0038 92B2     		uxth	r2, r2
 1671 003a 2142     		tst	r1, r4
 1672 003c 06D0     		beq	.L269
 1673 003e 013A     		sub	r2, r2, #1
 1674 0040 92B2     		uxth	r2, r2
 632:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 1675              		.loc 1 632 0
 1676 0042 002A     		cmp	r2, #0
 1677 0044 02D0     		beq	.L269
 1678              	.L270:
 634:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_PLLST_MASK)) break; // jump out early if PLLST clears before loop finishes
 1679              		.loc 1 634 0
 1680 0046 9C79     		ldrb	r4, [r3, #6]
 1681 0048 2142     		tst	r1, r4
 1682 004a F3D1     		bne	.L285
 1683              	.L269:
 636:../Sources/TFC/TFC_CrystalClock.c ****   if (MCG_S & MCG_S_PLLST_MASK) return 0x15; // check bit is really clear and return with error if 
 1684              		.loc 1 636 0
 1685 004c 024B     		ldr	r3, .L286
 1686 004e 9979     		ldrb	r1, [r3, #6]
 1687 0050 8A06     		lsl	r2, r1, #26
 1688 0052 DDD5     		bpl	.L268
 1689 0054 1520     		mov	r0, #21
 1690              	.LVL151:
 1691 0056 DBE7     		b	.L268
 1692              	.L287:
 1693              		.align	2
 1694              	.L286:
 1695 0058 00400640 		.word	1074151424
 1696              		.cfi_endproc
 1697              	.LFE8:
 1699              		.section	.text.fbe_blpe,"ax",%progbits
 1700              		.align	2
 1701              		.global	fbe_blpe
 1702              		.code	16
 1703              		.thumb_func
 1705              	fbe_blpe:
 1706              	.LFB9:
 644:../Sources/TFC/TFC_CrystalClock.c **** {
 1707              		.loc 1 644 0
 1708              		.cfi_startproc
 1709              	.LVL152:
 1710 0000 10B5     		push	{r4, lr}
 1711              	.LCFI14:
 1712              		.cfi_def_cfa_offset 8
 1713              		.cfi_offset 4, -8
 1714              		.cfi_offset 14, -4
 646:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1715              		.loc 1 646 0
 1716 0002 0B4B     		ldr	r3, .L295
 1717 0004 9A79     		ldrb	r2, [r3, #6]
 1718 0006 1107     		lsl	r1, r2, #28
 1719 0008 8A0F     		lsr	r2, r1, #30
 1720 000a 022A     		cmp	r2, #2
 1721 000c 01D0     		beq	.L294
 1722              	.L293:
 651:../Sources/TFC/TFC_CrystalClock.c ****     return 0x4;                                                       // return error code
 1723              		.loc 1 651 0
 1724 000e 0420     		mov	r0, #4
 1725              	.LVL153:
 1726              	.L289:
 659:../Sources/TFC/TFC_CrystalClock.c **** } // fbe_blpe
 1727              		.loc 1 659 0
 1728              		@ sp needed for prologue
 1729 0010 10BD     		pop	{r4, pc}
 1730              	.LVL154:
 1731              	.L294:
 647:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1732              		.loc 1 647 0
 1733 0012 9C79     		ldrb	r4, [r3, #6]
 646:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1734              		.loc 1 646 0
 1735 0014 E406     		lsl	r4, r4, #27
 1736 0016 FAD4     		bmi	.L293
 648:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 1737              		.loc 1 648 0
 1738 0018 9979     		ldrb	r1, [r3, #6]
 647:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1739              		.loc 1 647 0
 1740 001a 8C06     		lsl	r4, r1, #26
 1741 001c F7D4     		bmi	.L293
 649:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 1742              		.loc 1 649 0
 1743 001e 5C78     		ldrb	r4, [r3, #1]
 646:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1744              		.loc 1 646 0
 1745 0020 2242     		tst	r2, r4
 1746 0022 F4D1     		bne	.L293
 655:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C2 |= MCG_C2_LP_MASK; // set LP bit  
 1747              		.loc 1 655 0
 1748 0024 5978     		ldrb	r1, [r3, #1]
 1749 0026 0A43     		orr	r2, r1
 1750 0028 D2B2     		uxtb	r2, r2
 1751 002a 5A70     		strb	r2, [r3, #1]
 658:../Sources/TFC/TFC_CrystalClock.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency     
 1752              		.loc 1 658 0
 1753 002c F0E7     		b	.L289
 1754              	.L296:
 1755 002e C046     		.align	2
 1756              	.L295:
 1757 0030 00400640 		.word	1074151424
 1758              		.cfi_endproc
 1759              	.LFE9:
 1761              		.section	.text.fei_fbe,"ax",%progbits
 1762              		.align	2
 1763              		.global	fei_fbe
 1764              		.code	16
 1765              		.thumb_func
 1767              	fei_fbe:
 1768              	.LFB11:
 734:../Sources/TFC/TFC_CrystalClock.c **** {
 1769              		.loc 1 734 0
 1770              		.cfi_startproc
 1771              	.LVL155:
 1772 0000 70B5     		push	{r4, r5, r6, lr}
 1773              	.LCFI15:
 1774              		.cfi_def_cfa_offset 16
 1775              		.cfi_offset 4, -16
 1776              		.cfi_offset 5, -12
 1777              		.cfi_offset 6, -8
 1778              		.cfi_offset 14, -4
 740:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 1779              		.loc 1 740 0
 1780 0002 5C4B     		ldr	r3, .L364
 1781 0004 9C79     		ldrb	r4, [r3, #6]
 1782 0006 2507     		lsl	r5, r4, #28
 1783 0008 AE0F     		lsr	r6, r5, #30
 1784 000a 0AD1     		bne	.L312
 741:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 1785              		.loc 1 741 0
 1786 000c 9C79     		ldrb	r4, [r3, #6]
 740:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 1787              		.loc 1 740 0
 1788 000e E506     		lsl	r5, r4, #27
 1789 0010 07D5     		bpl	.L312
 742:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selecte
 1790              		.loc 1 742 0
 1791 0012 9B79     		ldrb	r3, [r3, #6]
 740:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 1792              		.loc 1 740 0
 1793 0014 9C06     		lsl	r4, r3, #26
 1794 0016 04D4     		bmi	.L312
 748:../Sources/TFC/TFC_CrystalClock.c ****   if  (crystal_val > 50000000) {return 0x21;}
 1795              		.loc 1 748 0
 1796 0018 574D     		ldr	r5, .L364+4
 1797 001a A842     		cmp	r0, r5
 1798 001c 03DD     		ble	.L356
 1799 001e 2120     		mov	r0, #33
 1800              	.LVL156:
 1801 0020 00E0     		b	.L298
 1802              	.LVL157:
 1803              	.L312:
 744:../Sources/TFC/TFC_CrystalClock.c ****     return 0x1;                                                     // return error code
 1804              		.loc 1 744 0
 1805 0022 0120     		mov	r0, #1
 1806              	.LVL158:
 1807              	.L298:
 829:../Sources/TFC/TFC_CrystalClock.c **** } // fei_fbe
 1808              		.loc 1 829 0
 1809              		@ sp needed for prologue
 1810 0024 70BD     		pop	{r4, r5, r6, pc}
 1811              	.LVL159:
 1812              	.L356:
 751:../Sources/TFC/TFC_CrystalClock.c ****   if (erefs_val)
 1813              		.loc 1 751 0
 1814 0026 002A     		cmp	r2, #0
 1815 0028 2FD1     		bne	.L357
 1816              	.L299:
 761:../Sources/TFC/TFC_CrystalClock.c ****     hgo_val = 1; // force hgo_val to 1 if > 0
 1817              		.loc 1 761 0
 1818 002a 4B1E     		sub	r3, r1, #1
 1819 002c 9941     		sbc	r1, r1, r3
 1820              	.LVL160:
 767:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C2;
 1821              		.loc 1 767 0
 1822 002e 514B     		ldr	r3, .L364
 768:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
 1823              		.loc 1 768 0
 1824 0030 3C25     		mov	r5, #60
 767:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C2;
 1825              		.loc 1 767 0
 1826 0032 5C78     		ldrb	r4, [r3, #1]
 1827              	.LVL161:
 769:../Sources/TFC/TFC_CrystalClock.c ****   if (crystal_val <= 40000)
 1828              		.loc 1 769 0
 1829 0034 514E     		ldr	r6, .L364+8
 768:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
 1830              		.loc 1 768 0
 1831 0036 AC43     		bic	r4, r5
 1832              	.LVL162:
 1833 0038 251C     		mov	r5, r4
 1834              	.LVL163:
 769:../Sources/TFC/TFC_CrystalClock.c ****   if (crystal_val <= 40000)
 1835              		.loc 1 769 0
 1836 003a B042     		cmp	r0, r6
 1837 003c 51DC     		bgt	.L300
 771:../Sources/TFC/TFC_CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 1838              		.loc 1 771 0
 1839 003e 9400     		lsl	r4, r2, #2
 1840              	.LVL164:
 1841 0040 2543     		orr	r5, r4
 1842              	.LVL165:
 1843 0042 EDB2     		uxtb	r5, r5
 1844 0044 C900     		lsl	r1, r1, #3
 1845 0046 2943     		orr	r1, r5
 1846              	.LVL166:
 781:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C2 = temp_reg;
 1847              		.loc 1 781 0
 1848 0048 5970     		strb	r1, [r3, #1]
 1849 004a 0023     		mov	r3, #0
 1850              	.LVL167:
 1851              	.L301:
 794:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C1;
 1852              		.loc 1 794 0
 1853 004c 494E     		ldr	r6, .L364
 795:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these
 1854              		.loc 1 795 0
 1855 004e 0325     		mov	r5, #3
 794:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C1;
 1856              		.loc 1 794 0
 1857 0050 3478     		ldrb	r4, [r6]
 1858              	.LVL168:
 796:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
 1859              		.loc 1 796 0
 1860 0052 8021     		mov	r1, #128
 795:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these
 1861              		.loc 1 795 0
 1862 0054 2C40     		and	r4, r5
 1863              	.LVL169:
 796:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
 1864              		.loc 1 796 0
 1865 0056 0C43     		orr	r4, r1
 1866 0058 2343     		orr	r3, r4
 1867              	.LVL170:
 797:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 = temp_reg;
 1868              		.loc 1 797 0
 1869 005a 3370     		strb	r3, [r6]
 800:../Sources/TFC/TFC_CrystalClock.c ****   if (erefs_val)
 1870              		.loc 1 800 0
 1871 005c 002A     		cmp	r2, #0
 1872 005e 23D0     		beq	.L304
 1873 0060 4749     		ldr	r1, .L364+12
 804:../Sources/TFC/TFC_CrystalClock.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 1874              		.loc 1 804 0
 1875 0062 0222     		mov	r2, #2
 1876              	.LVL171:
 1877 0064 08E0     		b	.L306
 1878              	.LVL172:
 1879              	.L358:
 1880 0066 B579     		ldrb	r5, [r6, #6]
 1881 0068 0139     		sub	r1, r1, #1
 1882 006a 8BB2     		uxth	r3, r1
 1883 006c 2A42     		tst	r2, r5
 1884 006e 06D1     		bne	.L305
 1885 0070 013B     		sub	r3, r3, #1
 1886 0072 99B2     		uxth	r1, r3
 802:../Sources/TFC/TFC_CrystalClock.c ****     for (i = 0 ; i < 10000 ; i++)
 1887              		.loc 1 802 0
 1888 0074 0029     		cmp	r1, #0
 1889 0076 02D0     		beq	.L305
 1890              	.L306:
 804:../Sources/TFC/TFC_CrystalClock.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 1891              		.loc 1 804 0
 1892 0078 B479     		ldrb	r4, [r6, #6]
 1893 007a 2242     		tst	r2, r4
 1894 007c F3D0     		beq	.L358
 1895              	.L305:
 806:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with err
 1896              		.loc 1 806 0
 1897 007e 3D4E     		ldr	r6, .L364
 1898 0080 B279     		ldrb	r2, [r6, #6]
 1899 0082 9207     		lsl	r2, r2, #30
 1900 0084 10D4     		bmi	.L304
 1901 0086 2320     		mov	r0, #35
 1902              	.LVL173:
 1903 0088 CCE7     		b	.L298
 1904              	.LVL174:
 1905              	.L357:
 753:../Sources/TFC/TFC_CrystalClock.c ****     if ((crystal_val < 30000) ||
 1906              		.loc 1 753 0
 1907 008a 3E4E     		ldr	r6, .L364+16
 1908 008c B042     		cmp	r0, r6
 1909 008e 01DC     		bgt	.L359
 1910              	.L316:
 755:../Sources/TFC/TFC_CrystalClock.c ****         (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal op
 1911              		.loc 1 755 0
 1912 0090 2220     		mov	r0, #34
 1913              	.LVL175:
 1914 0092 C7E7     		b	.L298
 1915              	.LVL176:
 1916              	.L359:
 754:../Sources/TFC/TFC_CrystalClock.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 1917              		.loc 1 754 0
 1918 0094 3C4C     		ldr	r4, .L364+20
 753:../Sources/TFC/TFC_CrystalClock.c ****     if ((crystal_val < 30000) ||
 1919              		.loc 1 753 0
 1920 0096 3D4B     		ldr	r3, .L364+24
 754:../Sources/TFC/TFC_CrystalClock.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 1921              		.loc 1 754 0
 1922 0098 0519     		add	r5, r0, r4
 753:../Sources/TFC/TFC_CrystalClock.c ****     if ((crystal_val < 30000) ||
 1923              		.loc 1 753 0
 1924 009a 9D42     		cmp	r5, r3
 1925 009c F8D9     		bls	.L316
 754:../Sources/TFC/TFC_CrystalClock.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 1926              		.loc 1 754 0
 1927 009e 3C4E     		ldr	r6, .L364+28
 1928 00a0 B042     		cmp	r0, r6
 1929 00a2 C2DD     		ble	.L299
 755:../Sources/TFC/TFC_CrystalClock.c ****         (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal op
 1930              		.loc 1 755 0
 1931 00a4 2220     		mov	r0, #34
 1932              	.LVL177:
 1933 00a6 BDE7     		b	.L298
 1934              	.LVL178:
 1935              	.L304:
 812:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 1936              		.loc 1 812 0
 1937 00a8 324D     		ldr	r5, .L364
 1938 00aa 1021     		mov	r1, #16
 1939 00ac AC79     		ldrb	r4, [r5, #6]
 1940 00ae 2142     		tst	r1, r4
 1941 00b0 11D0     		beq	.L307
 1942 00b2 AE79     		ldrb	r6, [r5, #6]
 1943 00b4 374B     		ldr	r3, .L364+32
 1944 00b6 3142     		tst	r1, r6
 1945 00b8 0DD0     		beq	.L307
 1946 00ba 013B     		sub	r3, r3, #1
 1947 00bc 08E0     		b	.L332
 1948              	.L360:
 1949 00be AC79     		ldrb	r4, [r5, #6]
 1950 00c0 013B     		sub	r3, r3, #1
 1951 00c2 9BB2     		uxth	r3, r3
 1952 00c4 2142     		tst	r1, r4
 1953 00c6 06D0     		beq	.L307
 1954 00c8 013B     		sub	r3, r3, #1
 1955 00ca 9BB2     		uxth	r3, r3
 810:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 1956              		.loc 1 810 0
 1957 00cc 002B     		cmp	r3, #0
 1958 00ce 02D0     		beq	.L307
 1959              	.L332:
 812:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 1960              		.loc 1 812 0
 1961 00d0 AA79     		ldrb	r2, [r5, #6]
 1962 00d2 1142     		tst	r1, r2
 1963 00d4 F3D1     		bne	.L360
 1964              	.L307:
 814:../Sources/TFC/TFC_CrystalClock.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
 1965              		.loc 1 814 0
 1966 00d6 274D     		ldr	r5, .L364
 1967 00d8 A979     		ldrb	r1, [r5, #6]
 1968 00da CC06     		lsl	r4, r1, #27
 1969 00dc 2BD5     		bpl	.L361
 1970 00de 1120     		mov	r0, #17
 1971              	.LVL179:
 1972 00e0 A0E7     		b	.L298
 1973              	.LVL180:
 1974              	.L300:
 773:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 8000000)
 1975              		.loc 1 773 0
 1976 00e2 2D4C     		ldr	r4, .L364+36
 1977              	.LVL181:
 1978 00e4 A042     		cmp	r0, r4
 1979 00e6 1DDC     		bgt	.L302
 775:../Sources/TFC/TFC_CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 1980              		.loc 1 775 0
 1981 00e8 1026     		mov	r6, #16
 1982 00ea 3543     		orr	r5, r6
 1983              	.LVL182:
 1984 00ec 9400     		lsl	r4, r2, #2
 1985 00ee 2543     		orr	r5, r4
 1986 00f0 EDB2     		uxtb	r5, r5
 1987 00f2 C900     		lsl	r1, r1, #3
 784:../Sources/TFC/TFC_CrystalClock.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 1988              		.loc 1 784 0
 1989 00f4 294E     		ldr	r6, .L364+40
 775:../Sources/TFC/TFC_CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 1990              		.loc 1 775 0
 1991 00f6 2943     		orr	r1, r5
 1992              	.LVL183:
 781:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C2 = temp_reg;
 1993              		.loc 1 781 0
 1994 00f8 5970     		strb	r1, [r3, #1]
 784:../Sources/TFC/TFC_CrystalClock.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 1995              		.loc 1 784 0
 1996 00fa 0023     		mov	r3, #0
 1997 00fc B042     		cmp	r0, r6
 1998 00fe A5DD     		ble	.L301
 1999              	.LVL184:
 2000              	.L303:
 785:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
 2001              		.loc 1 785 0
 2002 0100 274C     		ldr	r4, .L364+44
 2003 0102 0823     		mov	r3, #8
 2004 0104 A042     		cmp	r0, r4
 2005 0106 A1DD     		ble	.L301
 786:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
 2006              		.loc 1 786 0
 2007 0108 264D     		ldr	r5, .L364+48
 2008 010a 1023     		mov	r3, #16
 2009 010c A842     		cmp	r0, r5
 2010 010e 9DDD     		ble	.L301
 787:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
 2011              		.loc 1 787 0
 2012 0110 2549     		ldr	r1, .L364+52
 2013 0112 1823     		mov	r3, #24
 2014 0114 8842     		cmp	r0, r1
 2015 0116 99DD     		ble	.L301
 788:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
 2016              		.loc 1 788 0
 2017 0118 244E     		ldr	r6, .L364+56
 2018 011a 2823     		mov	r3, #40
 2019 011c B042     		cmp	r0, r6
 2020 011e 95DC     		bgt	.L301
 2021 0120 2023     		mov	r3, #32
 2022 0122 93E7     		b	.L301
 2023              	.LVL185:
 2024              	.L302:
 779:../Sources/TFC/TFC_CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 2025              		.loc 1 779 0
 2026 0124 2026     		mov	r6, #32
 2027 0126 3543     		orr	r5, r6
 2028              	.LVL186:
 2029 0128 9400     		lsl	r4, r2, #2
 2030 012a 2543     		orr	r5, r4
 2031 012c EDB2     		uxtb	r5, r5
 2032 012e C900     		lsl	r1, r1, #3
 2033 0130 2943     		orr	r1, r5
 2034              	.LVL187:
 781:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C2 = temp_reg;
 2035              		.loc 1 781 0
 2036 0132 5970     		strb	r1, [r3, #1]
 2037 0134 E4E7     		b	.L303
 2038              	.LVL188:
 2039              	.L361:
 814:../Sources/TFC/TFC_CrystalClock.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
 2040              		.loc 1 814 0
 2041 0136 FA26     		mov	r6, #250
 2042 0138 F600     		lsl	r6, r6, #3
 819:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 2043              		.loc 1 819 0
 2044 013a 0C22     		mov	r2, #12
 2045 013c 09E0     		b	.L309
 2046              	.L362:
 2047 013e A979     		ldrb	r1, [r5, #6]
 2048 0140 013E     		sub	r6, r6, #1
 2049 0142 B3B2     		uxth	r3, r6
 2050 0144 1140     		and	r1, r2
 2051 0146 0829     		cmp	r1, #8
 2052 0148 07D0     		beq	.L308
 2053 014a 013B     		sub	r3, r3, #1
 2054 014c 9EB2     		uxth	r6, r3
 817:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 2055              		.loc 1 817 0
 2056 014e 002E     		cmp	r6, #0
 2057 0150 03D0     		beq	.L308
 2058              	.L309:
 819:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 2059              		.loc 1 819 0
 2060 0152 AC79     		ldrb	r4, [r5, #6]
 2061 0154 1440     		and	r4, r2
 2062 0156 082C     		cmp	r4, #8
 2063 0158 F1D1     		bne	.L362
 2064              	.L308:
 821:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
 2065              		.loc 1 821 0
 2066 015a 064D     		ldr	r5, .L364
 2067 015c AA79     		ldrb	r2, [r5, #6]
 2068 015e 1407     		lsl	r4, r2, #28
 2069 0160 A30F     		lsr	r3, r4, #30
 2070 0162 022B     		cmp	r3, #2
 2071 0164 01D0     		beq	.L363
 2072 0166 1A20     		mov	r0, #26
 2073              	.LVL189:
 2074 0168 5CE7     		b	.L298
 2075              	.LVL190:
 2076              	.L363:
 826:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 |= MCG_C6_CME0_MASK;
 2077              		.loc 1 826 0
 2078 016a 6979     		ldrb	r1, [r5, #5]
 2079 016c 2026     		mov	r6, #32
 2080 016e 0E43     		orr	r6, r1
 2081 0170 6E71     		strb	r6, [r5, #5]
 828:../Sources/TFC/TFC_CrystalClock.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency
 2082              		.loc 1 828 0
 2083 0172 57E7     		b	.L298
 2084              	.L365:
 2085              		.align	2
 2086              	.L364:
 2087 0174 00400640 		.word	1074151424
 2088 0178 80F0FA02 		.word	50000000
 2089 017c 409C0000 		.word	40000
 2090 0180 10270000 		.word	10000
 2091 0184 2F750000 		.word	29999
 2092 0188 BF63FFFF 		.word	-40001
 2093 018c 7E2A2D00 		.word	2959998
 2094 0190 0048E801 		.word	32000000
 2095 0194 CF070000 		.word	1999
 2096 0198 00127A00 		.word	8000000
 2097 019c D0121300 		.word	1250000
 2098 01a0 A0252600 		.word	2500000
 2099 01a4 404B4C00 		.word	5000000
 2100 01a8 80969800 		.word	10000000
 2101 01ac 002D3101 		.word	20000000
 2102              		.cfi_endproc
 2103              	.LFE11:
 2105              		.section	.text.fbe_fee,"ax",%progbits
 2106              		.align	2
 2107              		.global	fbe_fee
 2108              		.code	16
 2109              		.thumb_func
 2111              	fbe_fee:
 2112              	.LFB12:
 833:../Sources/TFC/TFC_CrystalClock.c **** {
 2113              		.loc 1 833 0
 2114              		.cfi_startproc
 2115              	.LVL191:
 2116 0000 38B5     		push	{r3, r4, r5, lr}
 2117              	.LCFI16:
 2118              		.cfi_def_cfa_offset 16
 2119              		.cfi_offset 3, -16
 2120              		.cfi_offset 4, -12
 2121              		.cfi_offset 5, -8
 2122              		.cfi_offset 14, -4
 838:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2123              		.loc 1 838 0
 2124 0002 264B     		ldr	r3, .L389
 843:../Sources/TFC/TFC_CrystalClock.c ****     return 0x4;                                                       // return error code
 2125              		.loc 1 843 0
 2126 0004 0424     		mov	r4, #4
 838:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2127              		.loc 1 838 0
 2128 0006 9A79     		ldrb	r2, [r3, #6]
 2129 0008 1107     		lsl	r1, r2, #28
 2130 000a 8A0F     		lsr	r2, r1, #30
 2131 000c 022A     		cmp	r2, #2
 2132 000e 01D0     		beq	.L387
 2133              	.LVL192:
 2134              	.L367:
 872:../Sources/TFC/TFC_CrystalClock.c **** } // fbe_fee
 2135              		.loc 1 872 0
 2136 0010 201C     		mov	r0, r4
 2137              		@ sp needed for prologue
 2138 0012 38BD     		pop	{r3, r4, r5, pc}
 2139              	.LVL193:
 2140              	.L387:
 839:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 2141              		.loc 1 839 0
 2142 0014 9D79     		ldrb	r5, [r3, #6]
 838:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2143              		.loc 1 838 0
 2144 0016 ED06     		lsl	r5, r5, #27
 2145 0018 FAD4     		bmi	.L367
 840:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 2146              		.loc 1 840 0
 2147 001a 9D79     		ldrb	r5, [r3, #6]
 2148 001c 2021     		mov	r1, #32
 839:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 2149              		.loc 1 839 0
 2150 001e 2942     		tst	r1, r5
 2151 0020 F6D1     		bne	.L367
 841:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 2152              		.loc 1 841 0
 2153 0022 5D78     		ldrb	r5, [r3, #1]
 838:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2154              		.loc 1 838 0
 2155 0024 2A42     		tst	r2, r5
 2156 0026 F3D1     		bne	.L367
 847:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
 2157              		.loc 1 847 0
 2158 0028 5C78     		ldrb	r4, [r3, #1]
 2159 002a 3022     		mov	r2, #48
 2160 002c 2242     		tst	r2, r4
 2161 002e 2CD0     		beq	.L368
 849:../Sources/TFC/TFC_CrystalClock.c ****     fll_ref_freq = (crystal_val / (32 << ((MCG_C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT)));
 2162              		.loc 1 849 0
 2163 0030 1C78     		ldrb	r4, [r3]
 2164 0032 A206     		lsl	r2, r4, #26
 2165 0034 530F     		lsr	r3, r2, #29
 2166 0036 9940     		lsl	r1, r1, r3
 2167 0038 FFF7FEFF 		bl	__aeabi_idiv
 2168              	.LVL194:
 2169 003c 80B2     		uxth	r0, r0
 2170              	.LVL195:
 2171              	.L369:
 2172              	.LBB4:
 2173              	.LBB5:
1795:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) > 0x1) 
 2174              		.loc 1 1795 0
 2175 003e 174D     		ldr	r5, .L389
1797:../Sources/TFC/TFC_CrystalClock.c ****     return 0x3B; // return error code if DRS range 2 or 3 selected
 2176              		.loc 1 1797 0
 2177 0040 3B24     		mov	r4, #59
1795:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) > 0x1) 
 2178              		.loc 1 1795 0
 2179 0042 E978     		ldrb	r1, [r5, #3]
 2180 0044 4A06     		lsl	r2, r1, #25
 2181 0046 E3D4     		bmi	.L367
 2182              	.LBE5:
 2183              	.LBE4:
 857:../Sources/TFC/TFC_CrystalClock.c ****   mcg_out = fll_freq(fll_ref_freq); // FLL reference frequency calculated from ext ref freq and FRD
 2184              		.loc 1 857 0
 2185 0048 00B2     		sxth	r0, r0
 2186              	.LVL196:
 2187 004a FFF7FEFF 		bl	fll_freq.part.0
 2188              	.LVL197:
 2189 004e 041E     		sub	r4, r0, #0
 858:../Sources/TFC/TFC_CrystalClock.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
 2190              		.loc 1 858 0
 2191 0050 3B2C     		cmp	r4, #59
 2192 0052 DDDD     		ble	.L367
 861:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to select FLL output
 2193              		.loc 1 861 0
 2194 0054 2878     		ldrb	r0, [r5]
 2195 0056 3F22     		mov	r2, #63
 2196 0058 1040     		and	r0, r2
 2197 005a FA23     		mov	r3, #250
 2198 005c 2870     		strb	r0, [r5]
 2199              	.LVL198:
 2200 005e DA00     		lsl	r2, r3, #3
 866:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST
 2201              		.loc 1 866 0
 2202 0060 0C21     		mov	r1, #12
 2203 0062 08E0     		b	.L371
 2204              	.LVL199:
 2205              	.L388:
 2206 0064 AB79     		ldrb	r3, [r5, #6]
 2207 0066 013A     		sub	r2, r2, #1
 2208 0068 92B2     		uxth	r2, r2
 2209 006a 1942     		tst	r1, r3
 2210 006c 06D0     		beq	.L370
 2211 006e 013A     		sub	r2, r2, #1
 2212 0070 92B2     		uxth	r2, r2
 864:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 2213              		.loc 1 864 0
 2214 0072 002A     		cmp	r2, #0
 2215 0074 02D0     		beq	.L370
 2216              	.L371:
 866:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST
 2217              		.loc 1 866 0
 2218 0076 A879     		ldrb	r0, [r5, #6]
 2219 0078 0142     		tst	r1, r0
 2220 007a F3D1     		bne	.L388
 2221              	.L370:
 868:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check FLL is really
 2222              		.loc 1 868 0
 2223 007c 074D     		ldr	r5, .L389
 2224 007e A979     		ldrb	r1, [r5, #6]
 2225 0080 0807     		lsl	r0, r1, #28
 2226 0082 830F     		lsr	r3, r0, #30
 2227 0084 C4D0     		beq	.L367
 2228 0086 1824     		mov	r4, #24
 2229 0088 C2E7     		b	.L367
 2230              	.LVL200:
 2231              	.L368:
 853:../Sources/TFC/TFC_CrystalClock.c ****     fll_ref_freq = ((crystal_val) / (1 << (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT)))
 2232              		.loc 1 853 0
 2233 008a 5B78     		ldrb	r3, [r3, #1]
 2234 008c 0121     		mov	r1, #1
 2235 008e 1A40     		and	r2, r3
 2236 0090 1509     		lsr	r5, r2, #4
 2237 0092 A940     		lsl	r1, r1, r5
 2238 0094 FFF7FEFF 		bl	__aeabi_idiv
 2239              	.LVL201:
 2240 0098 80B2     		uxth	r0, r0
 2241              	.LVL202:
 2242 009a D0E7     		b	.L369
 2243              	.L390:
 2244              		.align	2
 2245              	.L389:
 2246 009c 00400640 		.word	1074151424
 2247              		.cfi_endproc
 2248              	.LFE12:
 2250              		.section	.text.fee_fbe,"ax",%progbits
 2251              		.align	2
 2252              		.global	fee_fbe
 2253              		.code	16
 2254              		.thumb_func
 2256              	fee_fbe:
 2257              	.LFB13:
 876:../Sources/TFC/TFC_CrystalClock.c **** { 
 2258              		.loc 1 876 0
 2259              		.cfi_startproc
 2260              	.LVL203:
 2261 0000 10B5     		push	{r4, lr}
 2262              	.LCFI17:
 2263              		.cfi_def_cfa_offset 8
 2264              		.cfi_offset 4, -8
 2265              		.cfi_offset 14, -4
 880:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 2266              		.loc 1 880 0
 2267 0002 154B     		ldr	r3, .L410
 2268 0004 9A79     		ldrb	r2, [r3, #6]
 2269 0006 1107     		lsl	r1, r2, #28
 2270 0008 8C0F     		lsr	r4, r1, #30
 2271 000a 01D0     		beq	.L408
 2272              	.L397:
 884:../Sources/TFC/TFC_CrystalClock.c ****     return 0x2;                                                       // return error code
 2273              		.loc 1 884 0
 2274 000c 0220     		mov	r0, #2
 2275              	.LVL204:
 2276              	.L392:
 900:../Sources/TFC/TFC_CrystalClock.c **** } // fee_fbe
 2277              		.loc 1 900 0
 2278              		@ sp needed for prologue
 2279 000e 10BD     		pop	{r4, pc}
 2280              	.LVL205:
 2281              	.L408:
 881:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 2282              		.loc 1 881 0
 2283 0010 9A79     		ldrb	r2, [r3, #6]
 880:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 2284              		.loc 1 880 0
 2285 0012 D106     		lsl	r1, r2, #27
 2286 0014 FAD4     		bmi	.L397
 882:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selecte
 2287              		.loc 1 882 0
 2288 0016 9979     		ldrb	r1, [r3, #6]
 880:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 2289              		.loc 1 880 0
 2290 0018 8906     		lsl	r1, r1, #26
 2291 001a F7D4     		bmi	.L397
 889:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 |= MCG_C1_CLKS(2); // set CLKS to select ext ref clock
 2292              		.loc 1 889 0
 2293 001c 1C78     		ldrb	r4, [r3]
 2294 001e 8022     		mov	r2, #128
 2295 0020 2243     		orr	r2, r4
 2296 0022 FA21     		mov	r1, #250
 2297 0024 1A70     		strb	r2, [r3]
 2298              	.LVL206:
 2299 0026 CA00     		lsl	r2, r1, #3
 894:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 2300              		.loc 1 894 0
 2301 0028 0C21     		mov	r1, #12
 2302 002a 09E0     		b	.L394
 2303              	.LVL207:
 2304              	.L409:
 2305 002c 9C79     		ldrb	r4, [r3, #6]
 2306 002e 013A     		sub	r2, r2, #1
 2307 0030 92B2     		uxth	r2, r2
 2308 0032 0C40     		and	r4, r1
 2309 0034 082C     		cmp	r4, #8
 2310 0036 07D0     		beq	.L393
 2311 0038 013A     		sub	r2, r2, #1
 2312 003a 92B2     		uxth	r2, r2
 892:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 2313              		.loc 1 892 0
 2314 003c 002A     		cmp	r2, #0
 2315 003e 03D0     		beq	.L393
 2316              	.L394:
 894:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 2317              		.loc 1 894 0
 2318 0040 9C79     		ldrb	r4, [r3, #6]
 2319 0042 0C40     		and	r4, r1
 2320 0044 082C     		cmp	r4, #8
 2321 0046 F1D1     		bne	.L409
 2322              	.L393:
 896:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
 2323              		.loc 1 896 0
 2324 0048 034B     		ldr	r3, .L410
 2325 004a 9979     		ldrb	r1, [r3, #6]
 2326 004c 0C07     		lsl	r4, r1, #28
 2327 004e A20F     		lsr	r2, r4, #30
 2328 0050 022A     		cmp	r2, #2
 2329 0052 DCD0     		beq	.L392
 2330 0054 1A20     		mov	r0, #26
 2331              	.LVL208:
 2332 0056 DAE7     		b	.L392
 2333              	.L411:
 2334              		.align	2
 2335              	.L410:
 2336 0058 00400640 		.word	1074151424
 2337              		.cfi_endproc
 2338              	.LFE13:
 2340              		.section	.text.fbe_fbi,"ax",%progbits
 2341              		.align	2
 2342              		.global	fbe_fbi
 2343              		.code	16
 2344              		.thumb_func
 2346              	fbe_fbi:
 2347              	.LFB14:
 904:../Sources/TFC/TFC_CrystalClock.c **** {
 2348              		.loc 1 904 0
 2349              		.cfi_startproc
 2350              	.LVL209:
 2351 0000 38B5     		push	{r3, r4, r5, lr}
 2352              	.LCFI18:
 2353              		.cfi_def_cfa_offset 16
 2354              		.cfi_offset 3, -16
 2355              		.cfi_offset 4, -12
 2356              		.cfi_offset 5, -8
 2357              		.cfi_offset 14, -4
 910:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2358              		.loc 1 910 0
 2359 0002 524B     		ldr	r3, .L468
 2360 0004 9A79     		ldrb	r2, [r3, #6]
 2361 0006 1407     		lsl	r4, r2, #28
 2362 0008 A20F     		lsr	r2, r4, #30
 2363 000a 022A     		cmp	r2, #2
 2364 000c 01D0     		beq	.L459
 2365              	.L428:
 915:../Sources/TFC/TFC_CrystalClock.c ****     return 0x4;                                                       // return error code
 2366              		.loc 1 915 0
 2367 000e 0420     		mov	r0, #4
 2368              	.LVL210:
 2369              	.L413:
 990:../Sources/TFC/TFC_CrystalClock.c **** } //fbe_fbi
 2370              		.loc 1 990 0
 2371              		@ sp needed for prologue
 2372 0010 38BD     		pop	{r3, r4, r5, pc}
 2373              	.LVL211:
 2374              	.L459:
 911:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 2375              		.loc 1 911 0
 2376 0012 9D79     		ldrb	r5, [r3, #6]
 910:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2377              		.loc 1 910 0
 2378 0014 ED06     		lsl	r5, r5, #27
 2379 0016 FAD4     		bmi	.L428
 912:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 2380              		.loc 1 912 0
 2381 0018 9D79     		ldrb	r5, [r3, #6]
 2382 001a 2024     		mov	r4, #32
 911:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 2383              		.loc 1 911 0
 2384 001c 2C42     		tst	r4, r5
 2385 001e F6D1     		bne	.L428
 913:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 2386              		.loc 1 913 0
 2387 0020 5D78     		ldrb	r5, [r3, #1]
 910:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2388              		.loc 1 910 0
 2389 0022 2A42     		tst	r2, r5
 2390 0024 F3D1     		bne	.L428
 919:../Sources/TFC/TFC_CrystalClock.c ****   if (!(irc_select))
 2391              		.loc 1 919 0
 2392 0026 0029     		cmp	r1, #0
 2393 0028 06D1     		bne	.L414
 921:../Sources/TFC/TFC_CrystalClock.c ****     if ((irc_freq < 31250) || (irc_freq > 39063)) {return 0x31;}
 2394              		.loc 1 921 0
 2395 002a 494D     		ldr	r5, .L468+4
 2396 002c 494A     		ldr	r2, .L468+8
 2397 002e 4519     		add	r5, r0, r5
 2398 0030 9542     		cmp	r5, r2
 2399 0032 08D9     		bls	.L460
 2400 0034 3120     		mov	r0, #49
 2401              	.LVL212:
 2402 0036 EBE7     		b	.L413
 2403              	.LVL213:
 2404              	.L414:
 925:../Sources/TFC/TFC_CrystalClock.c ****     if ((irc_freq < 3000000) || (irc_freq > 5000000)) {return 0x32;} // Fast IRC freq
 2405              		.loc 1 925 0
 2406 0038 474A     		ldr	r2, .L468+12
 2407 003a 8518     		add	r5, r0, r2
 2408 003c 474A     		ldr	r2, .L468+16
 2409 003e 9542     		cmp	r5, r2
 2410 0040 24D9     		bls	.L461
 2411 0042 3220     		mov	r0, #50
 2412              	.LVL214:
 2413 0044 E4E7     		b	.L413
 2414              	.LVL215:
 2415              	.L460:
 935:../Sources/TFC/TFC_CrystalClock.c ****     MCG_C2 &= ~MCG_C2_IRCS_MASK; // select slow IRC by clearing IRCS
 2416              		.loc 1 935 0
 2417 0046 5A78     		ldrb	r2, [r3, #1]
 2418 0048 0125     		mov	r5, #1
 2419 004a AA43     		bic	r2, r5
 2420 004c 5A70     		strb	r2, [r3, #1]
 939:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 &= ~MCG_C6_CME0_MASK;
 2421              		.loc 1 939 0
 2422 004e 5A79     		ldrb	r2, [r3, #5]
 2423 0050 A243     		bic	r2, r4
 2424 0052 5A71     		strb	r2, [r3, #5]
 942:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C1;
 2425              		.loc 1 942 0
 2426 0054 1D78     		ldrb	r5, [r3]
 2427              	.LVL216:
 943:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~MCG_C1_CLKS_MASK;                    // clear CLKS bits 
 2428              		.loc 1 943 0
 2429 0056 3F24     		mov	r4, #63
 2430 0058 2C40     		and	r4, r5
 2431              	.LVL217:
 944:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= (MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK); // select IRC as MCGOUT and enable IREFS
 2432              		.loc 1 944 0
 2433 005a 4422     		mov	r2, #68
 2434 005c 2243     		orr	r2, r4
 2435              	.LVL218:
 945:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 = temp_reg; // update MCG_C1
 2436              		.loc 1 945 0
 2437 005e FA25     		mov	r5, #250
 2438 0060 1A70     		strb	r2, [r3]
 2439              	.LVL219:
 952:../Sources/TFC/TFC_CrystalClock.c ****       if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishe
 2440              		.loc 1 952 0
 2441 0062 0124     		mov	r4, #1
 945:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 = temp_reg; // update MCG_C1
 2442              		.loc 1 945 0
 2443 0064 EA00     		lsl	r2, r5, #3
 2444              	.LVL220:
 2445 0066 08E0     		b	.L418
 2446              	.LVL221:
 2447              	.L462:
 952:../Sources/TFC/TFC_CrystalClock.c ****       if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishe
 2448              		.loc 1 952 0
 2449 0068 9D79     		ldrb	r5, [r3, #6]
 2450 006a 013A     		sub	r2, r2, #1
 2451 006c 92B2     		uxth	r2, r2
 2452 006e 2C42     		tst	r4, r5
 2453 0070 06D0     		beq	.L417
 2454 0072 013A     		sub	r2, r2, #1
 2455 0074 92B2     		uxth	r2, r2
 950:../Sources/TFC/TFC_CrystalClock.c ****     for (i = 0 ; i < 2000 ; i++)
 2456              		.loc 1 950 0
 2457 0076 002A     		cmp	r2, #0
 2458 0078 02D0     		beq	.L417
 2459              	.L418:
 952:../Sources/TFC/TFC_CrystalClock.c ****       if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishe
 2460              		.loc 1 952 0
 2461 007a 9D79     		ldrb	r5, [r3, #6]
 2462 007c 2C42     		tst	r4, r5
 2463 007e F3D1     		bne	.L462
 2464              	.L417:
 954:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_IRCST_MASK) return 0x13; // check bit is really clear and return with error i
 2465              		.loc 1 954 0
 2466 0080 324B     		ldr	r3, .L468
 2467 0082 9C79     		ldrb	r4, [r3, #6]
 2468 0084 E407     		lsl	r4, r4, #31
 2469 0086 24D5     		bpl	.L421
 2470 0088 1320     		mov	r0, #19
 2471              	.LVL222:
 2472 008a C1E7     		b	.L413
 2473              	.LVL223:
 2474              	.L461:
 931:../Sources/TFC/TFC_CrystalClock.c ****     MCG_C2 |= MCG_C2_IRCS_MASK; // select fast IRC by setting IRCS
 2475              		.loc 1 931 0
 2476 008c 5D78     		ldrb	r5, [r3, #1]
 2477 008e 0122     		mov	r2, #1
 2478 0090 2A43     		orr	r2, r5
 2479 0092 5A70     		strb	r2, [r3, #1]
 939:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 &= ~MCG_C6_CME0_MASK;
 2480              		.loc 1 939 0
 2481 0094 5D79     		ldrb	r5, [r3, #5]
 2482 0096 A543     		bic	r5, r4
 2483 0098 5D71     		strb	r5, [r3, #5]
 942:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C1;
 2484              		.loc 1 942 0
 2485 009a 1A78     		ldrb	r2, [r3]
 2486              	.LVL224:
 943:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~MCG_C1_CLKS_MASK;                    // clear CLKS bits 
 2487              		.loc 1 943 0
 2488 009c 3F24     		mov	r4, #63
 2489 009e 1440     		and	r4, r2
 2490              	.LVL225:
 944:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= (MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK); // select IRC as MCGOUT and enable IREFS
 2491              		.loc 1 944 0
 2492 00a0 4425     		mov	r5, #68
 2493 00a2 2543     		orr	r5, r4
 2494              	.LVL226:
 945:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 = temp_reg; // update MCG_C1
 2495              		.loc 1 945 0
 2496 00a4 FA22     		mov	r2, #250
 2497 00a6 1D70     		strb	r5, [r3]
 2498              	.LVL227:
 2499 00a8 D200     		lsl	r2, r2, #3
 960:../Sources/TFC/TFC_CrystalClock.c ****       if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
 2500              		.loc 1 960 0
 2501 00aa 0124     		mov	r4, #1
 2502 00ac 08E0     		b	.L416
 2503              	.LVL228:
 2504              	.L463:
 2505 00ae 9D79     		ldrb	r5, [r3, #6]
 2506 00b0 013A     		sub	r2, r2, #1
 2507 00b2 92B2     		uxth	r2, r2
 2508 00b4 2C42     		tst	r4, r5
 2509 00b6 06D1     		bne	.L420
 2510 00b8 013A     		sub	r2, r2, #1
 2511 00ba 92B2     		uxth	r2, r2
 958:../Sources/TFC/TFC_CrystalClock.c ****     for (i = 0 ; i < 2000 ; i++)
 2512              		.loc 1 958 0
 2513 00bc 002A     		cmp	r2, #0
 2514 00be 02D0     		beq	.L420
 2515              	.L416:
 960:../Sources/TFC/TFC_CrystalClock.c ****       if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
 2516              		.loc 1 960 0
 2517 00c0 9D79     		ldrb	r5, [r3, #6]
 2518 00c2 2C42     		tst	r4, r5
 2519 00c4 F3D0     		beq	.L463
 2520              	.L420:
 962:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_IRCST_MASK)) return 0x14; // check bit is really set and return with error 
 2521              		.loc 1 962 0
 2522 00c6 214B     		ldr	r3, .L468
 2523 00c8 9C79     		ldrb	r4, [r3, #6]
 2524 00ca E507     		lsl	r5, r4, #31
 2525 00cc 01D4     		bmi	.L421
 2526 00ce 1420     		mov	r0, #20
 2527              	.LVL229:
 2528 00d0 9EE7     		b	.L413
 2529              	.LVL230:
 2530              	.L421:
 945:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 = temp_reg; // update MCG_C1
 2531              		.loc 1 945 0
 2532 00d2 FA25     		mov	r5, #250
 2533 00d4 EB00     		lsl	r3, r5, #3
 968:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST
 2534              		.loc 1 968 0
 2535 00d6 1D4C     		ldr	r4, .L468
 2536 00d8 0C22     		mov	r2, #12
 2537 00da 09E0     		b	.L419
 2538              	.LVL231:
 2539              	.L464:
 2540 00dc A579     		ldrb	r5, [r4, #6]
 2541 00de 013B     		sub	r3, r3, #1
 2542 00e0 9BB2     		uxth	r3, r3
 2543 00e2 1540     		and	r5, r2
 2544 00e4 042D     		cmp	r5, #4
 2545 00e6 07D0     		beq	.L422
 2546 00e8 013B     		sub	r3, r3, #1
 2547 00ea 9BB2     		uxth	r3, r3
 966:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 2548              		.loc 1 966 0
 2549 00ec 002B     		cmp	r3, #0
 2550 00ee 03D0     		beq	.L422
 2551              	.L419:
 968:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST
 2552              		.loc 1 968 0
 2553 00f0 A579     		ldrb	r5, [r4, #6]
 2554 00f2 1540     		and	r5, r2
 2555 00f4 042D     		cmp	r5, #4
 2556 00f6 F1D1     		bne	.L464
 2557              	.L422:
 970:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19; // check IRC is really
 2558              		.loc 1 970 0
 2559 00f8 144C     		ldr	r4, .L468
 2560 00fa A279     		ldrb	r2, [r4, #6]
 2561 00fc 1507     		lsl	r5, r2, #28
 2562 00fe AB0F     		lsr	r3, r5, #30
 2563 0100 012B     		cmp	r3, #1
 2564 0102 01D0     		beq	.L465
 2565 0104 1920     		mov	r0, #25
 2566              	.LVL232:
 2567 0106 83E7     		b	.L413
 2568              	.LVL233:
 2569              	.L465:
 2570 0108 FA22     		mov	r2, #250
 2571 010a D300     		lsl	r3, r2, #3
 975:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
 2572              		.loc 1 975 0
 2573 010c 1022     		mov	r2, #16
 2574 010e 08E0     		b	.L424
 2575              	.L466:
 2576 0110 A579     		ldrb	r5, [r4, #6]
 2577 0112 013B     		sub	r3, r3, #1
 2578 0114 9BB2     		uxth	r3, r3
 2579 0116 2A42     		tst	r2, r5
 2580 0118 06D1     		bne	.L423
 2581 011a 013B     		sub	r3, r3, #1
 2582 011c 9BB2     		uxth	r3, r3
 973:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 2583              		.loc 1 973 0
 2584 011e 002B     		cmp	r3, #0
 2585 0120 02D0     		beq	.L423
 2586              	.L424:
 975:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
 2587              		.loc 1 975 0
 2588 0122 A579     		ldrb	r5, [r4, #6]
 2589 0124 2A42     		tst	r2, r5
 2590 0126 F3D0     		beq	.L466
 2591              	.L423:
 977:../Sources/TFC/TFC_CrystalClock.c ****   if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error i
 2592              		.loc 1 977 0
 2593 0128 084D     		ldr	r5, .L468
 2594 012a AC79     		ldrb	r4, [r5, #6]
 2595 012c E406     		lsl	r4, r4, #27
 2596 012e 01D4     		bmi	.L467
 2597 0130 1220     		mov	r0, #18
 2598              	.LVL234:
 2599 0132 6DE7     		b	.L413
 2600              	.LVL235:
 2601              	.L467:
 981:../Sources/TFC/TFC_CrystalClock.c ****   if (irc_select)
 2602              		.loc 1 981 0
 2603 0134 0029     		cmp	r1, #0
 2604 0136 00D1     		bne	.LCB3187
 2605 0138 6AE7     		b	.L413	@long jump
 2606              	.LCB3187:
 983:../Sources/TFC/TFC_CrystalClock.c ****     fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fa
 2607              		.loc 1 983 0
 2608 013a 297A     		ldrb	r1, [r5, #8]
 2609              	.LVL236:
 2610 013c 0125     		mov	r5, #1
 2611 013e 0A07     		lsl	r2, r1, #28
 2612 0140 530F     		lsr	r3, r2, #29
 2613 0142 9D40     		lsl	r5, r5, r3
 984:../Sources/TFC/TFC_CrystalClock.c ****     return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by FCRDIV
 2614              		.loc 1 984 0
 2615 0144 E9B2     		uxtb	r1, r5
 2616              	.LVL237:
 2617 0146 FFF7FEFF 		bl	__aeabi_idiv
 2618              	.LVL238:
 2619 014a 61E7     		b	.L413
 2620              	.L469:
 2621              		.align	2
 2622              	.L468:
 2623 014c 00400640 		.word	1074151424
 2624 0150 EE85FFFF 		.word	-31250
 2625 0154 851E0000 		.word	7813
 2626 0158 4039D2FF 		.word	-3000000
 2627 015c 80841E00 		.word	2000000
 2628              		.cfi_endproc
 2629              	.LFE14:
 2631              		.section	.text.fbi_fbe,"ax",%progbits
 2632              		.align	2
 2633              		.global	fbi_fbe
 2634              		.code	16
 2635              		.thumb_func
 2637              	fbi_fbe:
 2638              	.LFB15:
 994:../Sources/TFC/TFC_CrystalClock.c **** {
 2639              		.loc 1 994 0
 2640              		.cfi_startproc
 2641              	.LVL239:
 2642 0000 30B5     		push	{r4, r5, lr}
 2643              	.LCFI19:
 2644              		.cfi_def_cfa_offset 12
 2645              		.cfi_offset 4, -12
 2646              		.cfi_offset 5, -8
 2647              		.cfi_offset 14, -4
1000:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 2648              		.loc 1 1000 0
 2649 0002 5D4B     		ldr	r3, .L537
 2650 0004 9C79     		ldrb	r4, [r3, #6]
 2651 0006 2507     		lsl	r5, r4, #28
 2652 0008 AC0F     		lsr	r4, r5, #30
 2653 000a 012C     		cmp	r4, #1
 2654 000c 01D0     		beq	.L529
 2655              	.L486:
1005:../Sources/TFC/TFC_CrystalClock.c ****     return 0x3;                                                       // MCG not in correct mode re
 2656              		.loc 1 1005 0
 2657 000e 0320     		mov	r0, #3
 2658              	.LVL240:
 2659              	.L471:
1091:../Sources/TFC/TFC_CrystalClock.c **** } // fbi_fbe
 2660              		.loc 1 1091 0
 2661              		@ sp needed for prologue
 2662 0010 30BD     		pop	{r4, r5, pc}
 2663              	.LVL241:
 2664              	.L529:
1001:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 2665              		.loc 1 1001 0
 2666 0012 9D79     		ldrb	r5, [r3, #6]
1000:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 2667              		.loc 1 1000 0
 2668 0014 ED06     		lsl	r5, r5, #27
 2669 0016 FAD5     		bpl	.L486
1002:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 2670              		.loc 1 1002 0
 2671 0018 9C79     		ldrb	r4, [r3, #6]
1001:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 2672              		.loc 1 1001 0
 2673 001a A506     		lsl	r5, r4, #26
 2674 001c F7D4     		bmi	.L486
1003:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
 2675              		.loc 1 1003 0
 2676 001e 5B78     		ldrb	r3, [r3, #1]
1000:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 2677              		.loc 1 1000 0
 2678 0020 9C07     		lsl	r4, r3, #30
 2679 0022 F4D4     		bmi	.L486
1009:../Sources/TFC/TFC_CrystalClock.c ****   if  (crystal_val > 50000000) {return 0x21;}
 2680              		.loc 1 1009 0
 2681 0024 554D     		ldr	r5, .L537+4
 2682 0026 A842     		cmp	r0, r5
 2683 0028 01DD     		ble	.L530
 2684 002a 2120     		mov	r0, #33
 2685              	.LVL242:
 2686 002c F0E7     		b	.L471
 2687              	.LVL243:
 2688              	.L530:
1012:../Sources/TFC/TFC_CrystalClock.c ****   if (erefs_val)
 2689              		.loc 1 1012 0
 2690 002e 002A     		cmp	r2, #0
 2691 0030 0CD0     		beq	.L472
1014:../Sources/TFC/TFC_CrystalClock.c ****     if ((crystal_val < 30000) ||
 2692              		.loc 1 1014 0
 2693 0032 534C     		ldr	r4, .L537+8
 2694 0034 A042     		cmp	r0, r4
 2695 0036 01DC     		bgt	.L531
 2696              	.L490:
1016:../Sources/TFC/TFC_CrystalClock.c ****         (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal op
 2697              		.loc 1 1016 0
 2698 0038 2220     		mov	r0, #34
 2699              	.LVL244:
 2700 003a E9E7     		b	.L471
 2701              	.LVL245:
 2702              	.L531:
1015:../Sources/TFC/TFC_CrystalClock.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 2703              		.loc 1 1015 0
 2704 003c 514B     		ldr	r3, .L537+12
1014:../Sources/TFC/TFC_CrystalClock.c ****     if ((crystal_val < 30000) ||
 2705              		.loc 1 1014 0
 2706 003e 524C     		ldr	r4, .L537+16
1015:../Sources/TFC/TFC_CrystalClock.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 2707              		.loc 1 1015 0
 2708 0040 C518     		add	r5, r0, r3
1014:../Sources/TFC/TFC_CrystalClock.c ****     if ((crystal_val < 30000) ||
 2709              		.loc 1 1014 0
 2710 0042 A542     		cmp	r5, r4
 2711 0044 F8D9     		bls	.L490
1015:../Sources/TFC/TFC_CrystalClock.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 2712              		.loc 1 1015 0
 2713 0046 514B     		ldr	r3, .L537+20
 2714 0048 9842     		cmp	r0, r3
 2715 004a F5DC     		bgt	.L490
 2716              	.L472:
1022:../Sources/TFC/TFC_CrystalClock.c ****     hgo_val = 1; // force hgo_val to 1 if > 0
 2717              		.loc 1 1022 0
 2718 004c 4B1E     		sub	r3, r1, #1
 2719 004e 9941     		sbc	r1, r1, r3
 2720              	.LVL246:
1028:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C2;
 2721              		.loc 1 1028 0
 2722 0050 494B     		ldr	r3, .L537
1029:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
 2723              		.loc 1 1029 0
 2724 0052 3C25     		mov	r5, #60
1028:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C2;
 2725              		.loc 1 1028 0
 2726 0054 5C78     		ldrb	r4, [r3, #1]
 2727              	.LVL247:
1029:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
 2728              		.loc 1 1029 0
 2729 0056 AC43     		bic	r4, r5
 2730              	.LVL248:
1030:../Sources/TFC/TFC_CrystalClock.c ****   if (crystal_val <= 40000)
 2731              		.loc 1 1030 0
 2732 0058 4D4D     		ldr	r5, .L537+24
 2733 005a A842     		cmp	r0, r5
 2734 005c 43DC     		bgt	.L473
1032:../Sources/TFC/TFC_CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 2735              		.loc 1 1032 0
 2736 005e 9500     		lsl	r5, r2, #2
 2737 0060 2C43     		orr	r4, r5
 2738              	.LVL249:
 2739 0062 E4B2     		uxtb	r4, r4
 2740 0064 C900     		lsl	r1, r1, #3
 2741 0066 2143     		orr	r1, r4
 2742              	.LVL250:
1042:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C2 = temp_reg;
 2743              		.loc 1 1042 0
 2744 0068 5970     		strb	r1, [r3, #1]
1046:../Sources/TFC/TFC_CrystalClock.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 2745              		.loc 1 1046 0
 2746 006a 0023     		mov	r3, #0
 2747              	.LVL251:
 2748              	.L474:
1056:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C1;
 2749              		.loc 1 1056 0
 2750 006c 4249     		ldr	r1, .L537
1057:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these
 2751              		.loc 1 1057 0
 2752 006e 0325     		mov	r5, #3
1056:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C1;
 2753              		.loc 1 1056 0
 2754 0070 0C78     		ldrb	r4, [r1]
 2755              	.LVL252:
1058:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
 2756              		.loc 1 1058 0
 2757 0072 DB00     		lsl	r3, r3, #3
 2758              	.LVL253:
1057:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these
 2759              		.loc 1 1057 0
 2760 0074 2540     		and	r5, r4
1058:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
 2761              		.loc 1 1058 0
 2762 0076 8024     		mov	r4, #128
 2763              	.LVL254:
 2764 0078 2C43     		orr	r4, r5
 2765 007a 2343     		orr	r3, r4
 2766              	.LVL255:
1059:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 = temp_reg;
 2767              		.loc 1 1059 0
 2768 007c 0B70     		strb	r3, [r1]
1062:../Sources/TFC/TFC_CrystalClock.c ****   if (erefs_val)
 2769              		.loc 1 1062 0
 2770 007e 002A     		cmp	r2, #0
 2771 0080 14D0     		beq	.L477
 2772 0082 444B     		ldr	r3, .L537+28
 2773              	.LVL256:
1066:../Sources/TFC/TFC_CrystalClock.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 2774              		.loc 1 1066 0
 2775 0084 0222     		mov	r2, #2
 2776              	.LVL257:
 2777 0086 08E0     		b	.L479
 2778              	.L532:
 2779              	.LVL258:
 2780 0088 8C79     		ldrb	r4, [r1, #6]
 2781 008a 013B     		sub	r3, r3, #1
 2782 008c 9BB2     		uxth	r3, r3
 2783 008e 2242     		tst	r2, r4
 2784 0090 06D1     		bne	.L478
 2785 0092 013B     		sub	r3, r3, #1
 2786 0094 9BB2     		uxth	r3, r3
1064:../Sources/TFC/TFC_CrystalClock.c ****     for (i = 0 ; i < 10000 ; i++)
 2787              		.loc 1 1064 0
 2788 0096 002B     		cmp	r3, #0
 2789 0098 02D0     		beq	.L478
 2790              	.L479:
1066:../Sources/TFC/TFC_CrystalClock.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 2791              		.loc 1 1066 0
 2792 009a 8D79     		ldrb	r5, [r1, #6]
 2793 009c 2A42     		tst	r2, r5
 2794 009e F3D0     		beq	.L532
 2795              	.L478:
1068:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with err
 2796              		.loc 1 1068 0
 2797 00a0 3549     		ldr	r1, .L537
 2798 00a2 8A79     		ldrb	r2, [r1, #6]
 2799 00a4 9107     		lsl	r1, r2, #30
 2800 00a6 01D4     		bmi	.L477
 2801 00a8 2320     		mov	r0, #35
 2802              	.LVL259:
 2803 00aa B1E7     		b	.L471
 2804              	.LVL260:
 2805              	.L477:
1074:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 2806              		.loc 1 1074 0
 2807 00ac 324D     		ldr	r5, .L537
 2808 00ae 1021     		mov	r1, #16
 2809 00b0 AC79     		ldrb	r4, [r5, #6]
 2810 00b2 2142     		tst	r1, r4
 2811 00b4 11D0     		beq	.L480
 2812 00b6 AA79     		ldrb	r2, [r5, #6]
 2813 00b8 374B     		ldr	r3, .L537+32
 2814 00ba 1142     		tst	r1, r2
 2815 00bc 0DD0     		beq	.L480
 2816 00be 013B     		sub	r3, r3, #1
 2817 00c0 08E0     		b	.L506
 2818              	.L533:
 2819 00c2 AA79     		ldrb	r2, [r5, #6]
 2820 00c4 013B     		sub	r3, r3, #1
 2821 00c6 9BB2     		uxth	r3, r3
 2822 00c8 1142     		tst	r1, r2
 2823 00ca 06D0     		beq	.L480
 2824 00cc 013B     		sub	r3, r3, #1
 2825 00ce 9BB2     		uxth	r3, r3
1072:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 2826              		.loc 1 1072 0
 2827 00d0 002B     		cmp	r3, #0
 2828 00d2 02D0     		beq	.L480
 2829              	.L506:
1074:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 2830              		.loc 1 1074 0
 2831 00d4 AC79     		ldrb	r4, [r5, #6]
 2832 00d6 2142     		tst	r1, r4
 2833 00d8 F3D1     		bne	.L533
 2834              	.L480:
1076:../Sources/TFC/TFC_CrystalClock.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
 2835              		.loc 1 1076 0
 2836 00da 274D     		ldr	r5, .L537
 2837 00dc A979     		ldrb	r1, [r5, #6]
 2838 00de CC06     		lsl	r4, r1, #27
 2839 00e0 22D5     		bpl	.L534
 2840 00e2 1120     		mov	r0, #17
 2841              	.LVL261:
 2842 00e4 94E7     		b	.L471
 2843              	.LVL262:
 2844              	.L473:
1034:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 8000000)
 2845              		.loc 1 1034 0
 2846 00e6 2D4D     		ldr	r5, .L537+36
 2847 00e8 A842     		cmp	r0, r5
 2848 00ea 37DC     		bgt	.L475
1036:../Sources/TFC/TFC_CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 2849              		.loc 1 1036 0
 2850 00ec 1025     		mov	r5, #16
 2851 00ee 2C43     		orr	r4, r5
 2852              	.LVL263:
 2853 00f0 9500     		lsl	r5, r2, #2
 2854 00f2 2C43     		orr	r4, r5
 2855 00f4 E4B2     		uxtb	r4, r4
 2856 00f6 C900     		lsl	r1, r1, #3
1046:../Sources/TFC/TFC_CrystalClock.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 2857              		.loc 1 1046 0
 2858 00f8 294D     		ldr	r5, .L537+40
1036:../Sources/TFC/TFC_CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 2859              		.loc 1 1036 0
 2860 00fa 2143     		orr	r1, r4
 2861              	.LVL264:
1042:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C2 = temp_reg;
 2862              		.loc 1 1042 0
 2863 00fc 5970     		strb	r1, [r3, #1]
1046:../Sources/TFC/TFC_CrystalClock.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 2864              		.loc 1 1046 0
 2865 00fe 0023     		mov	r3, #0
 2866 0100 A842     		cmp	r0, r5
 2867 0102 B3DD     		ble	.L474
 2868              	.LVL265:
 2869              	.L476:
1047:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
 2870              		.loc 1 1047 0
 2871 0104 274C     		ldr	r4, .L537+44
 2872 0106 0123     		mov	r3, #1
 2873 0108 A042     		cmp	r0, r4
 2874 010a AFDD     		ble	.L474
1048:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
 2875              		.loc 1 1048 0
 2876 010c 2649     		ldr	r1, .L537+48
 2877 010e 0223     		mov	r3, #2
 2878 0110 8842     		cmp	r0, r1
 2879 0112 ABDD     		ble	.L474
1049:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
 2880              		.loc 1 1049 0
 2881 0114 254D     		ldr	r5, .L537+52
 2882 0116 0323     		mov	r3, #3
 2883 0118 A842     		cmp	r0, r5
 2884 011a A7DD     		ble	.L474
1050:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
 2885              		.loc 1 1050 0
 2886 011c 244C     		ldr	r4, .L537+56
1051:../Sources/TFC/TFC_CrystalClock.c ****   else {frdiv_val = 5;}
 2887              		.loc 1 1051 0
 2888 011e 0523     		mov	r3, #5
1050:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
 2889              		.loc 1 1050 0
 2890 0120 A042     		cmp	r0, r4
 2891 0122 A3DC     		bgt	.L474
 2892 0124 0423     		mov	r3, #4
 2893 0126 A1E7     		b	.L474
 2894              	.LVL266:
 2895              	.L534:
1076:../Sources/TFC/TFC_CrystalClock.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
 2896              		.loc 1 1076 0
 2897 0128 FA24     		mov	r4, #250
 2898 012a E100     		lsl	r1, r4, #3
1081:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 2899              		.loc 1 1081 0
 2900 012c 0C22     		mov	r2, #12
 2901 012e 09E0     		b	.L482
 2902              	.L535:
 2903 0130 AC79     		ldrb	r4, [r5, #6]
 2904 0132 0139     		sub	r1, r1, #1
 2905 0134 89B2     		uxth	r1, r1
 2906 0136 1440     		and	r4, r2
 2907 0138 082C     		cmp	r4, #8
 2908 013a 07D0     		beq	.L481
 2909 013c 0139     		sub	r1, r1, #1
 2910 013e 89B2     		uxth	r1, r1
1079:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 2911              		.loc 1 1079 0
 2912 0140 0029     		cmp	r1, #0
 2913 0142 03D0     		beq	.L481
 2914              	.L482:
1081:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 2915              		.loc 1 1081 0
 2916 0144 AB79     		ldrb	r3, [r5, #6]
 2917 0146 1340     		and	r3, r2
 2918 0148 082B     		cmp	r3, #8
 2919 014a F1D1     		bne	.L535
 2920              	.L481:
1083:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
 2921              		.loc 1 1083 0
 2922 014c 0A4D     		ldr	r5, .L537
 2923 014e AA79     		ldrb	r2, [r5, #6]
 2924 0150 1307     		lsl	r3, r2, #28
 2925 0152 9C0F     		lsr	r4, r3, #30
 2926 0154 022C     		cmp	r4, #2
 2927 0156 0AD0     		beq	.L536
 2928 0158 1A20     		mov	r0, #26
 2929              	.LVL267:
 2930 015a 59E7     		b	.L471
 2931              	.LVL268:
 2932              	.L475:
1040:../Sources/TFC/TFC_CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 2933              		.loc 1 1040 0
 2934 015c 2025     		mov	r5, #32
 2935 015e 2C43     		orr	r4, r5
 2936              	.LVL269:
 2937 0160 9500     		lsl	r5, r2, #2
 2938 0162 2C43     		orr	r4, r5
 2939 0164 E4B2     		uxtb	r4, r4
 2940 0166 C900     		lsl	r1, r1, #3
 2941 0168 2143     		orr	r1, r4
 2942              	.LVL270:
1042:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C2 = temp_reg;
 2943              		.loc 1 1042 0
 2944 016a 5970     		strb	r1, [r3, #1]
 2945 016c CAE7     		b	.L476
 2946              	.LVL271:
 2947              	.L536:
1088:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 |= MCG_C6_CME0_MASK;
 2948              		.loc 1 1088 0
 2949 016e 6A79     		ldrb	r2, [r5, #5]
 2950 0170 2021     		mov	r1, #32
 2951 0172 0A43     		orr	r2, r1
 2952 0174 6A71     		strb	r2, [r5, #5]
1090:../Sources/TFC/TFC_CrystalClock.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency  
 2953              		.loc 1 1090 0
 2954 0176 4BE7     		b	.L471
 2955              	.L538:
 2956              		.align	2
 2957              	.L537:
 2958 0178 00400640 		.word	1074151424
 2959 017c 80F0FA02 		.word	50000000
 2960 0180 2F750000 		.word	29999
 2961 0184 BF63FFFF 		.word	-40001
 2962 0188 7E2A2D00 		.word	2959998
 2963 018c 0048E801 		.word	32000000
 2964 0190 409C0000 		.word	40000
 2965 0194 10270000 		.word	10000
 2966 0198 CF070000 		.word	1999
 2967 019c 00127A00 		.word	8000000
 2968 01a0 D0121300 		.word	1250000
 2969 01a4 A0252600 		.word	2500000
 2970 01a8 404B4C00 		.word	5000000
 2971 01ac 80969800 		.word	10000000
 2972 01b0 002D3101 		.word	20000000
 2973              		.cfi_endproc
 2974              	.LFE15:
 2976              		.section	.text.fbi_blpi,"ax",%progbits
 2977              		.align	2
 2978              		.global	fbi_blpi
 2979              		.code	16
 2980              		.thumb_func
 2982              	fbi_blpi:
 2983              	.LFB16:
1110:../Sources/TFC/TFC_CrystalClock.c **** {
 2984              		.loc 1 1110 0
 2985              		.cfi_startproc
 2986              	.LVL272:
 2987 0000 38B5     		push	{r3, r4, r5, lr}
 2988              	.LCFI20:
 2989              		.cfi_def_cfa_offset 16
 2990              		.cfi_offset 3, -16
 2991              		.cfi_offset 4, -12
 2992              		.cfi_offset 5, -8
 2993              		.cfi_offset 14, -4
1114:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 2994              		.loc 1 1114 0
 2995 0002 104B     		ldr	r3, .L549
 2996 0004 9A79     		ldrb	r2, [r3, #6]
 2997 0006 1407     		lsl	r4, r2, #28
 2998 0008 A20F     		lsr	r2, r4, #30
 2999 000a 012A     		cmp	r2, #1
 3000 000c 01D0     		beq	.L548
 3001              	.L544:
1119:../Sources/TFC/TFC_CrystalClock.c ****     return 0x3;                                                       // MCG not in correct mode re
 3002              		.loc 1 1119 0
 3003 000e 0320     		mov	r0, #3
 3004              	.LVL273:
 3005              	.L540:
1135:../Sources/TFC/TFC_CrystalClock.c **** } // fbi_blpi
 3006              		.loc 1 1135 0
 3007              		@ sp needed for prologue
 3008 0010 38BD     		pop	{r3, r4, r5, pc}
 3009              	.LVL274:
 3010              	.L548:
1115:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 3011              		.loc 1 1115 0
 3012 0012 9D79     		ldrb	r5, [r3, #6]
1114:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 3013              		.loc 1 1114 0
 3014 0014 ED06     		lsl	r5, r5, #27
 3015 0016 FAD5     		bpl	.L544
1116:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 3016              		.loc 1 1116 0
 3017 0018 9C79     		ldrb	r4, [r3, #6]
1115:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 3018              		.loc 1 1115 0
 3019 001a A506     		lsl	r5, r4, #26
 3020 001c F7D4     		bmi	.L544
1117:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
 3021              		.loc 1 1117 0
 3022 001e 5D78     		ldrb	r5, [r3, #1]
1114:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 3023              		.loc 1 1114 0
 3024 0020 AD07     		lsl	r5, r5, #30
 3025 0022 F4D4     		bmi	.L544
1123:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C2 |= MCG_C2_LP_MASK;
 3026              		.loc 1 1123 0
 3027 0024 5D78     		ldrb	r5, [r3, #1]
 3028 0026 0224     		mov	r4, #2
 3029 0028 2C43     		orr	r4, r5
 3030 002a E5B2     		uxtb	r5, r4
 3031 002c 5D70     		strb	r5, [r3, #1]
1126:../Sources/TFC/TFC_CrystalClock.c ****   if (irc_select)
 3032              		.loc 1 1126 0
 3033 002e 0029     		cmp	r1, #0
 3034 0030 EED0     		beq	.L540
1128:../Sources/TFC/TFC_CrystalClock.c ****     fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fa
 3035              		.loc 1 1128 0
 3036 0032 197A     		ldrb	r1, [r3, #8]
 3037              	.LVL275:
 3038 0034 0B07     		lsl	r3, r1, #28
 3039 0036 5C0F     		lsr	r4, r3, #29
 3040 0038 A240     		lsl	r2, r2, r4
1129:../Sources/TFC/TFC_CrystalClock.c ****     return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
 3041              		.loc 1 1129 0
 3042 003a FF21     		mov	r1, #255
 3043              	.LVL276:
 3044 003c 1140     		and	r1, r2
 3045 003e FFF7FEFF 		bl	__aeabi_idiv
 3046              	.LVL277:
 3047 0042 E5E7     		b	.L540
 3048              	.L550:
 3049              		.align	2
 3050              	.L549:
 3051 0044 00400640 		.word	1074151424
 3052              		.cfi_endproc
 3053              	.LFE16:
 3055              		.section	.text.blpi_fbi,"ax",%progbits
 3056              		.align	2
 3057              		.global	blpi_fbi
 3058              		.code	16
 3059              		.thumb_func
 3061              	blpi_fbi:
 3062              	.LFB17:
1155:../Sources/TFC/TFC_CrystalClock.c **** {
 3063              		.loc 1 1155 0
 3064              		.cfi_startproc
 3065              	.LVL278:
 3066 0000 38B5     		push	{r3, r4, r5, lr}
 3067              	.LCFI21:
 3068              		.cfi_def_cfa_offset 16
 3069              		.cfi_offset 3, -16
 3070              		.cfi_offset 4, -12
 3071              		.cfi_offset 5, -8
 3072              		.cfi_offset 14, -4
1158:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 3073              		.loc 1 1158 0
 3074 0002 104B     		ldr	r3, .L561
 3075 0004 9A79     		ldrb	r2, [r3, #6]
 3076 0006 1407     		lsl	r4, r2, #28
 3077 0008 A20F     		lsr	r2, r4, #30
 3078 000a 012A     		cmp	r2, #1
 3079 000c 01D0     		beq	.L560
 3080              	.L556:
1163:../Sources/TFC/TFC_CrystalClock.c ****     return 0x5;                                                       // MCG not in correct mode re
 3081              		.loc 1 1163 0
 3082 000e 0520     		mov	r0, #5
 3083              	.LVL279:
 3084              	.L552:
1179:../Sources/TFC/TFC_CrystalClock.c **** } // blpi_fbi
 3085              		.loc 1 1179 0
 3086              		@ sp needed for prologue
 3087 0010 38BD     		pop	{r3, r4, r5, pc}
 3088              	.LVL280:
 3089              	.L560:
1159:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 3090              		.loc 1 1159 0
 3091 0012 9D79     		ldrb	r5, [r3, #6]
1158:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 3092              		.loc 1 1158 0
 3093 0014 ED06     		lsl	r5, r5, #27
 3094 0016 FAD5     		bpl	.L556
1160:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 3095              		.loc 1 1160 0
 3096 0018 9C79     		ldrb	r4, [r3, #6]
1159:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 3097              		.loc 1 1159 0
 3098 001a A506     		lsl	r5, r4, #26
 3099 001c F7D4     		bmi	.L556
1161:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_C2 & MCG_C2_LP_MASK)))                                     // check LP bit is set
 3100              		.loc 1 1161 0
 3101 001e 5D78     		ldrb	r5, [r3, #1]
 3102 0020 0224     		mov	r4, #2
1158:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 3103              		.loc 1 1158 0
 3104 0022 2C42     		tst	r4, r5
 3105 0024 F3D0     		beq	.L556
1167:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C2 &= ~MCG_C2_LP_MASK;
 3106              		.loc 1 1167 0
 3107 0026 5D78     		ldrb	r5, [r3, #1]
 3108 0028 A543     		bic	r5, r4
 3109 002a 5D70     		strb	r5, [r3, #1]
1170:../Sources/TFC/TFC_CrystalClock.c ****   if (irc_select)
 3110              		.loc 1 1170 0
 3111 002c 0029     		cmp	r1, #0
 3112 002e EFD0     		beq	.L552
1172:../Sources/TFC/TFC_CrystalClock.c ****     fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fa
 3113              		.loc 1 1172 0
 3114 0030 197A     		ldrb	r1, [r3, #8]
 3115              	.LVL281:
 3116 0032 0B07     		lsl	r3, r1, #28
 3117 0034 5D0F     		lsr	r5, r3, #29
 3118 0036 AA40     		lsl	r2, r2, r5
1173:../Sources/TFC/TFC_CrystalClock.c ****     return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
 3119              		.loc 1 1173 0
 3120 0038 FF21     		mov	r1, #255
 3121              	.LVL282:
 3122 003a 1140     		and	r1, r2
 3123 003c FFF7FEFF 		bl	__aeabi_idiv
 3124              	.LVL283:
 3125 0040 E6E7     		b	.L552
 3126              	.L562:
 3127 0042 C046     		.align	2
 3128              	.L561:
 3129 0044 00400640 		.word	1074151424
 3130              		.cfi_endproc
 3131              	.LFE17:
 3133              		.section	.text.fee_fbi,"ax",%progbits
 3134              		.align	2
 3135              		.global	fee_fbi
 3136              		.code	16
 3137              		.thumb_func
 3139              	fee_fbi:
 3140              	.LFB19:
1299:../Sources/TFC/TFC_CrystalClock.c **** { 
 3141              		.loc 1 1299 0
 3142              		.cfi_startproc
 3143              	.LVL284:
 3144 0000 38B5     		push	{r3, r4, r5, lr}
 3145              	.LCFI22:
 3146              		.cfi_def_cfa_offset 16
 3147              		.cfi_offset 3, -16
 3148              		.cfi_offset 4, -12
 3149              		.cfi_offset 5, -8
 3150              		.cfi_offset 14, -4
1304:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3151              		.loc 1 1304 0
 3152 0002 4E4B     		ldr	r3, .L618
 3153 0004 9A79     		ldrb	r2, [r3, #6]
 3154 0006 1407     		lsl	r4, r2, #28
 3155 0008 A50F     		lsr	r5, r4, #30
 3156 000a 01D0     		beq	.L609
 3157              	.L578:
1308:../Sources/TFC/TFC_CrystalClock.c ****     return 0x2;                                                     // return error code
 3158              		.loc 1 1308 0
 3159 000c 0220     		mov	r0, #2
 3160              	.LVL285:
 3161              	.L564:
1379:../Sources/TFC/TFC_CrystalClock.c **** } // fee_fbi 
 3162              		.loc 1 1379 0
 3163              		@ sp needed for prologue
 3164 000e 38BD     		pop	{r3, r4, r5, pc}
 3165              	.LVL286:
 3166              	.L609:
1305:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                             // check FLL ref is external re
 3167              		.loc 1 1305 0
 3168 0010 9A79     		ldrb	r2, [r3, #6]
1304:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3169              		.loc 1 1304 0
 3170 0012 D406     		lsl	r4, r2, #27
 3171 0014 FAD4     		bmi	.L578
1306:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                               // check PLLS mux has selected 
 3172              		.loc 1 1306 0
 3173 0016 9C79     		ldrb	r4, [r3, #6]
 3174 0018 2022     		mov	r2, #32
1304:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3175              		.loc 1 1304 0
 3176 001a 2242     		tst	r2, r4
 3177 001c F6D1     		bne	.L578
1312:../Sources/TFC/TFC_CrystalClock.c ****   if (!(irc_select))
 3178              		.loc 1 1312 0
 3179 001e 0029     		cmp	r1, #0
 3180 0020 06D1     		bne	.L565
1314:../Sources/TFC/TFC_CrystalClock.c ****     if ((irc_freq < 31250) || (irc_freq > 39063)) {return 0x31;}
 3181              		.loc 1 1314 0
 3182 0022 474D     		ldr	r5, .L618+4
 3183 0024 474C     		ldr	r4, .L618+8
 3184 0026 4519     		add	r5, r0, r5
 3185 0028 A542     		cmp	r5, r4
 3186 002a 08D9     		bls	.L610
 3187 002c 3120     		mov	r0, #49
 3188              	.LVL287:
 3189 002e EEE7     		b	.L564
 3190              	.LVL288:
 3191              	.L565:
1318:../Sources/TFC/TFC_CrystalClock.c ****     if ((irc_freq < 3000000) || (irc_freq > 5000000)) {return 0x32;} // Fast IRC freq
 3192              		.loc 1 1318 0
 3193 0030 454D     		ldr	r5, .L618+12
 3194 0032 464C     		ldr	r4, .L618+16
 3195 0034 4519     		add	r5, r0, r5
 3196 0036 A542     		cmp	r5, r4
 3197 0038 22D9     		bls	.L611
 3198 003a 3220     		mov	r0, #50
 3199              	.LVL289:
 3200 003c E7E7     		b	.L564
 3201              	.LVL290:
 3202              	.L610:
1328:../Sources/TFC/TFC_CrystalClock.c ****     MCG_C2 &= ~MCG_C2_IRCS_MASK; // select slow IRC by clearing IRCS
 3203              		.loc 1 1328 0
 3204 003e 5C78     		ldrb	r4, [r3, #1]
 3205 0040 0125     		mov	r5, #1
 3206 0042 AC43     		bic	r4, r5
 3207 0044 5C70     		strb	r4, [r3, #1]
1332:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 &= ~MCG_C6_CME0_MASK;
 3208              		.loc 1 1332 0
 3209 0046 5C79     		ldrb	r4, [r3, #5]
 3210 0048 9443     		bic	r4, r2
 3211 004a 5C71     		strb	r4, [r3, #5]
1335:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 |= MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK; // set IREFS and select IRC as MCGOUT
 3212              		.loc 1 1335 0
 3213 004c 1D78     		ldrb	r5, [r3]
 3214 004e 4424     		mov	r4, #68
 3215 0050 2C43     		orr	r4, r5
 3216 0052 FA22     		mov	r2, #250
 3217 0054 1C70     		strb	r4, [r3]
 3218              	.LVL291:
 3219 0056 D200     		lsl	r2, r2, #3
1342:../Sources/TFC/TFC_CrystalClock.c ****       if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishe
 3220              		.loc 1 1342 0
 3221 0058 0124     		mov	r4, #1
 3222 005a 08E0     		b	.L569
 3223              	.LVL292:
 3224              	.L612:
 3225 005c 9D79     		ldrb	r5, [r3, #6]
 3226 005e 013A     		sub	r2, r2, #1
 3227 0060 92B2     		uxth	r2, r2
 3228 0062 2C42     		tst	r4, r5
 3229 0064 06D0     		beq	.L568
 3230 0066 013A     		sub	r2, r2, #1
 3231 0068 92B2     		uxth	r2, r2
1340:../Sources/TFC/TFC_CrystalClock.c ****     for (i = 0 ; i < 2000 ; i++)
 3232              		.loc 1 1340 0
 3233 006a 002A     		cmp	r2, #0
 3234 006c 02D0     		beq	.L568
 3235              	.L569:
1342:../Sources/TFC/TFC_CrystalClock.c ****       if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishe
 3236              		.loc 1 1342 0
 3237 006e 9D79     		ldrb	r5, [r3, #6]
 3238 0070 2C42     		tst	r4, r5
 3239 0072 F3D1     		bne	.L612
 3240              	.L568:
1344:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_IRCST_MASK) return 0x13; // check bit is really clear and return with error i
 3241              		.loc 1 1344 0
 3242 0074 314B     		ldr	r3, .L618
 3243 0076 9C79     		ldrb	r4, [r3, #6]
 3244 0078 E207     		lsl	r2, r4, #31
 3245 007a 22D5     		bpl	.L572
 3246 007c 1320     		mov	r0, #19
 3247              	.LVL293:
 3248 007e C6E7     		b	.L564
 3249              	.LVL294:
 3250              	.L611:
1324:../Sources/TFC/TFC_CrystalClock.c ****     MCG_C2 |= MCG_C2_IRCS_MASK; // select fast IRC by setting IRCS
 3251              		.loc 1 1324 0
 3252 0080 5D78     		ldrb	r5, [r3, #1]
 3253 0082 0124     		mov	r4, #1
 3254 0084 2C43     		orr	r4, r5
 3255 0086 5C70     		strb	r4, [r3, #1]
1332:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 &= ~MCG_C6_CME0_MASK;
 3256              		.loc 1 1332 0
 3257 0088 5D79     		ldrb	r5, [r3, #5]
 3258 008a 9543     		bic	r5, r2
 3259 008c 5D71     		strb	r5, [r3, #5]
1335:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 |= MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK; // set IREFS and select IRC as MCGOUT
 3260              		.loc 1 1335 0
 3261 008e 1C78     		ldrb	r4, [r3]
 3262 0090 4425     		mov	r5, #68
 3263 0092 2543     		orr	r5, r4
 3264 0094 FA22     		mov	r2, #250
 3265 0096 1D70     		strb	r5, [r3]
 3266              	.LVL295:
 3267 0098 D200     		lsl	r2, r2, #3
1350:../Sources/TFC/TFC_CrystalClock.c ****       if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
 3268              		.loc 1 1350 0
 3269 009a 0124     		mov	r4, #1
 3270 009c 08E0     		b	.L567
 3271              	.LVL296:
 3272              	.L613:
 3273 009e 9D79     		ldrb	r5, [r3, #6]
 3274 00a0 013A     		sub	r2, r2, #1
 3275 00a2 92B2     		uxth	r2, r2
 3276 00a4 2C42     		tst	r4, r5
 3277 00a6 06D1     		bne	.L571
 3278 00a8 013A     		sub	r2, r2, #1
 3279 00aa 92B2     		uxth	r2, r2
1348:../Sources/TFC/TFC_CrystalClock.c ****     for (i = 0 ; i < 2000 ; i++)
 3280              		.loc 1 1348 0
 3281 00ac 002A     		cmp	r2, #0
 3282 00ae 02D0     		beq	.L571
 3283              	.L567:
1350:../Sources/TFC/TFC_CrystalClock.c ****       if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
 3284              		.loc 1 1350 0
 3285 00b0 9D79     		ldrb	r5, [r3, #6]
 3286 00b2 2C42     		tst	r4, r5
 3287 00b4 F3D0     		beq	.L613
 3288              	.L571:
1352:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_IRCST_MASK)) return 0x14; // check bit is really set and return with error 
 3289              		.loc 1 1352 0
 3290 00b6 214B     		ldr	r3, .L618
 3291 00b8 9C79     		ldrb	r4, [r3, #6]
 3292 00ba E407     		lsl	r4, r4, #31
 3293 00bc 01D4     		bmi	.L572
 3294 00be 1420     		mov	r0, #20
 3295              	.LVL297:
 3296 00c0 A5E7     		b	.L564
 3297              	.LVL298:
 3298              	.L572:
1335:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 |= MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK; // set IREFS and select IRC as MCGOUT
 3299              		.loc 1 1335 0
 3300 00c2 FA25     		mov	r5, #250
 3301 00c4 EB00     		lsl	r3, r5, #3
1358:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST
 3302              		.loc 1 1358 0
 3303 00c6 1D4C     		ldr	r4, .L618
 3304 00c8 0C22     		mov	r2, #12
 3305 00ca 09E0     		b	.L570
 3306              	.LVL299:
 3307              	.L614:
 3308 00cc A579     		ldrb	r5, [r4, #6]
 3309 00ce 013B     		sub	r3, r3, #1
 3310 00d0 9BB2     		uxth	r3, r3
 3311 00d2 1540     		and	r5, r2
 3312 00d4 042D     		cmp	r5, #4
 3313 00d6 07D0     		beq	.L573
 3314 00d8 013B     		sub	r3, r3, #1
 3315 00da 9BB2     		uxth	r3, r3
1356:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 3316              		.loc 1 1356 0
 3317 00dc 002B     		cmp	r3, #0
 3318 00de 03D0     		beq	.L573
 3319              	.L570:
1358:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST
 3320              		.loc 1 1358 0
 3321 00e0 A579     		ldrb	r5, [r4, #6]
 3322 00e2 1540     		and	r5, r2
 3323 00e4 042D     		cmp	r5, #4
 3324 00e6 F1D1     		bne	.L614
 3325              	.L573:
1360:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19; // check IRC is really
 3326              		.loc 1 1360 0
 3327 00e8 144C     		ldr	r4, .L618
 3328 00ea A279     		ldrb	r2, [r4, #6]
 3329 00ec 1507     		lsl	r5, r2, #28
 3330 00ee AB0F     		lsr	r3, r5, #30
 3331 00f0 012B     		cmp	r3, #1
 3332 00f2 01D0     		beq	.L615
 3333 00f4 1920     		mov	r0, #25
 3334              	.LVL300:
 3335 00f6 8AE7     		b	.L564
 3336              	.LVL301:
 3337              	.L615:
 3338 00f8 FA22     		mov	r2, #250
 3339 00fa D300     		lsl	r3, r2, #3
1365:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
 3340              		.loc 1 1365 0
 3341 00fc 1022     		mov	r2, #16
 3342 00fe 08E0     		b	.L575
 3343              	.L616:
 3344 0100 A579     		ldrb	r5, [r4, #6]
 3345 0102 013B     		sub	r3, r3, #1
 3346 0104 9BB2     		uxth	r3, r3
 3347 0106 2A42     		tst	r2, r5
 3348 0108 06D1     		bne	.L574
 3349 010a 013B     		sub	r3, r3, #1
 3350 010c 9BB2     		uxth	r3, r3
1363:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 3351              		.loc 1 1363 0
 3352 010e 002B     		cmp	r3, #0
 3353 0110 02D0     		beq	.L574
 3354              	.L575:
1365:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
 3355              		.loc 1 1365 0
 3356 0112 A579     		ldrb	r5, [r4, #6]
 3357 0114 2A42     		tst	r2, r5
 3358 0116 F3D0     		beq	.L616
 3359              	.L574:
1367:../Sources/TFC/TFC_CrystalClock.c ****   if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error i
 3360              		.loc 1 1367 0
 3361 0118 084D     		ldr	r5, .L618
 3362 011a AC79     		ldrb	r4, [r5, #6]
 3363 011c E406     		lsl	r4, r4, #27
 3364 011e 01D4     		bmi	.L617
 3365 0120 1220     		mov	r0, #18
 3366              	.LVL302:
 3367 0122 74E7     		b	.L564
 3368              	.LVL303:
 3369              	.L617:
1370:../Sources/TFC/TFC_CrystalClock.c ****   if (irc_select)
 3370              		.loc 1 1370 0
 3371 0124 0029     		cmp	r1, #0
 3372 0126 00D1     		bne	.LCB4182
 3373 0128 71E7     		b	.L564	@long jump
 3374              	.LCB4182:
1372:../Sources/TFC/TFC_CrystalClock.c ****     fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fa
 3375              		.loc 1 1372 0
 3376 012a 297A     		ldrb	r1, [r5, #8]
 3377              	.LVL304:
 3378 012c 0125     		mov	r5, #1
 3379 012e 0A07     		lsl	r2, r1, #28
 3380 0130 530F     		lsr	r3, r2, #29
 3381 0132 9D40     		lsl	r5, r5, r3
1373:../Sources/TFC/TFC_CrystalClock.c ****     return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
 3382              		.loc 1 1373 0
 3383 0134 E9B2     		uxtb	r1, r5
 3384              	.LVL305:
 3385 0136 FFF7FEFF 		bl	__aeabi_idiv
 3386              	.LVL306:
 3387 013a 68E7     		b	.L564
 3388              	.L619:
 3389              		.align	2
 3390              	.L618:
 3391 013c 00400640 		.word	1074151424
 3392 0140 EE85FFFF 		.word	-31250
 3393 0144 851E0000 		.word	7813
 3394 0148 4039D2FF 		.word	-3000000
 3395 014c 80841E00 		.word	2000000
 3396              		.cfi_endproc
 3397              	.LFE19:
 3399              		.section	.text.fei_fbi,"ax",%progbits
 3400              		.align	2
 3401              		.global	fei_fbi
 3402              		.code	16
 3403              		.thumb_func
 3405              	fei_fbi:
 3406              	.LFB21:
1434:../Sources/TFC/TFC_CrystalClock.c **** {
 3407              		.loc 1 1434 0
 3408              		.cfi_startproc
 3409              	.LVL307:
 3410 0000 38B5     		push	{r3, r4, r5, lr}
 3411              	.LCFI23:
 3412              		.cfi_def_cfa_offset 16
 3413              		.cfi_offset 3, -16
 3414              		.cfi_offset 4, -12
 3415              		.cfi_offset 5, -8
 3416              		.cfi_offset 14, -4
1440:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3417              		.loc 1 1440 0
 3418 0002 414B     		ldr	r3, .L666
 3419 0004 9A79     		ldrb	r2, [r3, #6]
 3420 0006 1407     		lsl	r4, r2, #28
 3421 0008 A50F     		lsr	r5, r4, #30
 3422 000a 0ED1     		bne	.L633
1441:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 3423              		.loc 1 1441 0
 3424 000c 9A79     		ldrb	r2, [r3, #6]
1440:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3425              		.loc 1 1440 0
 3426 000e D406     		lsl	r4, r2, #27
 3427 0010 0BD5     		bpl	.L633
1442:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selecte
 3428              		.loc 1 1442 0
 3429 0012 9C79     		ldrb	r4, [r3, #6]
1440:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3430              		.loc 1 1440 0
 3431 0014 A406     		lsl	r4, r4, #26
 3432 0016 08D4     		bmi	.L633
1448:../Sources/TFC/TFC_CrystalClock.c ****   if (!(irc_select))
 3433              		.loc 1 1448 0
 3434 0018 0029     		cmp	r1, #0
 3435 001a 08D1     		bne	.L622
1450:../Sources/TFC/TFC_CrystalClock.c ****     if ((irc_freq < 31250) || (irc_freq > 39063)) {return 0x31;}
 3436              		.loc 1 1450 0
 3437 001c 3B4D     		ldr	r5, .L666+4
 3438 001e 3C4A     		ldr	r2, .L666+8
 3439 0020 4419     		add	r4, r0, r5
 3440 0022 9442     		cmp	r4, r2
 3441 0024 2AD9     		bls	.L660
 3442 0026 3120     		mov	r0, #49
 3443              	.LVL308:
 3444 0028 00E0     		b	.L621
 3445              	.LVL309:
 3446              	.L633:
1444:../Sources/TFC/TFC_CrystalClock.c ****     return 0x1;                                                       // return error code
 3447              		.loc 1 1444 0
 3448 002a 0120     		mov	r0, #1
 3449              	.LVL310:
 3450              	.L621:
1508:../Sources/TFC/TFC_CrystalClock.c **** } // fei_fbi
 3451              		.loc 1 1508 0
 3452              		@ sp needed for prologue
 3453 002c 38BD     		pop	{r3, r4, r5, pc}
 3454              	.LVL311:
 3455              	.L622:
1454:../Sources/TFC/TFC_CrystalClock.c ****     if ((irc_freq < 3000000) || (irc_freq > 5000000)) {return 0x32;} // Fast IRC freq
 3456              		.loc 1 1454 0
 3457 002e 394D     		ldr	r5, .L666+12
 3458 0030 394A     		ldr	r2, .L666+16
 3459 0032 4419     		add	r4, r0, r5
 3460 0034 9442     		cmp	r4, r2
 3461 0036 01D9     		bls	.L661
 3462 0038 3220     		mov	r0, #50
 3463              	.LVL312:
 3464 003a F7E7     		b	.L621
 3465              	.LVL313:
 3466              	.L661:
1460:../Sources/TFC/TFC_CrystalClock.c ****     MCG_C2 |= MCG_C2_IRCS_MASK; // select fast IRCS
 3467              		.loc 1 1460 0
 3468 003c 5D78     		ldrb	r5, [r3, #1]
 3469 003e 0124     		mov	r4, #1
 3470 0040 2C43     		orr	r4, r5
 3471 0042 5C70     		strb	r4, [r3, #1]
1468:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C1;
 3472              		.loc 1 1468 0
 3473 0044 1A78     		ldrb	r2, [r3]
 3474              	.LVL314:
1469:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS
 3475              		.loc 1 1469 0
 3476 0046 3F25     		mov	r5, #63
1470:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= MCG_C1_CLKS(1); // select IRC as the MCG clock sourse
 3477              		.loc 1 1470 0
 3478 0048 4024     		mov	r4, #64
1469:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS
 3479              		.loc 1 1469 0
 3480 004a 2A40     		and	r2, r5
 3481              	.LVL315:
1470:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= MCG_C1_CLKS(1); // select IRC as the MCG clock sourse
 3482              		.loc 1 1470 0
 3483 004c 2243     		orr	r2, r4
 3484              	.LVL316:
1471:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 = temp_reg;
 3485              		.loc 1 1471 0
 3486 004e 1A70     		strb	r2, [r3]
 3487              	.LVL317:
 3488 0050 FA22     		mov	r2, #250
 3489              	.LVL318:
 3490 0052 D200     		lsl	r2, r2, #3
1486:../Sources/TFC/TFC_CrystalClock.c ****       if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
 3491              		.loc 1 1486 0
 3492 0054 0124     		mov	r4, #1
 3493 0056 08E0     		b	.L624
 3494              	.LVL319:
 3495              	.L662:
 3496 0058 9D79     		ldrb	r5, [r3, #6]
 3497 005a 013A     		sub	r2, r2, #1
 3498 005c 92B2     		uxth	r2, r2
 3499 005e 2C42     		tst	r4, r5
 3500 0060 06D1     		bne	.L628
 3501 0062 013A     		sub	r2, r2, #1
 3502 0064 92B2     		uxth	r2, r2
1484:../Sources/TFC/TFC_CrystalClock.c ****     for (i = 0 ; i < 2000 ; i++)
 3503              		.loc 1 1484 0
 3504 0066 002A     		cmp	r2, #0
 3505 0068 02D0     		beq	.L628
 3506              	.L624:
1486:../Sources/TFC/TFC_CrystalClock.c ****       if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
 3507              		.loc 1 1486 0
 3508 006a 9D79     		ldrb	r5, [r3, #6]
 3509 006c 2C42     		tst	r4, r5
 3510 006e F3D0     		beq	.L662
 3511              	.L628:
1488:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_IRCST_MASK)) return 0x14; // check bit is really set and return with error 
 3512              		.loc 1 1488 0
 3513 0070 254B     		ldr	r3, .L666
 3514 0072 9C79     		ldrb	r4, [r3, #6]
 3515 0074 E207     		lsl	r2, r4, #31
 3516 0076 21D4     		bmi	.L629
 3517 0078 1420     		mov	r0, #20
 3518              	.LVL320:
 3519 007a D7E7     		b	.L621
 3520              	.LVL321:
 3521              	.L660:
1464:../Sources/TFC/TFC_CrystalClock.c ****     MCG_C2 &= ~MCG_C2_IRCS_MASK; // select slow IRCS
 3522              		.loc 1 1464 0
 3523 007c 5D78     		ldrb	r5, [r3, #1]
 3524 007e 0124     		mov	r4, #1
 3525 0080 A543     		bic	r5, r4
 3526 0082 5D70     		strb	r5, [r3, #1]
1468:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C1;
 3527              		.loc 1 1468 0
 3528 0084 1A78     		ldrb	r2, [r3]
 3529              	.LVL322:
1469:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS
 3530              		.loc 1 1469 0
 3531 0086 3F25     		mov	r5, #63
1470:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= MCG_C1_CLKS(1); // select IRC as the MCG clock sourse
 3532              		.loc 1 1470 0
 3533 0088 4024     		mov	r4, #64
1469:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS
 3534              		.loc 1 1469 0
 3535 008a 2A40     		and	r2, r5
 3536              	.LVL323:
1470:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= MCG_C1_CLKS(1); // select IRC as the MCG clock sourse
 3537              		.loc 1 1470 0
 3538 008c 2243     		orr	r2, r4
 3539              	.LVL324:
1471:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 = temp_reg;
 3540              		.loc 1 1471 0
 3541 008e 1A70     		strb	r2, [r3]
 3542              	.LVL325:
 3543 0090 FA22     		mov	r2, #250
 3544              	.LVL326:
 3545 0092 D200     		lsl	r2, r2, #3
1478:../Sources/TFC/TFC_CrystalClock.c ****       if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishe
 3546              		.loc 1 1478 0
 3547 0094 0124     		mov	r4, #1
 3548 0096 08E0     		b	.L626
 3549              	.LVL327:
 3550              	.L663:
 3551 0098 9D79     		ldrb	r5, [r3, #6]
 3552 009a 013A     		sub	r2, r2, #1
 3553 009c 92B2     		uxth	r2, r2
 3554 009e 2C42     		tst	r4, r5
 3555 00a0 06D0     		beq	.L625
 3556 00a2 013A     		sub	r2, r2, #1
 3557 00a4 92B2     		uxth	r2, r2
1476:../Sources/TFC/TFC_CrystalClock.c ****     for (i = 0 ; i < 2000 ; i++)
 3558              		.loc 1 1476 0
 3559 00a6 002A     		cmp	r2, #0
 3560 00a8 02D0     		beq	.L625
 3561              	.L626:
1478:../Sources/TFC/TFC_CrystalClock.c ****       if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishe
 3562              		.loc 1 1478 0
 3563 00aa 9D79     		ldrb	r5, [r3, #6]
 3564 00ac 2C42     		tst	r4, r5
 3565 00ae F3D1     		bne	.L663
 3566              	.L625:
1480:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_IRCST_MASK) return 0x13; // check bit is really clear and return with error i
 3567              		.loc 1 1480 0
 3568 00b0 154B     		ldr	r3, .L666
 3569 00b2 9C79     		ldrb	r4, [r3, #6]
 3570 00b4 E407     		lsl	r4, r4, #31
 3571 00b6 01D5     		bpl	.L629
 3572 00b8 1320     		mov	r0, #19
 3573              	.LVL328:
 3574 00ba B7E7     		b	.L621
 3575              	.LVL329:
 3576              	.L629:
1471:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 = temp_reg;
 3577              		.loc 1 1471 0
 3578 00bc FA25     		mov	r5, #250
 3579 00be EB00     		lsl	r3, r5, #3
1494:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST
 3580              		.loc 1 1494 0
 3581 00c0 114C     		ldr	r4, .L666
 3582 00c2 0C22     		mov	r2, #12
 3583 00c4 09E0     		b	.L627
 3584              	.LVL330:
 3585              	.L664:
 3586 00c6 A579     		ldrb	r5, [r4, #6]
 3587 00c8 013B     		sub	r3, r3, #1
 3588 00ca 9BB2     		uxth	r3, r3
 3589 00cc 1540     		and	r5, r2
 3590 00ce 042D     		cmp	r5, #4
 3591 00d0 07D0     		beq	.L630
 3592 00d2 013B     		sub	r3, r3, #1
 3593 00d4 9BB2     		uxth	r3, r3
1492:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 3594              		.loc 1 1492 0
 3595 00d6 002B     		cmp	r3, #0
 3596 00d8 03D0     		beq	.L630
 3597              	.L627:
1494:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST
 3598              		.loc 1 1494 0
 3599 00da A579     		ldrb	r5, [r4, #6]
 3600 00dc 1540     		and	r5, r2
 3601 00de 042D     		cmp	r5, #4
 3602 00e0 F1D1     		bne	.L664
 3603              	.L630:
1496:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19; // check IRC is really
 3604              		.loc 1 1496 0
 3605 00e2 094C     		ldr	r4, .L666
 3606 00e4 A279     		ldrb	r2, [r4, #6]
 3607 00e6 1507     		lsl	r5, r2, #28
 3608 00e8 AB0F     		lsr	r3, r5, #30
 3609 00ea 012B     		cmp	r3, #1
 3610 00ec 01D0     		beq	.L665
 3611 00ee 1920     		mov	r0, #25
 3612              	.LVL331:
 3613 00f0 9CE7     		b	.L621
 3614              	.LVL332:
 3615              	.L665:
1499:../Sources/TFC/TFC_CrystalClock.c ****   if (irc_select)
 3616              		.loc 1 1499 0
 3617 00f2 0029     		cmp	r1, #0
 3618 00f4 9AD0     		beq	.L621
1501:../Sources/TFC/TFC_CrystalClock.c ****     fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fa
 3619              		.loc 1 1501 0
 3620 00f6 217A     		ldrb	r1, [r4, #8]
 3621              	.LVL333:
 3622 00f8 0C07     		lsl	r4, r1, #28
 3623 00fa 620F     		lsr	r2, r4, #29
 3624 00fc 9340     		lsl	r3, r3, r2
1502:../Sources/TFC/TFC_CrystalClock.c ****     return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
 3625              		.loc 1 1502 0
 3626 00fe FF21     		mov	r1, #255
 3627              	.LVL334:
 3628 0100 1940     		and	r1, r3
 3629 0102 FFF7FEFF 		bl	__aeabi_idiv
 3630              	.LVL335:
 3631 0106 91E7     		b	.L621
 3632              	.L667:
 3633              		.align	2
 3634              	.L666:
 3635 0108 00400640 		.word	1074151424
 3636 010c EE85FFFF 		.word	-31250
 3637 0110 851E0000 		.word	7813
 3638 0114 4039D2FF 		.word	-3000000
 3639 0118 80841E00 		.word	2000000
 3640              		.cfi_endproc
 3641              	.LFE21:
 3643              		.section	.text.fei_fee,"ax",%progbits
 3644              		.align	2
 3645              		.global	fei_fee
 3646              		.code	16
 3647              		.thumb_func
 3649              	fei_fee:
 3650              	.LFB22:
1530:../Sources/TFC/TFC_CrystalClock.c **** {
 3651              		.loc 1 1530 0
 3652              		.cfi_startproc
 3653              	.LVL336:
 3654 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 3655              	.LCFI24:
 3656              		.cfi_def_cfa_offset 24
 3657              		.cfi_offset 3, -24
 3658              		.cfi_offset 4, -20
 3659              		.cfi_offset 5, -16
 3660              		.cfi_offset 6, -12
 3661              		.cfi_offset 7, -8
 3662              		.cfi_offset 14, -4
1537:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3663              		.loc 1 1537 0
 3664 0002 5F4B     		ldr	r3, .L727
1530:../Sources/TFC/TFC_CrystalClock.c **** {
 3665              		.loc 1 1530 0
 3666 0004 161C     		mov	r6, r2
1537:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3667              		.loc 1 1537 0
 3668 0006 9D79     		ldrb	r5, [r3, #6]
1541:../Sources/TFC/TFC_CrystalClock.c ****     return 0x1;                                                     // return error code
 3669              		.loc 1 1541 0
 3670 0008 0124     		mov	r4, #1
1537:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3671              		.loc 1 1537 0
 3672 000a 2A07     		lsl	r2, r5, #28
 3673              	.LVL337:
 3674 000c 970F     		lsr	r7, r2, #30
 3675 000e 09D1     		bne	.L669
1538:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 3676              		.loc 1 1538 0
 3677 0010 9D79     		ldrb	r5, [r3, #6]
1537:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3678              		.loc 1 1537 0
 3679 0012 EA06     		lsl	r2, r5, #27
 3680 0014 06D5     		bpl	.L669
1539:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selecte
 3681              		.loc 1 1539 0
 3682 0016 9B79     		ldrb	r3, [r3, #6]
1537:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3683              		.loc 1 1537 0
 3684 0018 9A06     		lsl	r2, r3, #26
 3685 001a 03D4     		bmi	.L669
1545:../Sources/TFC/TFC_CrystalClock.c ****   if  (crystal_val > 50000000) {return 0x21;}
 3686              		.loc 1 1545 0
 3687 001c 594A     		ldr	r2, .L727+4
 3688 001e 2124     		mov	r4, #33
 3689 0020 9042     		cmp	r0, r2
 3690 0022 01DD     		ble	.L721
 3691              	.LVL338:
 3692              	.L669:
1634:../Sources/TFC/TFC_CrystalClock.c **** } // fei_fee
 3693              		.loc 1 1634 0
 3694 0024 201C     		mov	r0, r4
 3695              		@ sp needed for prologue
 3696 0026 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3697              	.LVL339:
 3698              	.L721:
1548:../Sources/TFC/TFC_CrystalClock.c ****   if (erefs_val)
 3699              		.loc 1 1548 0
 3700 0028 002E     		cmp	r6, #0
 3701 002a 3ED1     		bne	.L722
 3702              	.L670:
1558:../Sources/TFC/TFC_CrystalClock.c ****     hgo_val = 1; // force hgo_val to 1 if > 0
 3703              		.loc 1 1558 0
 3704 002c 4B1E     		sub	r3, r1, #1
 3705 002e 9941     		sbc	r1, r1, r3
 3706              	.LVL340:
1564:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C2;
 3707              		.loc 1 1564 0
 3708 0030 534B     		ldr	r3, .L727
1565:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
 3709              		.loc 1 1565 0
 3710 0032 3C24     		mov	r4, #60
1564:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C2;
 3711              		.loc 1 1564 0
 3712 0034 5D78     		ldrb	r5, [r3, #1]
 3713              	.LVL341:
1566:../Sources/TFC/TFC_CrystalClock.c ****   if (crystal_val <= 40000)
 3714              		.loc 1 1566 0
 3715 0036 544A     		ldr	r2, .L727+8
1565:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
 3716              		.loc 1 1565 0
 3717 0038 A543     		bic	r5, r4
 3718              	.LVL342:
 3719 003a 2F1C     		mov	r7, r5
 3720              	.LVL343:
1566:../Sources/TFC/TFC_CrystalClock.c ****   if (crystal_val <= 40000)
 3721              		.loc 1 1566 0
 3722 003c 9042     		cmp	r0, r2
 3723 003e 41DC     		bgt	.L671
1568:../Sources/TFC/TFC_CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 3724              		.loc 1 1568 0
 3725 0040 B200     		lsl	r2, r6, #2
 3726 0042 1743     		orr	r7, r2
 3727 0044 FFB2     		uxtb	r7, r7
 3728 0046 CD00     		lsl	r5, r1, #3
 3729              	.LVL344:
 3730 0048 3D43     		orr	r5, r7
 3731              	.LVL345:
1578:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C2 = temp_reg;
 3732              		.loc 1 1578 0
 3733 004a 5D70     		strb	r5, [r3, #1]
 3734 004c 0027     		mov	r7, #0
 3735 004e 0125     		mov	r5, #1
 3736              	.LVL346:
 3737 0050 2021     		mov	r1, #32
 3738              	.L672:
1590:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
 3739              		.loc 1 1590 0
 3740 0052 4B4B     		ldr	r3, .L727
 3741 0054 5C78     		ldrb	r4, [r3, #1]
 3742 0056 A206     		lsl	r2, r4, #26
 3743 0058 930F     		lsr	r3, r2, #30
 3744 005a 00D1     		bne	.L720
1596:../Sources/TFC/TFC_CrystalClock.c ****     fll_ref_freq = ((crystal_val) / (1 << frdiv_val));
 3745              		.loc 1 1596 0
 3746 005c 291C     		mov	r1, r5
 3747              	.L720:
 3748              	.LBB8:
 3749              	.LBB9:
1795:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) > 0x1) 
 3750              		.loc 1 1795 0
 3751 005e 484D     		ldr	r5, .L727
 3752              	.LBE9:
 3753              	.LBE8:
1596:../Sources/TFC/TFC_CrystalClock.c ****     fll_ref_freq = ((crystal_val) / (1 << frdiv_val));
 3754              		.loc 1 1596 0
 3755 0060 FFF7FEFF 		bl	__aeabi_idiv
 3756              	.LVL347:
 3757              	.LBB11:
 3758              	.LBB10:
1795:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) > 0x1) 
 3759              		.loc 1 1795 0
 3760 0064 E978     		ldrb	r1, [r5, #3]
1797:../Sources/TFC/TFC_CrystalClock.c ****     return 0x3B; // return error code if DRS range 2 or 3 selected
 3761              		.loc 1 1797 0
 3762 0066 3B24     		mov	r4, #59
1795:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) > 0x1) 
 3763              		.loc 1 1795 0
 3764 0068 4906     		lsl	r1, r1, #25
 3765 006a DBD4     		bmi	.L669
 3766 006c FFF7FEFF 		bl	fll_freq.part.0
 3767              	.LVL348:
 3768 0070 041E     		sub	r4, r0, #0
 3769              	.LBE10:
 3770              	.LBE11:
1601:../Sources/TFC/TFC_CrystalClock.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
 3771              		.loc 1 1601 0
 3772 0072 3B2C     		cmp	r4, #59
 3773 0074 D6DD     		ble	.L669
1606:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C1;
 3774              		.loc 1 1606 0
 3775 0076 2878     		ldrb	r0, [r5]
 3776              	.LVL349:
1607:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these
 3777              		.loc 1 1607 0
 3778 0078 0322     		mov	r2, #3
 3779 007a 1040     		and	r0, r2
 3780              	.LVL350:
1608:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= (MCG_C1_CLKS(0) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
 3781              		.loc 1 1608 0
 3782 007c 0743     		orr	r7, r0
 3783              	.LVL351:
1609:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 = temp_reg;
 3784              		.loc 1 1609 0
 3785 007e 2F70     		strb	r7, [r5]
1612:../Sources/TFC/TFC_CrystalClock.c ****   if (erefs_val)
 3786              		.loc 1 1612 0
 3787 0080 002E     		cmp	r6, #0
 3788 0082 3ED0     		beq	.L677
 3789 0084 414E     		ldr	r6, .L727+12
1616:../Sources/TFC/TFC_CrystalClock.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 3790              		.loc 1 1616 0
 3791 0086 2F1C     		mov	r7, r5
 3792              	.LVL352:
 3793 0088 0223     		mov	r3, #2
 3794 008a 05E0     		b	.L679
 3795              	.L723:
 3796              	.LVL353:
 3797 008c B979     		ldrb	r1, [r7, #6]
 3798 008e 0B42     		tst	r3, r1
 3799 0090 05D1     		bne	.L678
 3800 0092 023E     		sub	r6, r6, #2
1614:../Sources/TFC/TFC_CrystalClock.c ****     for (i = 0 ; i < 20000000 ; i++)
 3801              		.loc 1 1614 0
 3802 0094 002E     		cmp	r6, #0
 3803 0096 02D0     		beq	.L678
 3804              	.L679:
1616:../Sources/TFC/TFC_CrystalClock.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 3805              		.loc 1 1616 0
 3806 0098 BD79     		ldrb	r5, [r7, #6]
 3807 009a 2B42     		tst	r3, r5
 3808 009c F6D0     		beq	.L723
 3809              	.L678:
1618:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with err
 3810              		.loc 1 1618 0
 3811 009e 3848     		ldr	r0, .L727
 3812 00a0 8279     		ldrb	r2, [r0, #6]
 3813 00a2 9207     		lsl	r2, r2, #30
 3814 00a4 2DD4     		bmi	.L677
 3815 00a6 2324     		mov	r4, #35
 3816 00a8 BCE7     		b	.L669
 3817              	.LVL354:
 3818              	.L722:
1550:../Sources/TFC/TFC_CrystalClock.c ****     if ((crystal_val < 30000) ||
 3819              		.loc 1 1550 0
 3820 00aa 394F     		ldr	r7, .L727+16
1552:../Sources/TFC/TFC_CrystalClock.c ****         (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal op
 3821              		.loc 1 1552 0
 3822 00ac 2224     		mov	r4, #34
1550:../Sources/TFC/TFC_CrystalClock.c ****     if ((crystal_val < 30000) ||
 3823              		.loc 1 1550 0
 3824 00ae B842     		cmp	r0, r7
 3825 00b0 B8DD     		ble	.L669
1551:../Sources/TFC/TFC_CrystalClock.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 3826              		.loc 1 1551 0
 3827 00b2 384D     		ldr	r5, .L727+20
1550:../Sources/TFC/TFC_CrystalClock.c ****     if ((crystal_val < 30000) ||
 3828              		.loc 1 1550 0
 3829 00b4 384B     		ldr	r3, .L727+24
1551:../Sources/TFC/TFC_CrystalClock.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 3830              		.loc 1 1551 0
 3831 00b6 4219     		add	r2, r0, r5
1550:../Sources/TFC/TFC_CrystalClock.c ****     if ((crystal_val < 30000) ||
 3832              		.loc 1 1550 0
 3833 00b8 9A42     		cmp	r2, r3
 3834 00ba B3D9     		bls	.L669
1551:../Sources/TFC/TFC_CrystalClock.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 3835              		.loc 1 1551 0
 3836 00bc 374F     		ldr	r7, .L727+28
 3837 00be B842     		cmp	r0, r7
 3838 00c0 B0DC     		bgt	.L669
 3839 00c2 B3E7     		b	.L670
 3840              	.LVL355:
 3841              	.L671:
1570:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 8000000)
 3842              		.loc 1 1570 0
 3843 00c4 364D     		ldr	r5, .L727+32
 3844              	.LVL356:
 3845 00c6 A842     		cmp	r0, r5
 3846 00c8 39DC     		bgt	.L673
1572:../Sources/TFC/TFC_CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 3847              		.loc 1 1572 0
 3848 00ca 1025     		mov	r5, #16
 3849 00cc 2F43     		orr	r7, r5
 3850              	.LVL357:
 3851 00ce B400     		lsl	r4, r6, #2
 3852 00d0 2743     		orr	r7, r4
 3853 00d2 FAB2     		uxtb	r2, r7
 3854 00d4 CF00     		lsl	r7, r1, #3
 3855 00d6 1743     		orr	r7, r2
 3856              	.LVL358:
1578:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C2 = temp_reg;
 3857              		.loc 1 1578 0
 3858 00d8 5F70     		strb	r7, [r3, #1]
1582:../Sources/TFC/TFC_CrystalClock.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 3859              		.loc 1 1582 0
 3860 00da 324B     		ldr	r3, .L727+36
 3861 00dc 9842     		cmp	r0, r3
 3862 00de 4ADD     		ble	.L724
 3863              	.LVL359:
 3864              	.L674:
1583:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
 3865              		.loc 1 1583 0
 3866 00e0 3149     		ldr	r1, .L727+40
 3867 00e2 8842     		cmp	r0, r1
 3868 00e4 27DD     		ble	.L689
1584:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
 3869              		.loc 1 1584 0
 3870 00e6 314D     		ldr	r5, .L727+44
 3871 00e8 A842     		cmp	r0, r5
 3872 00ea 36DD     		ble	.L690
1585:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
 3873              		.loc 1 1585 0
 3874 00ec 304C     		ldr	r4, .L727+48
 3875 00ee A042     		cmp	r0, r4
 3876 00f0 37DD     		ble	.L691
1586:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
 3877              		.loc 1 1586 0
 3878 00f2 264A     		ldr	r2, .L727+12
 3879 00f4 9042     		cmp	r0, r2
 3880 00f6 39DC     		bgt	.L692
 3881 00f8 8021     		mov	r1, #128
 3882 00fa 2027     		mov	r7, #32
 3883 00fc 1025     		mov	r5, #16
 3884 00fe 8900     		lsl	r1, r1, #2
 3885 0100 A7E7     		b	.L672
 3886              	.LVL360:
 3887              	.L677:
1624:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 3888              		.loc 1 1624 0
 3889 0102 1F4E     		ldr	r6, .L727
 3890 0104 1027     		mov	r7, #16
 3891 0106 B379     		ldrb	r3, [r6, #6]
 3892 0108 1F42     		tst	r7, r3
 3893 010a 0ED0     		beq	.L680
 3894 010c B179     		ldrb	r1, [r6, #6]
 3895 010e 294D     		ldr	r5, .L727+52
 3896 0110 0F42     		tst	r7, r1
 3897 0112 0AD0     		beq	.L680
 3898 0114 013D     		sub	r5, r5, #1
 3899 0116 05E0     		b	.L701
 3900              	.L725:
 3901 0118 B279     		ldrb	r2, [r6, #6]
 3902 011a 1742     		tst	r7, r2
 3903 011c 05D0     		beq	.L680
 3904 011e 023D     		sub	r5, r5, #2
1622:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 3905              		.loc 1 1622 0
 3906 0120 002D     		cmp	r5, #0
 3907 0122 02D0     		beq	.L680
 3908              	.L701:
1624:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 3909              		.loc 1 1624 0
 3910 0124 B079     		ldrb	r0, [r6, #6]
 3911 0126 0742     		tst	r7, r0
 3912 0128 F6D1     		bne	.L725
 3913              	.L680:
1626:../Sources/TFC/TFC_CrystalClock.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
 3914              		.loc 1 1626 0
 3915 012a 154E     		ldr	r6, .L727
 3916 012c B779     		ldrb	r7, [r6, #6]
 3917 012e F906     		lsl	r1, r7, #27
 3918 0130 0ED5     		bpl	.L726
 3919 0132 1124     		mov	r4, #17
 3920 0134 76E7     		b	.L669
 3921              	.LVL361:
 3922              	.L689:
1583:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
 3923              		.loc 1 1583 0
 3924 0136 0827     		mov	r7, #8
 3925 0138 0225     		mov	r5, #2
 3926 013a 4021     		mov	r1, #64
 3927 013c 89E7     		b	.L672
 3928              	.LVL362:
 3929              	.L673:
1576:../Sources/TFC/TFC_CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 3930              		.loc 1 1576 0
 3931 013e 2024     		mov	r4, #32
 3932 0140 2743     		orr	r7, r4
 3933              	.LVL363:
 3934 0142 B200     		lsl	r2, r6, #2
 3935 0144 1743     		orr	r7, r2
 3936 0146 FFB2     		uxtb	r7, r7
 3937 0148 C900     		lsl	r1, r1, #3
 3938 014a 3943     		orr	r1, r7
 3939              	.LVL364:
1578:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C2 = temp_reg;
 3940              		.loc 1 1578 0
 3941 014c 5970     		strb	r1, [r3, #1]
 3942 014e C7E7     		b	.L674
 3943              	.LVL365:
 3944              	.L726:
1631:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 |= MCG_C6_CME0_MASK;
 3945              		.loc 1 1631 0
 3946 0150 7379     		ldrb	r3, [r6, #5]
 3947 0152 2025     		mov	r5, #32
 3948 0154 1D43     		orr	r5, r3
 3949 0156 7571     		strb	r5, [r6, #5]
1633:../Sources/TFC/TFC_CrystalClock.c ****   return mcg_out; // MCGOUT frequency equals FLL frequency
 3950              		.loc 1 1633 0
 3951 0158 64E7     		b	.L669
 3952              	.LVL366:
 3953              	.L690:
1584:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
 3954              		.loc 1 1584 0
 3955 015a 1027     		mov	r7, #16
 3956 015c 0425     		mov	r5, #4
 3957 015e 8021     		mov	r1, #128
 3958 0160 77E7     		b	.L672
 3959              	.L691:
1585:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
 3960              		.loc 1 1585 0
 3961 0162 8024     		mov	r4, #128
 3962 0164 1827     		mov	r7, #24
 3963 0166 0825     		mov	r5, #8
 3964 0168 6100     		lsl	r1, r4, #1
 3965 016a 72E7     		b	.L672
 3966              	.L692:
1586:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
 3967              		.loc 1 1586 0
 3968 016c 8023     		mov	r3, #128
 3969 016e 2827     		mov	r7, #40
 3970 0170 2025     		mov	r5, #32
 3971 0172 D900     		lsl	r1, r3, #3
 3972 0174 6DE7     		b	.L672
 3973              	.LVL367:
 3974              	.L724:
1582:../Sources/TFC/TFC_CrystalClock.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 3975              		.loc 1 1582 0
 3976 0176 0027     		mov	r7, #0
 3977              	.LVL368:
 3978 0178 0125     		mov	r5, #1
 3979 017a 2021     		mov	r1, #32
 3980              	.LVL369:
 3981 017c 69E7     		b	.L672
 3982              	.L728:
 3983 017e C046     		.align	2
 3984              	.L727:
 3985 0180 00400640 		.word	1074151424
 3986 0184 80F0FA02 		.word	50000000
 3987 0188 409C0000 		.word	40000
 3988 018c 002D3101 		.word	20000000
 3989 0190 2F750000 		.word	29999
 3990 0194 BF63FFFF 		.word	-40001
 3991 0198 7E2A2D00 		.word	2959998
 3992 019c 0048E801 		.word	32000000
 3993 01a0 00127A00 		.word	8000000
 3994 01a4 D0121300 		.word	1250000
 3995 01a8 A0252600 		.word	2500000
 3996 01ac 404B4C00 		.word	5000000
 3997 01b0 80969800 		.word	10000000
 3998 01b4 CF070000 		.word	1999
 3999              		.cfi_endproc
 4000              	.LFE22:
 4002              		.section	.text.fee_fei,"ax",%progbits
 4003              		.align	2
 4004              		.global	fee_fei
 4005              		.code	16
 4006              		.thumb_func
 4008              	fee_fei:
 4009              	.LFB23:
1638:../Sources/TFC/TFC_CrystalClock.c **** {
 4010              		.loc 1 1638 0
 4011              		.cfi_startproc
 4012              	.LVL370:
 4013 0000 38B5     		push	{r3, r4, r5, lr}
 4014              	.LCFI25:
 4015              		.cfi_def_cfa_offset 16
 4016              		.cfi_offset 3, -16
 4017              		.cfi_offset 4, -12
 4018              		.cfi_offset 5, -8
 4019              		.cfi_offset 14, -4
1643:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 4020              		.loc 1 1643 0
 4021 0002 1D4C     		ldr	r4, .L743
1647:../Sources/TFC/TFC_CrystalClock.c ****     return 0x2;                                                     // return error code
 4022              		.loc 1 1647 0
 4023 0004 0223     		mov	r3, #2
1643:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 4024              		.loc 1 1643 0
 4025 0006 A279     		ldrb	r2, [r4, #6]
 4026 0008 1107     		lsl	r1, r2, #28
 4027 000a 8D0F     		lsr	r5, r1, #30
 4028 000c 01D0     		beq	.L741
 4029              	.LVL371:
 4030              	.L730:
1675:../Sources/TFC/TFC_CrystalClock.c **** } // fee_fei
 4031              		.loc 1 1675 0
 4032 000e 181C     		mov	r0, r3
 4033              		@ sp needed for prologue
 4034 0010 38BD     		pop	{r3, r4, r5, pc}
 4035              	.LVL372:
 4036              	.L741:
1644:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                             // check FLL ref is external re
 4037              		.loc 1 1644 0
 4038 0012 A279     		ldrb	r2, [r4, #6]
1643:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 4039              		.loc 1 1643 0
 4040 0014 D106     		lsl	r1, r2, #27
 4041 0016 FAD4     		bmi	.L730
1645:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                               // check PLLS mux has selected 
 4042              		.loc 1 1645 0
 4043 0018 A179     		ldrb	r1, [r4, #6]
 4044 001a 2025     		mov	r5, #32
1643:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 4045              		.loc 1 1643 0
 4046 001c 0D42     		tst	r5, r1
 4047 001e F6D1     		bne	.L730
1651:../Sources/TFC/TFC_CrystalClock.c ****   if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
 4048              		.loc 1 1651 0
 4049 0020 164B     		ldr	r3, .L743+4
 4050 0022 174A     		ldr	r2, .L743+8
 4051 0024 C118     		add	r1, r0, r3
1653:../Sources/TFC/TFC_CrystalClock.c ****     return 0x31;
 4052              		.loc 1 1653 0
 4053 0026 3123     		mov	r3, #49
1651:../Sources/TFC/TFC_CrystalClock.c ****   if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
 4054              		.loc 1 1651 0
 4055 0028 9142     		cmp	r1, r2
 4056 002a F0D8     		bhi	.L730
 4057              	.LVL373:
 4058              	.LBB14:
 4059              	.LBB15:
1795:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) > 0x1) 
 4060              		.loc 1 1795 0
 4061 002c E178     		ldrb	r1, [r4, #3]
1797:../Sources/TFC/TFC_CrystalClock.c ****     return 0x3B; // return error code if DRS range 2 or 3 selected
 4062              		.loc 1 1797 0
 4063 002e 3B23     		mov	r3, #59
1795:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) > 0x1) 
 4064              		.loc 1 1795 0
 4065 0030 4906     		lsl	r1, r1, #25
 4066 0032 ECD4     		bmi	.L730
 4067 0034 FFF7FEFF 		bl	fll_freq.part.0
 4068              	.LVL374:
 4069 0038 031E     		sub	r3, r0, #0
 4070              	.LBE15:
 4071              	.LBE14:
1658:../Sources/TFC/TFC_CrystalClock.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
 4072              		.loc 1 1658 0
 4073 003a 3B2B     		cmp	r3, #59
 4074 003c E7DD     		ble	.L730
1661:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 &= ~MCG_C6_CME0_MASK;
 4075              		.loc 1 1661 0
 4076 003e 6079     		ldrb	r0, [r4, #5]
1664:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 |= MCG_C1_IREFS_MASK; // select internal reference
 4077              		.loc 1 1664 0
 4078 0040 0422     		mov	r2, #4
1661:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 &= ~MCG_C6_CME0_MASK;
 4079              		.loc 1 1661 0
 4080 0042 A843     		bic	r0, r5
 4081 0044 6071     		strb	r0, [r4, #5]
1664:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 |= MCG_C1_IREFS_MASK; // select internal reference
 4082              		.loc 1 1664 0
 4083 0046 2578     		ldrb	r5, [r4]
 4084 0048 FA21     		mov	r1, #250
 4085 004a 2A43     		orr	r2, r5
 4086 004c 2270     		strb	r2, [r4]
 4087              	.LVL375:
1669:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
 4088              		.loc 1 1669 0
 4089 004e 1025     		mov	r5, #16
1664:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 |= MCG_C1_IREFS_MASK; // select internal reference
 4090              		.loc 1 1664 0
 4091 0050 CA00     		lsl	r2, r1, #3
 4092 0052 08E0     		b	.L732
 4093              	.LVL376:
 4094              	.L742:
1669:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
 4095              		.loc 1 1669 0
 4096 0054 A179     		ldrb	r1, [r4, #6]
 4097 0056 013A     		sub	r2, r2, #1
 4098 0058 92B2     		uxth	r2, r2
 4099 005a 0D42     		tst	r5, r1
 4100 005c 06D1     		bne	.L731
 4101 005e 013A     		sub	r2, r2, #1
 4102 0060 92B2     		uxth	r2, r2
1667:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 4103              		.loc 1 1667 0
 4104 0062 002A     		cmp	r2, #0
 4105 0064 02D0     		beq	.L731
 4106              	.L732:
1669:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
 4107              		.loc 1 1669 0
 4108 0066 A079     		ldrb	r0, [r4, #6]
 4109 0068 0542     		tst	r5, r0
 4110 006a F3D0     		beq	.L742
 4111              	.L731:
1671:../Sources/TFC/TFC_CrystalClock.c ****   if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error i
 4112              		.loc 1 1671 0
 4113 006c 024C     		ldr	r4, .L743
 4114 006e A579     		ldrb	r5, [r4, #6]
 4115 0070 E906     		lsl	r1, r5, #27
 4116 0072 CCD4     		bmi	.L730
 4117 0074 1223     		mov	r3, #18
 4118 0076 CAE7     		b	.L730
 4119              	.L744:
 4120              		.align	2
 4121              	.L743:
 4122 0078 00400640 		.word	1074151424
 4123 007c EE85FFFF 		.word	-31250
 4124 0080 851E0000 		.word	7813
 4125              		.cfi_endproc
 4126              	.LFE23:
 4128              		.section	.text.fll_freq,"ax",%progbits
 4129              		.align	2
 4130              		.global	fll_freq
 4131              		.code	16
 4132              		.thumb_func
 4134              	fll_freq:
 4135              	.LFB25:
1791:../Sources/TFC/TFC_CrystalClock.c **** {
 4136              		.loc 1 1791 0
 4137              		.cfi_startproc
 4138              	.LVL377:
 4139 0000 08B5     		push	{r3, lr}
 4140              	.LCFI26:
 4141              		.cfi_def_cfa_offset 8
 4142              		.cfi_offset 3, -8
 4143              		.cfi_offset 14, -4
1795:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) > 0x1) 
 4144              		.loc 1 1795 0
 4145 0002 054B     		ldr	r3, .L749
 4146 0004 DA78     		ldrb	r2, [r3, #3]
1797:../Sources/TFC/TFC_CrystalClock.c ****     return 0x3B; // return error code if DRS range 2 or 3 selected
 4147              		.loc 1 1797 0
 4148 0006 3B23     		mov	r3, #59
1795:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) > 0x1) 
 4149              		.loc 1 1795 0
 4150 0008 5106     		lsl	r1, r2, #25
 4151 000a 01D5     		bpl	.L748
 4152              	.LVL378:
 4153              	.L746:
 4154              		.loc 1 1853 0
 4155 000c 181C     		mov	r0, r3
 4156              		@ sp needed for prologue
 4157 000e 08BD     		pop	{r3, pc}
 4158              	.LVL379:
 4159              	.L748:
 4160 0010 FFF7FEFF 		bl	fll_freq.part.0
 4161              	.LVL380:
 4162 0014 031C     		mov	r3, r0
 4163 0016 F9E7     		b	.L746
 4164              	.L750:
 4165              		.align	2
 4166              	.L749:
 4167 0018 00400640 		.word	1074151424
 4168              		.cfi_endproc
 4169              	.LFE25:
 4171              		.section	.text.fbi_fei,"ax",%progbits
 4172              		.align	2
 4173              		.global	fbi_fei
 4174              		.code	16
 4175              		.thumb_func
 4177              	fbi_fei:
 4178              	.LFB20:
1383:../Sources/TFC/TFC_CrystalClock.c **** {
 4179              		.loc 1 1383 0
 4180              		.cfi_startproc
 4181              	.LVL381:
 4182 0000 10B5     		push	{r4, lr}
 4183              	.LCFI27:
 4184              		.cfi_def_cfa_offset 8
 4185              		.cfi_offset 4, -8
 4186              		.cfi_offset 14, -4
1389:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4187              		.loc 1 1389 0
 4188 0002 284C     		ldr	r4, .L781
1394:../Sources/TFC/TFC_CrystalClock.c ****     return 0x3;                                                       // MCG not in correct mode re
 4189              		.loc 1 1394 0
 4190 0004 0323     		mov	r3, #3
1389:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4191              		.loc 1 1389 0
 4192 0006 A279     		ldrb	r2, [r4, #6]
 4193 0008 1107     		lsl	r1, r2, #28
 4194 000a 8A0F     		lsr	r2, r1, #30
 4195 000c 012A     		cmp	r2, #1
 4196 000e 01D0     		beq	.L777
 4197              	.LVL382:
 4198              	.L752:
1430:../Sources/TFC/TFC_CrystalClock.c **** } // fbi_fei
 4199              		.loc 1 1430 0
 4200 0010 181C     		mov	r0, r3
 4201              		@ sp needed for prologue
 4202 0012 10BD     		pop	{r4, pc}
 4203              	.LVL383:
 4204              	.L777:
1390:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 4205              		.loc 1 1390 0
 4206 0014 A179     		ldrb	r1, [r4, #6]
1389:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4207              		.loc 1 1389 0
 4208 0016 C906     		lsl	r1, r1, #27
 4209 0018 FAD5     		bpl	.L752
1391:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 4210              		.loc 1 1391 0
 4211 001a A279     		ldrb	r2, [r4, #6]
1390:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 4212              		.loc 1 1390 0
 4213 001c 9106     		lsl	r1, r2, #26
 4214 001e F7D4     		bmi	.L752
1392:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
 4215              		.loc 1 1392 0
 4216 0020 6178     		ldrb	r1, [r4, #1]
1389:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4217              		.loc 1 1389 0
 4218 0022 8907     		lsl	r1, r1, #30
 4219 0024 F4D4     		bmi	.L752
1398:../Sources/TFC/TFC_CrystalClock.c ****   if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
 4220              		.loc 1 1398 0
 4221 0026 204B     		ldr	r3, .L781+4
 4222 0028 204A     		ldr	r2, .L781+8
 4223 002a C118     		add	r1, r0, r3
1400:../Sources/TFC/TFC_CrystalClock.c ****     return 0x31;
 4224              		.loc 1 1400 0
 4225 002c 3123     		mov	r3, #49
1398:../Sources/TFC/TFC_CrystalClock.c ****   if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
 4226              		.loc 1 1398 0
 4227 002e 9142     		cmp	r1, r2
 4228 0030 EED8     		bhi	.L752
1404:../Sources/TFC/TFC_CrystalClock.c ****   mcg_out = fll_freq(slow_irc_freq); 
 4229              		.loc 1 1404 0
 4230 0032 FFF7FEFF 		bl	fll_freq
 4231              	.LVL384:
 4232 0036 031E     		sub	r3, r0, #0
 4233              	.LVL385:
1405:../Sources/TFC/TFC_CrystalClock.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
 4234              		.loc 1 1405 0
 4235 0038 3B2B     		cmp	r3, #59
 4236 003a E9DD     		ble	.L752
1408:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C1;
 4237              		.loc 1 1408 0
 4238 003c 2078     		ldrb	r0, [r4]
 4239              	.LVL386:
1409:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS field
 4240              		.loc 1 1409 0
 4241 003e 3F22     		mov	r2, #63
 4242 0040 0240     		and	r2, r0
 4243              	.LVL387:
1411:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= MCG_C1_IREFS_MASK; // make sure IRC is FLL reference
 4244              		.loc 1 1411 0
 4245 0042 0421     		mov	r1, #4
 4246 0044 0A43     		orr	r2, r1
 4247              	.LVL388:
1412:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 = temp_reg; // update MCG_C1
 4248              		.loc 1 1412 0
 4249 0046 FA20     		mov	r0, #250
 4250 0048 2270     		strb	r2, [r4]
 4251              	.LVL389:
1417:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST clears before loop finishes
 4252              		.loc 1 1417 0
 4253 004a 1021     		mov	r1, #16
1412:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 = temp_reg; // update MCG_C1
 4254              		.loc 1 1412 0
 4255 004c C200     		lsl	r2, r0, #3
 4256              	.LVL390:
 4257 004e 08E0     		b	.L754
 4258              	.LVL391:
 4259              	.L778:
1417:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST clears before loop finishes
 4260              		.loc 1 1417 0
 4261 0050 A079     		ldrb	r0, [r4, #6]
 4262 0052 013A     		sub	r2, r2, #1
 4263 0054 92B2     		uxth	r2, r2
 4264 0056 0142     		tst	r1, r0
 4265 0058 06D1     		bne	.L753
 4266 005a 013A     		sub	r2, r2, #1
 4267 005c 92B2     		uxth	r2, r2
1415:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 4268              		.loc 1 1415 0
 4269 005e 002A     		cmp	r2, #0
 4270 0060 02D0     		beq	.L753
 4271              	.L754:
1417:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST clears before loop finishes
 4272              		.loc 1 1417 0
 4273 0062 A079     		ldrb	r0, [r4, #6]
 4274 0064 0142     		tst	r1, r0
 4275 0066 F3D0     		beq	.L778
 4276              	.L753:
1419:../Sources/TFC/TFC_CrystalClock.c ****   if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error i
 4277              		.loc 1 1419 0
 4278 0068 0E48     		ldr	r0, .L781
 4279 006a 8479     		ldrb	r4, [r0, #6]
 4280 006c E106     		lsl	r1, r4, #27
 4281 006e 01D4     		bmi	.L779
 4282 0070 1223     		mov	r3, #18
 4283              	.LVL392:
 4284 0072 CDE7     		b	.L752
 4285              	.LVL393:
 4286              	.L779:
 4287 0074 FA21     		mov	r1, #250
 4288 0076 CA00     		lsl	r2, r1, #3
1424:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST
 4289              		.loc 1 1424 0
 4290 0078 0C21     		mov	r1, #12
 4291 007a 08E0     		b	.L756
 4292              	.L780:
 4293 007c 8479     		ldrb	r4, [r0, #6]
 4294 007e 013A     		sub	r2, r2, #1
 4295 0080 92B2     		uxth	r2, r2
 4296 0082 2142     		tst	r1, r4
 4297 0084 06D0     		beq	.L755
 4298 0086 013A     		sub	r2, r2, #1
 4299 0088 92B2     		uxth	r2, r2
1422:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 4300              		.loc 1 1422 0
 4301 008a 002A     		cmp	r2, #0
 4302 008c 02D0     		beq	.L755
 4303              	.L756:
1424:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST
 4304              		.loc 1 1424 0
 4305 008e 8479     		ldrb	r4, [r0, #6]
 4306 0090 2142     		tst	r1, r4
 4307 0092 F3D1     		bne	.L780
 4308              	.L755:
1426:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check FLL is really
 4309              		.loc 1 1426 0
 4310 0094 0348     		ldr	r0, .L781
 4311 0096 8179     		ldrb	r1, [r0, #6]
 4312 0098 0C07     		lsl	r4, r1, #28
 4313 009a A20F     		lsr	r2, r4, #30
 4314 009c B8D0     		beq	.L752
 4315 009e 1823     		mov	r3, #24
 4316              	.LVL394:
 4317 00a0 B6E7     		b	.L752
 4318              	.L782:
 4319 00a2 C046     		.align	2
 4320              	.L781:
 4321 00a4 00400640 		.word	1074151424
 4322 00a8 EE85FFFF 		.word	-31250
 4323 00ac 851E0000 		.word	7813
 4324              		.cfi_endproc
 4325              	.LFE20:
 4327              		.section	.text.fbi_fee,"ax",%progbits
 4328              		.align	2
 4329              		.global	fbi_fee
 4330              		.code	16
 4331              		.thumb_func
 4333              	fbi_fee:
 4334              	.LFB18:
1183:../Sources/TFC/TFC_CrystalClock.c **** {
 4335              		.loc 1 1183 0
 4336              		.cfi_startproc
 4337              	.LVL395:
 4338 0000 70B5     		push	{r4, r5, r6, lr}
 4339              	.LCFI28:
 4340              		.cfi_def_cfa_offset 16
 4341              		.cfi_offset 4, -16
 4342              		.cfi_offset 5, -12
 4343              		.cfi_offset 6, -8
 4344              		.cfi_offset 14, -4
1190:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4345              		.loc 1 1190 0
 4346 0002 6C4B     		ldr	r3, .L853
1183:../Sources/TFC/TFC_CrystalClock.c **** {
 4347              		.loc 1 1183 0
 4348 0004 161C     		mov	r6, r2
1190:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4349              		.loc 1 1190 0
 4350 0006 9D79     		ldrb	r5, [r3, #6]
1195:../Sources/TFC/TFC_CrystalClock.c ****     return 0x3;                                                       // MCG not in correct mode re
 4351              		.loc 1 1195 0
 4352 0008 0324     		mov	r4, #3
1190:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4353              		.loc 1 1190 0
 4354 000a 2A07     		lsl	r2, r5, #28
 4355              	.LVL396:
 4356 000c 950F     		lsr	r5, r2, #30
 4357 000e 012D     		cmp	r5, #1
 4358 0010 01D0     		beq	.L846
 4359              	.LVL397:
 4360              	.L784:
1295:../Sources/TFC/TFC_CrystalClock.c **** } //fbi_fee
 4361              		.loc 1 1295 0
 4362 0012 201C     		mov	r0, r4
 4363              		@ sp needed for prologue
 4364 0014 70BD     		pop	{r4, r5, r6, pc}
 4365              	.LVL398:
 4366              	.L846:
1191:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 4367              		.loc 1 1191 0
 4368 0016 9A79     		ldrb	r2, [r3, #6]
1190:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4369              		.loc 1 1190 0
 4370 0018 D506     		lsl	r5, r2, #27
 4371 001a FAD5     		bpl	.L784
1192:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 4372              		.loc 1 1192 0
 4373 001c 9D79     		ldrb	r5, [r3, #6]
1191:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 4374              		.loc 1 1191 0
 4375 001e AD06     		lsl	r5, r5, #26
 4376 0020 F7D4     		bmi	.L784
1193:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
 4377              		.loc 1 1193 0
 4378 0022 5B78     		ldrb	r3, [r3, #1]
1190:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4379              		.loc 1 1190 0
 4380 0024 9A07     		lsl	r2, r3, #30
 4381 0026 F4D4     		bmi	.L784
1199:../Sources/TFC/TFC_CrystalClock.c ****   if  (crystal_val > 50000000) {return 0x21;}
 4382              		.loc 1 1199 0
 4383 0028 634A     		ldr	r2, .L853+4
 4384 002a 2124     		mov	r4, #33
 4385 002c 9042     		cmp	r0, r2
 4386 002e F0DC     		bgt	.L784
1202:../Sources/TFC/TFC_CrystalClock.c ****   if (erefs_val)
 4387              		.loc 1 1202 0
 4388 0030 002E     		cmp	r6, #0
 4389 0032 0BD0     		beq	.L785
1204:../Sources/TFC/TFC_CrystalClock.c ****     if ((crystal_val < 30000) ||
 4390              		.loc 1 1204 0
 4391 0034 614D     		ldr	r5, .L853+8
1206:../Sources/TFC/TFC_CrystalClock.c ****         (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal op
 4392              		.loc 1 1206 0
 4393 0036 2224     		mov	r4, #34
1204:../Sources/TFC/TFC_CrystalClock.c ****     if ((crystal_val < 30000) ||
 4394              		.loc 1 1204 0
 4395 0038 A842     		cmp	r0, r5
 4396 003a EADD     		ble	.L784
1205:../Sources/TFC/TFC_CrystalClock.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 4397              		.loc 1 1205 0
 4398 003c 604B     		ldr	r3, .L853+12
1204:../Sources/TFC/TFC_CrystalClock.c ****     if ((crystal_val < 30000) ||
 4399              		.loc 1 1204 0
 4400 003e 614D     		ldr	r5, .L853+16
1205:../Sources/TFC/TFC_CrystalClock.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 4401              		.loc 1 1205 0
 4402 0040 C218     		add	r2, r0, r3
1204:../Sources/TFC/TFC_CrystalClock.c ****     if ((crystal_val < 30000) ||
 4403              		.loc 1 1204 0
 4404 0042 AA42     		cmp	r2, r5
 4405 0044 E5D9     		bls	.L784
1205:../Sources/TFC/TFC_CrystalClock.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 4406              		.loc 1 1205 0
 4407 0046 604B     		ldr	r3, .L853+20
 4408 0048 9842     		cmp	r0, r3
 4409 004a E2DC     		bgt	.L784
 4410              	.L785:
1218:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C2;
 4411              		.loc 1 1218 0
 4412 004c 594D     		ldr	r5, .L853
1212:../Sources/TFC/TFC_CrystalClock.c ****     hgo_val = 1; // force hgo_val to 1 if > 0
 4413              		.loc 1 1212 0
 4414 004e 0A1C     		mov	r2, r1
 4415 0050 511E     		sub	r1, r2, #1
 4416 0052 8A41     		sbc	r2, r2, r1
 4417              	.LVL399:
1220:../Sources/TFC/TFC_CrystalClock.c ****   if (crystal_val <= 40000)
 4418              		.loc 1 1220 0
 4419 0054 5D4B     		ldr	r3, .L853+24
1218:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C2;
 4420              		.loc 1 1218 0
 4421 0056 6978     		ldrb	r1, [r5, #1]
 4422              	.LVL400:
1219:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
 4423              		.loc 1 1219 0
 4424 0058 3C24     		mov	r4, #60
 4425 005a A143     		bic	r1, r4
 4426              	.LVL401:
1220:../Sources/TFC/TFC_CrystalClock.c ****   if (crystal_val <= 40000)
 4427              		.loc 1 1220 0
 4428 005c 9842     		cmp	r0, r3
 4429 005e 4FDC     		bgt	.L786
1222:../Sources/TFC/TFC_CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 4430              		.loc 1 1222 0
 4431 0060 B300     		lsl	r3, r6, #2
 4432 0062 1943     		orr	r1, r3
 4433              	.LVL402:
 4434 0064 CCB2     		uxtb	r4, r1
 4435 0066 D100     		lsl	r1, r2, #3
 4436 0068 2143     		orr	r1, r4
 4437              	.LVL403:
1232:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C2 = temp_reg;
 4438              		.loc 1 1232 0
 4439 006a 6970     		strb	r1, [r5, #1]
 4440 006c 0123     		mov	r3, #1
 4441 006e 0025     		mov	r5, #0
 4442 0070 2021     		mov	r1, #32
 4443              	.LVL404:
 4444              	.L787:
1243:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
 4445              		.loc 1 1243 0
 4446 0072 504A     		ldr	r2, .L853
 4447 0074 5478     		ldrb	r4, [r2, #1]
 4448 0076 A206     		lsl	r2, r4, #26
 4449 0078 940F     		lsr	r4, r2, #30
 4450 007a 00D1     		bne	.L845
1249:../Sources/TFC/TFC_CrystalClock.c ****     fll_ref_freq = ((crystal_val) / (1 << frdiv_val));
 4451              		.loc 1 1249 0
 4452 007c 191C     		mov	r1, r3
 4453              	.L845:
 4454 007e FFF7FEFF 		bl	__aeabi_idiv
 4455              	.LVL405:
1253:../Sources/TFC/TFC_CrystalClock.c ****   mcg_out = fll_freq(fll_ref_freq); // FLL reference frequency calculated from ext ref freq and FRD
 4456              		.loc 1 1253 0
 4457 0082 FFF7FEFF 		bl	fll_freq
 4458              	.LVL406:
 4459 0086 041E     		sub	r4, r0, #0
 4460              	.LVL407:
1254:../Sources/TFC/TFC_CrystalClock.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
 4461              		.loc 1 1254 0
 4462 0088 3B2C     		cmp	r4, #59
 4463 008a C2DD     		ble	.L784
1259:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C1;
 4464              		.loc 1 1259 0
 4465 008c 4949     		ldr	r1, .L853
1260:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear CLKS, FRDIV and
 4466              		.loc 1 1260 0
 4467 008e 0323     		mov	r3, #3
1259:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C1;
 4468              		.loc 1 1259 0
 4469 0090 0878     		ldrb	r0, [r1]
 4470              	.LVL408:
1260:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear CLKS, FRDIV and
 4471              		.loc 1 1260 0
 4472 0092 0340     		and	r3, r0
 4473              	.LVL409:
1261:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= (MCG_C1_CLKS(0) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
 4474              		.loc 1 1261 0
 4475 0094 1D43     		orr	r5, r3
 4476              	.LVL410:
1262:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 = temp_reg;
 4477              		.loc 1 1262 0
 4478 0096 0D70     		strb	r5, [r1]
1265:../Sources/TFC/TFC_CrystalClock.c ****   if (erefs_val)
 4479              		.loc 1 1265 0
 4480 0098 002E     		cmp	r6, #0
 4481 009a 14D0     		beq	.L792
 4482 009c 4C4B     		ldr	r3, .L853+28
1269:../Sources/TFC/TFC_CrystalClock.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 4483              		.loc 1 1269 0
 4484 009e 0226     		mov	r6, #2
 4485 00a0 08E0     		b	.L794
 4486              	.LVL411:
 4487              	.L847:
 4488 00a2 8879     		ldrb	r0, [r1, #6]
 4489 00a4 013B     		sub	r3, r3, #1
 4490 00a6 9AB2     		uxth	r2, r3
 4491 00a8 0642     		tst	r6, r0
 4492 00aa 06D1     		bne	.L793
 4493 00ac 013A     		sub	r2, r2, #1
 4494 00ae 93B2     		uxth	r3, r2
1267:../Sources/TFC/TFC_CrystalClock.c ****     for (i = 0 ; i < 10000 ; i++)
 4495              		.loc 1 1267 0
 4496 00b0 002B     		cmp	r3, #0
 4497 00b2 02D0     		beq	.L793
 4498              	.L794:
1269:../Sources/TFC/TFC_CrystalClock.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 4499              		.loc 1 1269 0
 4500 00b4 8D79     		ldrb	r5, [r1, #6]
 4501 00b6 2E42     		tst	r6, r5
 4502 00b8 F3D0     		beq	.L847
 4503              	.L793:
1271:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with err
 4504              		.loc 1 1271 0
 4505 00ba 3E49     		ldr	r1, .L853
 4506 00bc 8E79     		ldrb	r6, [r1, #6]
 4507 00be B507     		lsl	r5, r6, #30
 4508 00c0 01D4     		bmi	.L792
 4509 00c2 2324     		mov	r4, #35
 4510              	.LVL412:
 4511 00c4 A5E7     		b	.L784
 4512              	.LVL413:
 4513              	.L792:
1277:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 4514              		.loc 1 1277 0
 4515 00c6 3B4D     		ldr	r5, .L853
 4516 00c8 1022     		mov	r2, #16
 4517 00ca A879     		ldrb	r0, [r5, #6]
 4518 00cc 0242     		tst	r2, r0
 4519 00ce 11D0     		beq	.L795
 4520 00d0 A979     		ldrb	r1, [r5, #6]
 4521 00d2 404B     		ldr	r3, .L853+32
 4522 00d4 0A42     		tst	r2, r1
 4523 00d6 0DD0     		beq	.L795
 4524 00d8 013B     		sub	r3, r3, #1
 4525 00da 08E0     		b	.L821
 4526              	.L848:
 4527 00dc A879     		ldrb	r0, [r5, #6]
 4528 00de 013B     		sub	r3, r3, #1
 4529 00e0 9BB2     		uxth	r3, r3
 4530 00e2 0242     		tst	r2, r0
 4531 00e4 06D0     		beq	.L795
 4532 00e6 013B     		sub	r3, r3, #1
 4533 00e8 9BB2     		uxth	r3, r3
1275:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 4534              		.loc 1 1275 0
 4535 00ea 002B     		cmp	r3, #0
 4536 00ec 02D0     		beq	.L795
 4537              	.L821:
1277:../Sources/TFC/TFC_CrystalClock.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 4538              		.loc 1 1277 0
 4539 00ee AE79     		ldrb	r6, [r5, #6]
 4540 00f0 3242     		tst	r2, r6
 4541 00f2 F3D1     		bne	.L848
 4542              	.L795:
1279:../Sources/TFC/TFC_CrystalClock.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
 4543              		.loc 1 1279 0
 4544 00f4 2F4D     		ldr	r5, .L853
 4545 00f6 AA79     		ldrb	r2, [r5, #6]
 4546 00f8 D206     		lsl	r2, r2, #27
 4547 00fa 2DD5     		bpl	.L849
 4548 00fc 1124     		mov	r4, #17
 4549              	.LVL414:
 4550 00fe 88E7     		b	.L784
 4551              	.LVL415:
 4552              	.L786:
1224:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 8000000)
 4553              		.loc 1 1224 0
 4554 0100 354C     		ldr	r4, .L853+36
 4555 0102 A042     		cmp	r0, r4
 4556 0104 1FDC     		bgt	.L788
1226:../Sources/TFC/TFC_CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 4557              		.loc 1 1226 0
 4558 0106 1023     		mov	r3, #16
 4559 0108 1943     		orr	r1, r3
 4560              	.LVL416:
 4561 010a B400     		lsl	r4, r6, #2
 4562 010c 2143     		orr	r1, r4
 4563 010e C9B2     		uxtb	r1, r1
 4564 0110 D200     		lsl	r2, r2, #3
 4565 0112 0A43     		orr	r2, r1
 4566              	.LVL417:
1232:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C2 = temp_reg;
 4567              		.loc 1 1232 0
 4568 0114 6A70     		strb	r2, [r5, #1]
1236:../Sources/TFC/TFC_CrystalClock.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 4569              		.loc 1 1236 0
 4570 0116 314D     		ldr	r5, .L853+40
 4571 0118 A842     		cmp	r0, r5
 4572 011a 42DD     		ble	.L850
 4573              	.LVL418:
 4574              	.L789:
1237:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
 4575              		.loc 1 1237 0
 4576 011c 304B     		ldr	r3, .L853+44
 4577 011e 9842     		cmp	r0, r3
 4578 0120 0DDD     		ble	.L807
1238:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
 4579              		.loc 1 1238 0
 4580 0122 304C     		ldr	r4, .L853+48
 4581 0124 A042     		cmp	r0, r4
 4582 0126 38DD     		ble	.L808
1239:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
 4583              		.loc 1 1239 0
 4584 0128 2F49     		ldr	r1, .L853+52
 4585 012a 8842     		cmp	r0, r1
 4586 012c 30DD     		ble	.L809
1240:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
 4587              		.loc 1 1240 0
 4588 012e 2F4A     		ldr	r2, .L853+56
 4589 0130 9042     		cmp	r0, r2
 4590 0132 28DC     		bgt	.L810
 4591 0134 8021     		mov	r1, #128
 4592 0136 2025     		mov	r5, #32
 4593 0138 1023     		mov	r3, #16
 4594 013a 8900     		lsl	r1, r1, #2
 4595 013c 99E7     		b	.L787
 4596              	.L807:
1237:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
 4597              		.loc 1 1237 0
 4598 013e 0825     		mov	r5, #8
 4599 0140 0223     		mov	r3, #2
 4600 0142 4021     		mov	r1, #64
 4601 0144 95E7     		b	.L787
 4602              	.LVL419:
 4603              	.L788:
1230:../Sources/TFC/TFC_CrystalClock.c ****     temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 4604              		.loc 1 1230 0
 4605 0146 2023     		mov	r3, #32
 4606 0148 1943     		orr	r1, r3
 4607              	.LVL420:
 4608 014a B400     		lsl	r4, r6, #2
 4609 014c 2143     		orr	r1, r4
 4610 014e C9B2     		uxtb	r1, r1
 4611 0150 D200     		lsl	r2, r2, #3
 4612 0152 0A43     		orr	r2, r1
 4613              	.LVL421:
1232:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C2 = temp_reg;
 4614              		.loc 1 1232 0
 4615 0154 6A70     		strb	r2, [r5, #1]
 4616 0156 E1E7     		b	.L789
 4617              	.LVL422:
 4618              	.L849:
1279:../Sources/TFC/TFC_CrystalClock.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
 4619              		.loc 1 1279 0
 4620 0158 FA21     		mov	r1, #250
 4621 015a C900     		lsl	r1, r1, #3
1284:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST
 4622              		.loc 1 1284 0
 4623 015c 0C26     		mov	r6, #12
 4624 015e 08E0     		b	.L797
 4625              	.L851:
 4626 0160 AA79     		ldrb	r2, [r5, #6]
 4627 0162 0139     		sub	r1, r1, #1
 4628 0164 8BB2     		uxth	r3, r1
 4629 0166 1642     		tst	r6, r2
 4630 0168 06D0     		beq	.L796
 4631 016a 013B     		sub	r3, r3, #1
 4632 016c 99B2     		uxth	r1, r3
1282:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 4633              		.loc 1 1282 0
 4634 016e 0029     		cmp	r1, #0
 4635 0170 02D0     		beq	.L796
 4636              	.L797:
1284:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST
 4637              		.loc 1 1284 0
 4638 0172 A879     		ldrb	r0, [r5, #6]
 4639 0174 0642     		tst	r6, r0
 4640 0176 F3D1     		bne	.L851
 4641              	.L796:
1286:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check FLLK is reall
 4642              		.loc 1 1286 0
 4643 0178 0E4D     		ldr	r5, .L853
 4644 017a AE79     		ldrb	r6, [r5, #6]
 4645 017c 3007     		lsl	r0, r6, #28
 4646 017e 830F     		lsr	r3, r0, #30
 4647 0180 13D0     		beq	.L852
 4648 0182 1824     		mov	r4, #24
 4649              	.LVL423:
 4650 0184 45E7     		b	.L784
 4651              	.LVL424:
 4652              	.L810:
1240:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
 4653              		.loc 1 1240 0
 4654 0186 8024     		mov	r4, #128
 4655 0188 2825     		mov	r5, #40
 4656 018a 2023     		mov	r3, #32
 4657 018c E100     		lsl	r1, r4, #3
 4658 018e 70E7     		b	.L787
 4659              	.L809:
1239:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
 4660              		.loc 1 1239 0
 4661 0190 8022     		mov	r2, #128
 4662 0192 1825     		mov	r5, #24
 4663 0194 0823     		mov	r3, #8
 4664 0196 5100     		lsl	r1, r2, #1
 4665 0198 6BE7     		b	.L787
 4666              	.L808:
1238:../Sources/TFC/TFC_CrystalClock.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
 4667              		.loc 1 1238 0
 4668 019a 1025     		mov	r5, #16
 4669 019c 0423     		mov	r3, #4
 4670 019e 8021     		mov	r1, #128
 4671 01a0 67E7     		b	.L787
 4672              	.LVL425:
 4673              	.L850:
1236:../Sources/TFC/TFC_CrystalClock.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 4674              		.loc 1 1236 0
 4675 01a2 0025     		mov	r5, #0
 4676 01a4 0123     		mov	r3, #1
 4677 01a6 2021     		mov	r1, #32
 4678 01a8 63E7     		b	.L787
 4679              	.LVL426:
 4680              	.L852:
1292:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 |= MCG_C6_CME0_MASK;
 4681              		.loc 1 1292 0
 4682 01aa 6A79     		ldrb	r2, [r5, #5]
 4683 01ac 2021     		mov	r1, #32
 4684 01ae 0A43     		orr	r2, r1
 4685 01b0 6A71     		strb	r2, [r5, #5]
1294:../Sources/TFC/TFC_CrystalClock.c ****   return mcg_out; // MCGOUT frequency equals FLL frequency
 4686              		.loc 1 1294 0
 4687 01b2 2EE7     		b	.L784
 4688              	.L854:
 4689              		.align	2
 4690              	.L853:
 4691 01b4 00400640 		.word	1074151424
 4692 01b8 80F0FA02 		.word	50000000
 4693 01bc 2F750000 		.word	29999
 4694 01c0 BF63FFFF 		.word	-40001
 4695 01c4 7E2A2D00 		.word	2959998
 4696 01c8 0048E801 		.word	32000000
 4697 01cc 409C0000 		.word	40000
 4698 01d0 10270000 		.word	10000
 4699 01d4 CF070000 		.word	1999
 4700 01d8 00127A00 		.word	8000000
 4701 01dc D0121300 		.word	1250000
 4702 01e0 A0252600 		.word	2500000
 4703 01e4 404B4C00 		.word	5000000
 4704 01e8 80969800 		.word	10000000
 4705 01ec 002D3101 		.word	20000000
 4706              		.cfi_endproc
 4707              	.LFE18:
 4709              		.section	.text.fbe_fei,"ax",%progbits
 4710              		.align	2
 4711              		.global	fbe_fei
 4712              		.code	16
 4713              		.thumb_func
 4715              	fbe_fei:
 4716              	.LFB10:
 663:../Sources/TFC/TFC_CrystalClock.c **** {
 4717              		.loc 1 663 0
 4718              		.cfi_startproc
 4719              	.LVL427:
 4720 0000 38B5     		push	{r3, r4, r5, lr}
 4721              	.LCFI29:
 4722              		.cfi_def_cfa_offset 16
 4723              		.cfi_offset 3, -16
 4724              		.cfi_offset 4, -12
 4725              		.cfi_offset 5, -8
 4726              		.cfi_offset 14, -4
 669:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 4727              		.loc 1 669 0
 4728 0002 2A4C     		ldr	r4, .L884
 674:../Sources/TFC/TFC_CrystalClock.c ****     return 0x4;                                                       // return error code
 4729              		.loc 1 674 0
 4730 0004 0422     		mov	r2, #4
 669:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 4731              		.loc 1 669 0
 4732 0006 A379     		ldrb	r3, [r4, #6]
 4733 0008 1907     		lsl	r1, r3, #28
 4734 000a 8B0F     		lsr	r3, r1, #30
 4735 000c 022B     		cmp	r3, #2
 4736 000e 01D0     		beq	.L880
 4737              	.LVL428:
 4738              	.L856:
 712:../Sources/TFC/TFC_CrystalClock.c **** } // fbe_fei
 4739              		.loc 1 712 0
 4740 0010 101C     		mov	r0, r2
 4741              		@ sp needed for prologue
 4742 0012 38BD     		pop	{r3, r4, r5, pc}
 4743              	.LVL429:
 4744              	.L880:
 670:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 4745              		.loc 1 670 0
 4746 0014 A579     		ldrb	r5, [r4, #6]
 669:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 4747              		.loc 1 669 0
 4748 0016 ED06     		lsl	r5, r5, #27
 4749 0018 FAD4     		bmi	.L856
 671:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 4750              		.loc 1 671 0
 4751 001a A179     		ldrb	r1, [r4, #6]
 4752 001c 2025     		mov	r5, #32
 670:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 4753              		.loc 1 670 0
 4754 001e 0D42     		tst	r5, r1
 4755 0020 F6D1     		bne	.L856
 672:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 4756              		.loc 1 672 0
 4757 0022 6178     		ldrb	r1, [r4, #1]
 669:../Sources/TFC/TFC_CrystalClock.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 4758              		.loc 1 669 0
 4759 0024 0B42     		tst	r3, r1
 4760 0026 F3D1     		bne	.L856
 678:../Sources/TFC/TFC_CrystalClock.c ****   if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
 4761              		.loc 1 678 0
 4762 0028 214A     		ldr	r2, .L884+4
 4763 002a 224B     		ldr	r3, .L884+8
 4764 002c 8118     		add	r1, r0, r2
 680:../Sources/TFC/TFC_CrystalClock.c ****     return 0x31;
 4765              		.loc 1 680 0
 4766 002e 3122     		mov	r2, #49
 678:../Sources/TFC/TFC_CrystalClock.c ****   if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
 4767              		.loc 1 678 0
 4768 0030 9942     		cmp	r1, r3
 4769 0032 EDD8     		bhi	.L856
 684:../Sources/TFC/TFC_CrystalClock.c ****   mcg_out = fll_freq(slow_irc_freq); 
 4770              		.loc 1 684 0
 4771 0034 FFF7FEFF 		bl	fll_freq
 4772              	.LVL430:
 4773 0038 021E     		sub	r2, r0, #0
 4774              	.LVL431:
 685:../Sources/TFC/TFC_CrystalClock.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
 4775              		.loc 1 685 0
 4776 003a 3B2A     		cmp	r2, #59
 4777 003c E8DD     		ble	.L856
 688:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 &= ~MCG_C6_CME0_MASK; //This assumes OSC0 is used as the external clock source
 4778              		.loc 1 688 0
 4779 003e 6079     		ldrb	r0, [r4, #5]
 4780              	.LVL432:
 692:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS to select FLL output
 4781              		.loc 1 692 0
 4782 0040 3F23     		mov	r3, #63
 688:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C6 &= ~MCG_C6_CME0_MASK; //This assumes OSC0 is used as the external clock source
 4783              		.loc 1 688 0
 4784 0042 A843     		bic	r0, r5
 4785 0044 6071     		strb	r0, [r4, #5]
 691:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = MCG_C1;
 4786              		.loc 1 691 0
 4787 0046 2578     		ldrb	r5, [r4]
 4788              	.LVL433:
 693:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= MCG_C1_IREFS_MASK; // select internal reference clock
 4789              		.loc 1 693 0
 4790 0048 0421     		mov	r1, #4
 692:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS to select FLL output
 4791              		.loc 1 692 0
 4792 004a 2B40     		and	r3, r5
 4793              	.LVL434:
 693:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= MCG_C1_IREFS_MASK; // select internal reference clock
 4794              		.loc 1 693 0
 4795 004c 0B43     		orr	r3, r1
 4796              	.LVL435:
 694:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 = temp_reg; // update MCG_C1 
 4797              		.loc 1 694 0
 4798 004e FA20     		mov	r0, #250
 4799 0050 2370     		strb	r3, [r4]
 4800              	.LVL436:
 699:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
 4801              		.loc 1 699 0
 4802 0052 1025     		mov	r5, #16
 694:../Sources/TFC/TFC_CrystalClock.c ****   MCG_C1 = temp_reg; // update MCG_C1 
 4803              		.loc 1 694 0
 4804 0054 C300     		lsl	r3, r0, #3
 4805              	.LVL437:
 4806 0056 08E0     		b	.L858
 4807              	.LVL438:
 4808              	.L881:
 699:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
 4809              		.loc 1 699 0
 4810 0058 A079     		ldrb	r0, [r4, #6]
 4811 005a 013B     		sub	r3, r3, #1
 4812 005c 9BB2     		uxth	r3, r3
 4813 005e 0542     		tst	r5, r0
 4814 0060 06D1     		bne	.L857
 4815 0062 013B     		sub	r3, r3, #1
 4816 0064 9BB2     		uxth	r3, r3
 697:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 4817              		.loc 1 697 0
 4818 0066 002B     		cmp	r3, #0
 4819 0068 02D0     		beq	.L857
 4820              	.L858:
 699:../Sources/TFC/TFC_CrystalClock.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
 4821              		.loc 1 699 0
 4822 006a A179     		ldrb	r1, [r4, #6]
 4823 006c 0D42     		tst	r5, r1
 4824 006e F3D0     		beq	.L881
 4825              	.L857:
 701:../Sources/TFC/TFC_CrystalClock.c ****   if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error i
 4826              		.loc 1 701 0
 4827 0070 0E48     		ldr	r0, .L884
 4828 0072 8479     		ldrb	r4, [r0, #6]
 4829 0074 E506     		lsl	r5, r4, #27
 4830 0076 01D4     		bmi	.L882
 4831 0078 1222     		mov	r2, #18
 4832              	.LVL439:
 4833 007a C9E7     		b	.L856
 4834              	.LVL440:
 4835              	.L882:
 4836 007c FA25     		mov	r5, #250
 4837 007e EB00     		lsl	r3, r5, #3
 706:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST
 4838              		.loc 1 706 0
 4839 0080 0C21     		mov	r1, #12
 4840 0082 08E0     		b	.L860
 4841              	.L883:
 4842 0084 8579     		ldrb	r5, [r0, #6]
 4843 0086 013B     		sub	r3, r3, #1
 4844 0088 9BB2     		uxth	r3, r3
 4845 008a 2942     		tst	r1, r5
 4846 008c 06D0     		beq	.L859
 4847 008e 013B     		sub	r3, r3, #1
 4848 0090 9BB2     		uxth	r3, r3
 704:../Sources/TFC/TFC_CrystalClock.c ****   for (i = 0 ; i < 2000 ; i++)
 4849              		.loc 1 704 0
 4850 0092 002B     		cmp	r3, #0
 4851 0094 02D0     		beq	.L859
 4852              	.L860:
 706:../Sources/TFC/TFC_CrystalClock.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST
 4853              		.loc 1 706 0
 4854 0096 8479     		ldrb	r4, [r0, #6]
 4855 0098 2142     		tst	r1, r4
 4856 009a F3D1     		bne	.L883
 4857              	.L859:
 708:../Sources/TFC/TFC_CrystalClock.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check EXT CLK is re
 4858              		.loc 1 708 0
 4859 009c 0348     		ldr	r0, .L884
 4860 009e 8179     		ldrb	r1, [r0, #6]
 4861 00a0 0C07     		lsl	r4, r1, #28
 4862 00a2 A50F     		lsr	r5, r4, #30
 4863 00a4 B4D0     		beq	.L856
 4864 00a6 1822     		mov	r2, #24
 4865              	.LVL441:
 4866 00a8 B2E7     		b	.L856
 4867              	.L885:
 4868 00aa C046     		.align	2
 4869              	.L884:
 4870 00ac 00400640 		.word	1074151424
 4871 00b0 EE85FFFF 		.word	-31250
 4872 00b4 851E0000 		.word	7813
 4873              		.cfi_endproc
 4874              	.LFE10:
 4876              		.section	.text.what_mcg_mode,"ax",%progbits
 4877              		.align	2
 4878              		.global	what_mcg_mode
 4879              		.code	16
 4880              		.thumb_func
 4882              	what_mcg_mode:
 4883              	.LFB26:
1854:../Sources/TFC/TFC_CrystalClock.c **** 
1855:../Sources/TFC/TFC_CrystalClock.c **** 
1856:../Sources/TFC/TFC_CrystalClock.c **** unsigned char what_mcg_mode(void)
1857:../Sources/TFC/TFC_CrystalClock.c **** {
 4884              		.loc 1 1857 0
 4885              		.cfi_startproc
 4886 0000 00B5     		push	{lr}
 4887              	.LCFI30:
 4888              		.cfi_def_cfa_offset 4
 4889              		.cfi_offset 14, -4
1858:../Sources/TFC/TFC_CrystalClock.c ****   // check if in FEI mode
1859:../Sources/TFC/TFC_CrystalClock.c ****   if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) &&      // check CLKS mux has selc
 4890              		.loc 1 1859 0
 4891 0002 3E4B     		ldr	r3, .L928
 4892 0004 9A79     		ldrb	r2, [r3, #6]
 4893 0006 1007     		lsl	r0, r2, #28
 4894 0008 810F     		lsr	r1, r0, #30
 4895 000a 02D1     		bne	.L887
1860:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                     // check FLL ref is intern
 4896              		.loc 1 1860 0
 4897 000c 9A79     		ldrb	r2, [r3, #6]
1859:../Sources/TFC/TFC_CrystalClock.c ****   if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) &&      // check CLKS mux has selc
 4898              		.loc 1 1859 0
 4899 000e D006     		lsl	r0, r2, #27
 4900 0010 33D4     		bmi	.L921
 4901              	.L887:
1861:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)))                                     // check PLLS mux has sele
1862:../Sources/TFC/TFC_CrystalClock.c ****   {
1863:../Sources/TFC/TFC_CrystalClock.c ****     return FEI;                                                          // return FEI code
1864:../Sources/TFC/TFC_CrystalClock.c ****   }
1865:../Sources/TFC/TFC_CrystalClock.c ****   // Check MCG is in PEE mode
1866:../Sources/TFC/TFC_CrystalClock.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selc
 4902              		.loc 1 1866 0
 4903 0012 3A49     		ldr	r1, .L928
 4904 0014 8879     		ldrb	r0, [r1, #6]
 4905 0016 0207     		lsl	r2, r0, #28
 4906 0018 930F     		lsr	r3, r2, #30
 4907 001a 032B     		cmp	r3, #3
 4908 001c 32D0     		beq	.L922
 4909              	.L889:
1867:../Sources/TFC/TFC_CrystalClock.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
1868:../Sources/TFC/TFC_CrystalClock.c ****           (MCG_S & MCG_S_PLLST_MASK))                                    // check PLLS mux has sele
1869:../Sources/TFC/TFC_CrystalClock.c ****   {
1870:../Sources/TFC/TFC_CrystalClock.c ****     return PEE;                                                          // return PEE code
1871:../Sources/TFC/TFC_CrystalClock.c ****   }
1872:../Sources/TFC/TFC_CrystalClock.c ****   // Check MCG is in PBE mode
1873:../Sources/TFC/TFC_CrystalClock.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selc
 4910              		.loc 1 1873 0
 4911 001e 374B     		ldr	r3, .L928
 4912 0020 9A79     		ldrb	r2, [r3, #6]
 4913 0022 1007     		lsl	r0, r2, #28
 4914 0024 820F     		lsr	r2, r0, #30
 4915 0026 022A     		cmp	r2, #2
 4916 0028 34D0     		beq	.L923
 4917              	.L890:
1874:../Sources/TFC/TFC_CrystalClock.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
1875:../Sources/TFC/TFC_CrystalClock.c ****           (MCG_S & MCG_S_PLLST_MASK) &&                                  // check PLLS mux has sele
1876:../Sources/TFC/TFC_CrystalClock.c ****           (!(MCG_C2 & MCG_C2_LP_MASK)))                                  // check MCG_C2[LP] bit is
1877:../Sources/TFC/TFC_CrystalClock.c ****   {
1878:../Sources/TFC/TFC_CrystalClock.c ****     return PBE;                                                          // return PBE code
1879:../Sources/TFC/TFC_CrystalClock.c ****   }
1880:../Sources/TFC/TFC_CrystalClock.c ****   // Check MCG is in FBE mode
1881:../Sources/TFC/TFC_CrystalClock.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selc
 4918              		.loc 1 1881 0
 4919 002a 344B     		ldr	r3, .L928
 4920 002c 9A79     		ldrb	r2, [r3, #6]
 4921 002e 1107     		lsl	r1, r2, #28
 4922 0030 8A0F     		lsr	r2, r1, #30
 4923 0032 022A     		cmp	r2, #2
 4924 0034 39D0     		beq	.L924
 4925              	.L891:
1882:../Sources/TFC/TFC_CrystalClock.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
1883:../Sources/TFC/TFC_CrystalClock.c ****           (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has sele
1884:../Sources/TFC/TFC_CrystalClock.c ****           (!(MCG_C2 & MCG_C2_LP_MASK)))                                  // check MCG_C2[LP] bit is
1885:../Sources/TFC/TFC_CrystalClock.c ****   {
1886:../Sources/TFC/TFC_CrystalClock.c ****     return FBE;                                                          // return FBE code
1887:../Sources/TFC/TFC_CrystalClock.c ****   }
1888:../Sources/TFC/TFC_CrystalClock.c ****   // Check MCG is in BLPE mode
1889:../Sources/TFC/TFC_CrystalClock.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selc
 4926              		.loc 1 1889 0
 4927 0036 314B     		ldr	r3, .L928
 4928 0038 9A79     		ldrb	r2, [r3, #6]
 4929 003a 1007     		lsl	r0, r2, #28
 4930 003c 820F     		lsr	r2, r0, #30
 4931 003e 022A     		cmp	r2, #2
 4932 0040 3ED0     		beq	.L925
 4933              	.L892:
1890:../Sources/TFC/TFC_CrystalClock.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
1891:../Sources/TFC/TFC_CrystalClock.c ****           (MCG_C2 & MCG_C2_LP_MASK))                                     // check MCG_C2[LP] bit is
1892:../Sources/TFC/TFC_CrystalClock.c ****   {
1893:../Sources/TFC/TFC_CrystalClock.c ****     return BLPE;                                                         // return BLPE code
1894:../Sources/TFC/TFC_CrystalClock.c ****   }
1895:../Sources/TFC/TFC_CrystalClock.c ****   // check if in BLPI mode
1896:../Sources/TFC/TFC_CrystalClock.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selc
 4934              		.loc 1 1896 0
 4935 0042 2E4B     		ldr	r3, .L928
 4936 0044 9879     		ldrb	r0, [r3, #6]
 4937 0046 0207     		lsl	r2, r0, #28
 4938 0048 910F     		lsr	r1, r2, #30
 4939 004a 0129     		cmp	r1, #1
 4940 004c 40D0     		beq	.L926
 4941              	.L893:
1897:../Sources/TFC/TFC_CrystalClock.c ****           (MCG_S & MCG_S_IREFST_MASK) &&                                 // check FLL ref is intern
1898:../Sources/TFC/TFC_CrystalClock.c ****           (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has sele
1899:../Sources/TFC/TFC_CrystalClock.c ****           (MCG_C2 & MCG_C2_LP_MASK))                                     // check LP bit is set
1900:../Sources/TFC/TFC_CrystalClock.c ****   {
1901:../Sources/TFC/TFC_CrystalClock.c ****     return BLPI;                                                         // return BLPI code
1902:../Sources/TFC/TFC_CrystalClock.c ****   }
1903:../Sources/TFC/TFC_CrystalClock.c ****   // check if in FBI mode
1904:../Sources/TFC/TFC_CrystalClock.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selc
 4942              		.loc 1 1904 0
 4943 004e 2B4B     		ldr	r3, .L928
 4944 0050 9979     		ldrb	r1, [r3, #6]
 4945 0052 0807     		lsl	r0, r1, #28
 4946 0054 820F     		lsr	r2, r0, #30
 4947 0056 012A     		cmp	r2, #1
 4948 0058 45D0     		beq	.L927
 4949              	.L894:
1905:../Sources/TFC/TFC_CrystalClock.c ****           (MCG_S & MCG_S_IREFST_MASK) &&                                 // check FLL ref is intern
1906:../Sources/TFC/TFC_CrystalClock.c ****           (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has sele
1907:../Sources/TFC/TFC_CrystalClock.c ****           (!(MCG_C2 & MCG_C2_LP_MASK)))                                  // check LP bit is clear
1908:../Sources/TFC/TFC_CrystalClock.c ****   {  
1909:../Sources/TFC/TFC_CrystalClock.c ****     return FBI;                                                          // return FBI code 
1910:../Sources/TFC/TFC_CrystalClock.c ****   }
1911:../Sources/TFC/TFC_CrystalClock.c ****   // Check MCG is in FEE mode
1912:../Sources/TFC/TFC_CrystalClock.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selc
 4950              		.loc 1 1912 0
 4951 005a 284B     		ldr	r3, .L928
1913:../Sources/TFC/TFC_CrystalClock.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
1914:../Sources/TFC/TFC_CrystalClock.c ****           (!(MCG_S & MCG_S_PLLST_MASK)))                                 // check PLLS mux has sele
1915:../Sources/TFC/TFC_CrystalClock.c ****   {
1916:../Sources/TFC/TFC_CrystalClock.c ****     return FEE;                                                          // return FEE code
1917:../Sources/TFC/TFC_CrystalClock.c ****   }
1918:../Sources/TFC/TFC_CrystalClock.c ****   else
1919:../Sources/TFC/TFC_CrystalClock.c ****   {
1920:../Sources/TFC/TFC_CrystalClock.c ****     return 0;                                                            // error condition
 4952              		.loc 1 1920 0
 4953 005c 0020     		mov	r0, #0
1912:../Sources/TFC/TFC_CrystalClock.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selc
 4954              		.loc 1 1912 0
 4955 005e 9A79     		ldrb	r2, [r3, #6]
 4956 0060 1107     		lsl	r1, r2, #28
 4957 0062 8A0F     		lsr	r2, r1, #30
 4958 0064 08D1     		bne	.L888
1913:../Sources/TFC/TFC_CrystalClock.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 4959              		.loc 1 1913 0
 4960 0066 9979     		ldrb	r1, [r3, #6]
1912:../Sources/TFC/TFC_CrystalClock.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selc
 4961              		.loc 1 1912 0
 4962 0068 C906     		lsl	r1, r1, #27
 4963 006a 05D4     		bmi	.L888
1914:../Sources/TFC/TFC_CrystalClock.c ****           (!(MCG_S & MCG_S_PLLST_MASK)))                                 // check PLLS mux has sele
 4964              		.loc 1 1914 0
 4965 006c 9B79     		ldrb	r3, [r3, #6]
1913:../Sources/TFC/TFC_CrystalClock.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 4966              		.loc 1 1913 0
 4967 006e 2020     		mov	r0, #32
 4968 0070 1840     		and	r0, r3
1916:../Sources/TFC/TFC_CrystalClock.c ****     return FEE;                                                          // return FEE code
 4969              		.loc 1 1916 0
 4970 0072 4342     		neg	r3, r0
 4971 0074 5841     		adc	r0, r0, r3
 4972 0076 8000     		lsl	r0, r0, #2
 4973              	.L888:
1921:../Sources/TFC/TFC_CrystalClock.c ****   }
1922:../Sources/TFC/TFC_CrystalClock.c **** } // what_mcg_mode
 4974              		.loc 1 1922 0
 4975              		@ sp needed for prologue
 4976 0078 00BD     		pop	{pc}
 4977              	.L921:
1861:../Sources/TFC/TFC_CrystalClock.c ****       (!(MCG_S & MCG_S_PLLST_MASK)))                                     // check PLLS mux has sele
 4978              		.loc 1 1861 0
 4979 007a 9B79     		ldrb	r3, [r3, #6]
1863:../Sources/TFC/TFC_CrystalClock.c ****     return FEI;                                                          // return FEI code
 4980              		.loc 1 1863 0
 4981 007c 0320     		mov	r0, #3
1860:../Sources/TFC/TFC_CrystalClock.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                     // check FLL ref is intern
 4982              		.loc 1 1860 0
 4983 007e 9906     		lsl	r1, r3, #26
 4984 0080 FAD5     		bpl	.L888
 4985 0082 C6E7     		b	.L887
 4986              	.L922:
1867:../Sources/TFC/TFC_CrystalClock.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 4987              		.loc 1 1867 0
 4988 0084 8879     		ldrb	r0, [r1, #6]
1866:../Sources/TFC/TFC_CrystalClock.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selc
 4989              		.loc 1 1866 0
 4990 0086 C006     		lsl	r0, r0, #27
 4991 0088 C9D4     		bmi	.L889
1868:../Sources/TFC/TFC_CrystalClock.c ****           (MCG_S & MCG_S_PLLST_MASK))                                    // check PLLS mux has sele
 4992              		.loc 1 1868 0
 4993 008a 8979     		ldrb	r1, [r1, #6]
1870:../Sources/TFC/TFC_CrystalClock.c ****     return PEE;                                                          // return PEE code
 4994              		.loc 1 1870 0
 4995 008c 0820     		mov	r0, #8
1867:../Sources/TFC/TFC_CrystalClock.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 4996              		.loc 1 1867 0
 4997 008e 8906     		lsl	r1, r1, #26
 4998 0090 F2D4     		bmi	.L888
 4999 0092 C4E7     		b	.L889
 5000              	.L923:
1874:../Sources/TFC/TFC_CrystalClock.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 5001              		.loc 1 1874 0
 5002 0094 9979     		ldrb	r1, [r3, #6]
1873:../Sources/TFC/TFC_CrystalClock.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selc
 5003              		.loc 1 1873 0
 5004 0096 C806     		lsl	r0, r1, #27
 5005 0098 C7D4     		bmi	.L890
1875:../Sources/TFC/TFC_CrystalClock.c ****           (MCG_S & MCG_S_PLLST_MASK) &&                                  // check PLLS mux has sele
 5006              		.loc 1 1875 0
 5007 009a 9879     		ldrb	r0, [r3, #6]
1874:../Sources/TFC/TFC_CrystalClock.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 5008              		.loc 1 1874 0
 5009 009c 8006     		lsl	r0, r0, #26
 5010 009e C4D5     		bpl	.L890
1876:../Sources/TFC/TFC_CrystalClock.c ****           (!(MCG_C2 & MCG_C2_LP_MASK)))                                  // check MCG_C2[LP] bit is
 5011              		.loc 1 1876 0
 5012 00a0 5B78     		ldrb	r3, [r3, #1]
1878:../Sources/TFC/TFC_CrystalClock.c ****     return PBE;                                                          // return PBE code
 5013              		.loc 1 1878 0
 5014 00a2 0720     		mov	r0, #7
1875:../Sources/TFC/TFC_CrystalClock.c ****           (MCG_S & MCG_S_PLLST_MASK) &&                                  // check PLLS mux has sele
 5015              		.loc 1 1875 0
 5016 00a4 1A42     		tst	r2, r3
 5017 00a6 E7D0     		beq	.L888
 5018 00a8 BFE7     		b	.L890
 5019              	.L924:
1882:../Sources/TFC/TFC_CrystalClock.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 5020              		.loc 1 1882 0
 5021 00aa 9879     		ldrb	r0, [r3, #6]
1881:../Sources/TFC/TFC_CrystalClock.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selc
 5022              		.loc 1 1881 0
 5023 00ac C006     		lsl	r0, r0, #27
 5024 00ae C2D4     		bmi	.L891
1883:../Sources/TFC/TFC_CrystalClock.c ****           (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has sele
 5025              		.loc 1 1883 0
 5026 00b0 9979     		ldrb	r1, [r3, #6]
1882:../Sources/TFC/TFC_CrystalClock.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 5027              		.loc 1 1882 0
 5028 00b2 8806     		lsl	r0, r1, #26
 5029 00b4 BFD4     		bmi	.L891
1884:../Sources/TFC/TFC_CrystalClock.c ****           (!(MCG_C2 & MCG_C2_LP_MASK)))                                  // check MCG_C2[LP] bit is
 5030              		.loc 1 1884 0
 5031 00b6 5B78     		ldrb	r3, [r3, #1]
1886:../Sources/TFC/TFC_CrystalClock.c ****     return FBE;                                                          // return FBE code
 5032              		.loc 1 1886 0
 5033 00b8 0520     		mov	r0, #5
1883:../Sources/TFC/TFC_CrystalClock.c ****           (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has sele
 5034              		.loc 1 1883 0
 5035 00ba 1A42     		tst	r2, r3
 5036 00bc DCD0     		beq	.L888
 5037 00be BAE7     		b	.L891
 5038              	.L925:
1890:../Sources/TFC/TFC_CrystalClock.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 5039              		.loc 1 1890 0
 5040 00c0 9979     		ldrb	r1, [r3, #6]
1889:../Sources/TFC/TFC_CrystalClock.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selc
 5041              		.loc 1 1889 0
 5042 00c2 C806     		lsl	r0, r1, #27
 5043 00c4 BDD4     		bmi	.L892
1891:../Sources/TFC/TFC_CrystalClock.c ****           (MCG_C2 & MCG_C2_LP_MASK))                                     // check MCG_C2[LP] bit is
 5044              		.loc 1 1891 0
 5045 00c6 5B78     		ldrb	r3, [r3, #1]
1893:../Sources/TFC/TFC_CrystalClock.c ****     return BLPE;                                                         // return BLPE code
 5046              		.loc 1 1893 0
 5047 00c8 0620     		mov	r0, #6
1890:../Sources/TFC/TFC_CrystalClock.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 5048              		.loc 1 1890 0
 5049 00ca 1A42     		tst	r2, r3
 5050 00cc D4D1     		bne	.L888
 5051 00ce B8E7     		b	.L892
 5052              	.L926:
1897:../Sources/TFC/TFC_CrystalClock.c ****           (MCG_S & MCG_S_IREFST_MASK) &&                                 // check FLL ref is intern
 5053              		.loc 1 1897 0
 5054 00d0 9879     		ldrb	r0, [r3, #6]
1896:../Sources/TFC/TFC_CrystalClock.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selc
 5055              		.loc 1 1896 0
 5056 00d2 C106     		lsl	r1, r0, #27
 5057 00d4 BBD5     		bpl	.L893
1898:../Sources/TFC/TFC_CrystalClock.c ****           (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has sele
 5058              		.loc 1 1898 0
 5059 00d6 9A79     		ldrb	r2, [r3, #6]
1897:../Sources/TFC/TFC_CrystalClock.c ****           (MCG_S & MCG_S_IREFST_MASK) &&                                 // check FLL ref is intern
 5060              		.loc 1 1897 0
 5061 00d8 9006     		lsl	r0, r2, #26
 5062 00da B8D4     		bmi	.L893
1899:../Sources/TFC/TFC_CrystalClock.c ****           (MCG_C2 & MCG_C2_LP_MASK))                                     // check LP bit is set
 5063              		.loc 1 1899 0
 5064 00dc 5B78     		ldrb	r3, [r3, #1]
1901:../Sources/TFC/TFC_CrystalClock.c ****     return BLPI;                                                         // return BLPI code
 5065              		.loc 1 1901 0
 5066 00de 0120     		mov	r0, #1
1898:../Sources/TFC/TFC_CrystalClock.c ****           (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has sele
 5067              		.loc 1 1898 0
 5068 00e0 9907     		lsl	r1, r3, #30
 5069 00e2 B4D5     		bpl	.L893
 5070 00e4 C8E7     		b	.L888
 5071              	.L927:
1905:../Sources/TFC/TFC_CrystalClock.c ****           (MCG_S & MCG_S_IREFST_MASK) &&                                 // check FLL ref is intern
 5072              		.loc 1 1905 0
 5073 00e6 9979     		ldrb	r1, [r3, #6]
1904:../Sources/TFC/TFC_CrystalClock.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selc
 5074              		.loc 1 1904 0
 5075 00e8 C806     		lsl	r0, r1, #27
 5076 00ea B6D5     		bpl	.L894
1906:../Sources/TFC/TFC_CrystalClock.c ****           (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has sele
 5077              		.loc 1 1906 0
 5078 00ec 9879     		ldrb	r0, [r3, #6]
1905:../Sources/TFC/TFC_CrystalClock.c ****           (MCG_S & MCG_S_IREFST_MASK) &&                                 // check FLL ref is intern
 5079              		.loc 1 1905 0
 5080 00ee 8106     		lsl	r1, r0, #26
 5081 00f0 B3D4     		bmi	.L894
1907:../Sources/TFC/TFC_CrystalClock.c ****           (!(MCG_C2 & MCG_C2_LP_MASK)))                                  // check LP bit is clear
 5082              		.loc 1 1907 0
 5083 00f2 5B78     		ldrb	r3, [r3, #1]
1909:../Sources/TFC/TFC_CrystalClock.c ****     return FBI;                                                          // return FBI code 
 5084              		.loc 1 1909 0
 5085 00f4 0220     		mov	r0, #2
1906:../Sources/TFC/TFC_CrystalClock.c ****           (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has sele
 5086              		.loc 1 1906 0
 5087 00f6 9A07     		lsl	r2, r3, #30
 5088 00f8 BED5     		bpl	.L888
 5089 00fa AEE7     		b	.L894
 5090              	.L929:
 5091              		.align	2
 5092              	.L928:
 5093 00fc 00400640 		.word	1074151424
 5094              		.cfi_endproc
 5095              	.LFE26:
 5097              		.global	__aeabi_uidiv
 5098              		.global	__aeabi_i2f
 5099              		.global	__aeabi_fdiv
 5100              		.global	__aeabi_fmul
 5101              		.global	__aeabi_f2uiz
 5102              		.section	.text.atc,"ax",%progbits
 5103              		.align	2
 5104              		.global	atc
 5105              		.code	16
 5106              		.thumb_func
 5108              	atc:
 5109              	.LFB24:
1680:../Sources/TFC/TFC_CrystalClock.c **** {
 5110              		.loc 1 1680 0
 5111              		.cfi_startproc
 5112              	.LVL442:
 5113 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 5114              	.LCFI31:
 5115              		.cfi_def_cfa_offset 20
 5116              		.cfi_offset 4, -20
 5117              		.cfi_offset 5, -16
 5118              		.cfi_offset 6, -12
 5119              		.cfi_offset 7, -8
 5120              		.cfi_offset 14, -4
 5121 0002 5746     		mov	r7, sl
 5122 0004 4E46     		mov	r6, r9
 5123 0006 4546     		mov	r5, r8
 5124 0008 E0B4     		push	{r5, r6, r7}
 5125              	.LCFI32:
 5126              		.cfi_def_cfa_offset 32
 5127              		.cfi_offset 8, -32
 5128              		.cfi_offset 9, -28
 5129              		.cfi_offset 10, -24
1680:../Sources/TFC/TFC_CrystalClock.c **** {
 5130              		.loc 1 1680 0
 5131 000a 8046     		mov	r8, r0
 5132              	.LVL443:
 5133 000c 161C     		mov	r6, r2
 5134 000e 0F1C     		mov	r7, r1
1693:../Sources/TFC/TFC_CrystalClock.c ****   mcg_mode = what_mcg_mode(); // get present MCG mode
 5135              		.loc 1 1693 0
 5136 0010 FFF7FEFF 		bl	what_mcg_mode
 5137              	.LVL444:
1694:../Sources/TFC/TFC_CrystalClock.c ****   if ((mcg_mode != PEE) && (mcg_mode != PBE) && (mcg_mode != FBE))
 5138              		.loc 1 1694 0
 5139 0014 C21F     		sub	r2, r0, #7
1693:../Sources/TFC/TFC_CrystalClock.c ****   mcg_mode = what_mcg_mode(); // get present MCG mode
 5140              		.loc 1 1693 0
 5141 0016 031C     		mov	r3, r0
 5142              	.LVL445:
1694:../Sources/TFC/TFC_CrystalClock.c ****   if ((mcg_mode != PEE) && (mcg_mode != PBE) && (mcg_mode != FBE))
 5143              		.loc 1 1694 0
 5144 0018 D0B2     		uxtb	r0, r2
 5145              	.LVL446:
 5146 001a 0128     		cmp	r0, #1
 5147 001c 07D9     		bls	.L931
1696:../Sources/TFC/TFC_CrystalClock.c ****     return 1; // return error code if not in PEE, PBE or FBE modes
 5148              		.loc 1 1696 0
 5149 001e 0120     		mov	r0, #1
1694:../Sources/TFC/TFC_CrystalClock.c ****   if ((mcg_mode != PEE) && (mcg_mode != PBE) && (mcg_mode != FBE))
 5150              		.loc 1 1694 0
 5151 0020 052B     		cmp	r3, #5
 5152 0022 04D0     		beq	.L931
 5153              	.LVL447:
 5154              	.L932:
1785:../Sources/TFC/TFC_CrystalClock.c **** }// atc
 5155              		.loc 1 1785 0
 5156              		@ sp needed for prologue
 5157              	.LVL448:
 5158 0024 1CBC     		pop	{r2, r3, r4}
 5159 0026 9046     		mov	r8, r2
 5160 0028 9946     		mov	r9, r3
 5161 002a A246     		mov	sl, r4
 5162 002c F0BD     		pop	{r4, r5, r6, r7, pc}
 5163              	.LVL449:
 5164              	.L931:
1699:../Sources/TFC/TFC_CrystalClock.c ****   orig_div = SIM_CLKDIV1; //store present clock divider values
 5165              		.loc 1 1699 0
 5166 002e 534D     		ldr	r5, .L954
 5167 0030 534C     		ldr	r4, .L954+4
1701:../Sources/TFC/TFC_CrystalClock.c ****   bus_clk_div_val = mcg_out_freq / 16000000; // calculate bus clock divider to generate fastest all
 5168              		.loc 1 1701 0
 5169 0032 301C     		mov	r0, r6
1699:../Sources/TFC/TFC_CrystalClock.c ****   orig_div = SIM_CLKDIV1; //store present clock divider values
 5170              		.loc 1 1699 0
 5171 0034 2959     		ldr	r1, [r5, r4]
1702:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = SIM_CLKDIV1;
 5172              		.loc 1 1702 0
 5173 0036 2B59     		ldr	r3, [r5, r4]
 5174              	.LVL450:
1699:../Sources/TFC/TFC_CrystalClock.c ****   orig_div = SIM_CLKDIV1; //store present clock divider values
 5175              		.loc 1 1699 0
 5176 0038 8A46     		mov	sl, r1
 5177              	.LVL451:
1701:../Sources/TFC/TFC_CrystalClock.c ****   bus_clk_div_val = mcg_out_freq / 16000000; // calculate bus clock divider to generate fastest all
 5178              		.loc 1 1701 0
 5179 003a 5249     		ldr	r1, .L954+8
 5180              	.LVL452:
1702:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = SIM_CLKDIV1;
 5181              		.loc 1 1702 0
 5182 003c 9946     		mov	r9, r3
 5183              	.LVL453:
1701:../Sources/TFC/TFC_CrystalClock.c ****   bus_clk_div_val = mcg_out_freq / 16000000; // calculate bus clock divider to generate fastest all
 5184              		.loc 1 1701 0
 5185 003e FFF7FEFF 		bl	__aeabi_idiv
 5186              	.LVL454:
1703:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~SIM_CLKDIV1_OUTDIV4_MASK; // clear dividers except core
 5187              		.loc 1 1703 0
 5188 0042 514B     		ldr	r3, .L954+12
1705:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= SIM_CLKDIV1_OUTDIV4(bus_clk_div_val);
 5189              		.loc 1 1705 0
 5190 0044 0204     		lsl	r2, r0, #16
 5191 0046 E020     		mov	r0, #224
 5192 0048 C102     		lsl	r1, r0, #11
1703:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg &= ~SIM_CLKDIV1_OUTDIV4_MASK; // clear dividers except core
 5193              		.loc 1 1703 0
 5194 004a 4846     		mov	r0, r9
 5195 004c 0340     		and	r3, r0
 5196              	.LVL455:
1705:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg |= SIM_CLKDIV1_OUTDIV4(bus_clk_div_val);
 5197              		.loc 1 1705 0
 5198 004e 0A40     		and	r2, r1
 5199 0050 1A43     		orr	r2, r3
 5200              	.LVL456:
1706:../Sources/TFC/TFC_CrystalClock.c ****   SIM_CLKDIV1 = temp_reg; // set actual dividers
 5201              		.loc 1 1706 0
 5202 0052 2A51     		str	r2, [r5, r4]
1708:../Sources/TFC/TFC_CrystalClock.c ****   bus_clock_freq = mcg_out_freq / (((SIM_CLKDIV1) >> 16)+ 1);//For KL25, flash and bus use the same
 5203              		.loc 1 1708 0
 5204 0054 2A59     		ldr	r2, [r5, r4]
 5205              	.LVL457:
 5206 0056 301C     		mov	r0, r6
 5207 0058 110C     		lsr	r1, r2, #16
 5208 005a 0131     		add	r1, r1, #1
 5209 005c FFF7FEFF 		bl	__aeabi_uidiv
 5210              	.LVL458:
1709:../Sources/TFC/TFC_CrystalClock.c ****   if ((bus_clock_freq < 8000000) || (bus_clock_freq > 16000000))
 5211              		.loc 1 1709 0
 5212 0060 4A4E     		ldr	r6, .L954+16
 5213              	.LVL459:
 5214 0062 4B4B     		ldr	r3, .L954+20
 5215 0064 8119     		add	r1, r0, r6
 5216 0066 9942     		cmp	r1, r3
 5217 0068 03D9     		bls	.L933
1711:../Sources/TFC/TFC_CrystalClock.c ****     SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 5218              		.loc 1 1711 0
 5219 006a 5346     		mov	r3, sl
 5220 006c 2B51     		str	r3, [r5, r4]
1712:../Sources/TFC/TFC_CrystalClock.c ****     return 3; // error, bus clock frequency is not within 8MHz to 16MHz
 5221              		.loc 1 1712 0
 5222 006e 0320     		mov	r0, #3
 5223              	.LVL460:
 5224 0070 D8E7     		b	.L932
 5225              	.LVL461:
 5226              	.L933:
1688:../Sources/TFC/TFC_CrystalClock.c ****   if (irc_select > 0) // force irc to 1 if greater than 0
 5227              		.loc 1 1688 0
 5228 0072 4646     		mov	r6, r8
 5229 0074 731E     		sub	r3, r6, #1
 5230 0076 9E41     		sbc	r6, r6, r3
1715:../Sources/TFC/TFC_CrystalClock.c ****   if(!irc_select) //determine if slow or fast IRC to be trimmed
 5231              		.loc 1 1715 0
 5232 0078 002E     		cmp	r6, #0
 5233 007a 06D1     		bne	.L934
1717:../Sources/TFC/TFC_CrystalClock.c ****     if (irc_freq < 31250) // check frequency is above min spec.
 5234              		.loc 1 1717 0
 5235 007c 454A     		ldr	r2, .L954+24
 5236 007e 9742     		cmp	r7, r2
 5237 0080 0ADC     		bgt	.L935
1719:../Sources/TFC/TFC_CrystalClock.c ****       SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 5238              		.loc 1 1719 0
 5239 0082 5046     		mov	r0, sl
 5240              	.LVL462:
 5241 0084 2851     		str	r0, [r5, r4]
1720:../Sources/TFC/TFC_CrystalClock.c ****       return 4;
 5242              		.loc 1 1720 0
 5243 0086 0420     		mov	r0, #4
 5244 0088 CCE7     		b	.L932
 5245              	.LVL463:
 5246              	.L934:
1730:../Sources/TFC/TFC_CrystalClock.c ****     if (irc_freq < 3000000) // check frequency is above min spec.
 5247              		.loc 1 1730 0
 5248 008a 434A     		ldr	r2, .L954+28
 5249 008c 9742     		cmp	r7, r2
 5250 008e 0ADC     		bgt	.L937
1732:../Sources/TFC/TFC_CrystalClock.c ****       SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 5251              		.loc 1 1732 0
 5252 0090 5346     		mov	r3, sl
 5253 0092 2B51     		str	r3, [r5, r4]
1733:../Sources/TFC/TFC_CrystalClock.c ****       return 6;
 5254              		.loc 1 1733 0
 5255 0094 0620     		mov	r0, #6
 5256              	.LVL464:
 5257 0096 C5E7     		b	.L932
 5258              	.LVL465:
 5259              	.L935:
1722:../Sources/TFC/TFC_CrystalClock.c ****     if (irc_freq > 39062) // check frequency is below max spec.
 5260              		.loc 1 1722 0
 5261 0098 4049     		ldr	r1, .L954+32
 5262 009a 8F42     		cmp	r7, r1
 5263 009c 0ADD     		ble	.L936
1724:../Sources/TFC/TFC_CrystalClock.c ****       SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 5264              		.loc 1 1724 0
 5265 009e 5746     		mov	r7, sl
 5266              	.LVL466:
 5267 00a0 2F51     		str	r7, [r5, r4]
1725:../Sources/TFC/TFC_CrystalClock.c ****       return 5;
 5268              		.loc 1 1725 0
 5269 00a2 0520     		mov	r0, #5
 5270              	.LVL467:
 5271 00a4 BEE7     		b	.L932
 5272              	.LVL468:
 5273              	.L937:
1735:../Sources/TFC/TFC_CrystalClock.c ****     if (irc_freq > 5000000) // check frequency is below max spec.
 5274              		.loc 1 1735 0
 5275 00a6 3E49     		ldr	r1, .L954+36
 5276 00a8 8F42     		cmp	r7, r1
 5277 00aa 30DD     		ble	.L938
1737:../Sources/TFC/TFC_CrystalClock.c ****       SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 5278              		.loc 1 1737 0
 5279 00ac 5046     		mov	r0, sl
 5280              	.LVL469:
 5281 00ae 2851     		str	r0, [r5, r4]
1738:../Sources/TFC/TFC_CrystalClock.c ****       return 7;
 5282              		.loc 1 1738 0
 5283 00b0 0720     		mov	r0, #7
 5284 00b2 B7E7     		b	.L932
 5285              	.LVL470:
 5286              	.L936:
1746:../Sources/TFC/TFC_CrystalClock.c ****     atcv = (unsigned short)(21.0f * (bus_clock_freq / (float)irc_freq));
 5287              		.loc 1 1746 0
 5288 00b4 FFF7FEFF 		bl	__aeabi_i2f
 5289              	.LVL471:
 5290 00b8 041C     		add	r4, r0, #0
 5291 00ba 381C     		mov	r0, r7
 5292 00bc FFF7FEFF 		bl	__aeabi_i2f
 5293              	.LVL472:
 5294 00c0 011C     		add	r1, r0, #0
 5295 00c2 201C     		add	r0, r4, #0
 5296 00c4 FFF7FEFF 		bl	__aeabi_fdiv
 5297              	.LVL473:
 5298 00c8 3649     		ldr	r1, .L954+40
 5299 00ca FFF7FEFF 		bl	__aeabi_fmul
 5300              	.LVL474:
 5301 00ce FFF7FEFF 		bl	__aeabi_f2uiz
 5302              	.LVL475:
 5303 00d2 85B2     		uxth	r5, r0
 5304              	.LVL476:
 5305              	.L939:
1748:../Sources/TFC/TFC_CrystalClock.c ****   MCG_ATCVL = (atcv & 0xFF); //Set ATCVL to lower 8 bits of count value
 5306              		.loc 1 1748 0
 5307 00d4 3449     		ldr	r1, .L954+44
 5308 00d6 EFB2     		uxtb	r7, r5
1749:../Sources/TFC/TFC_CrystalClock.c ****   MCG_ATCVH = ((atcv & 0xFF00) >> 8); // Set ATCVH to upper 8 bits of count value
 5309              		.loc 1 1749 0
 5310 00d8 280A     		lsr	r0, r5, #8
1748:../Sources/TFC/TFC_CrystalClock.c ****   MCG_ATCVL = (atcv & 0xFF); //Set ATCVL to lower 8 bits of count value
 5311              		.loc 1 1748 0
 5312 00da CF72     		strb	r7, [r1, #11]
1749:../Sources/TFC/TFC_CrystalClock.c ****   MCG_ATCVH = ((atcv & 0xFF00) >> 8); // Set ATCVH to upper 8 bits of count value
 5313              		.loc 1 1749 0
 5314 00dc 8872     		strb	r0, [r1, #10]
1752:../Sources/TFC/TFC_CrystalClock.c ****   MCG_SC &= ~(MCG_SC_ATME_MASK | MCG_SC_ATMS_MASK |MCG_SC_ATMF_MASK); // clear auto trim settings
 5315              		.loc 1 1752 0
 5316 00de 0B7A     		ldrb	r3, [r1, #8]
 5317 00e0 1F22     		mov	r2, #31
 5318 00e2 1340     		and	r3, r2
 5319 00e4 0B72     		strb	r3, [r1, #8]
1754:../Sources/TFC/TFC_CrystalClock.c ****   MCG_SC |= temp_reg;
 5320              		.loc 1 1754 0
 5321 00e6 0C7A     		ldrb	r4, [r1, #8]
1753:../Sources/TFC/TFC_CrystalClock.c ****   temp_reg = (MCG_SC_ATME_MASK | (irc_select << MCG_SC_ATMS_SHIFT)); //Select IRC to trim and enabl
 5322              		.loc 1 1753 0
 5323 00e8 B501     		lsl	r5, r6, #6
 5324              	.LVL477:
 5325 00ea 8027     		mov	r7, #128
 5326 00ec 2F43     		orr	r7, r5
1754:../Sources/TFC/TFC_CrystalClock.c ****   MCG_SC |= temp_reg;
 5327              		.loc 1 1754 0
 5328 00ee 2743     		orr	r7, r4
 5329 00f0 0F72     		strb	r7, [r1, #8]
 5330              	.L940:
1756:../Sources/TFC/TFC_CrystalClock.c ****   while (MCG_SC & MCG_SC_ATME_MASK) {}; //poll for ATME bit to clear
 5331              		.loc 1 1756 0
 5332 00f2 0B7A     		ldrb	r3, [r1, #8]
 5333 00f4 2C48     		ldr	r0, .L954+44
 5334 00f6 5AB2     		sxtb	r2, r3
 5335 00f8 002A     		cmp	r2, #0
 5336 00fa FADB     		blt	.L940
1758:../Sources/TFC/TFC_CrystalClock.c ****   if (MCG_SC & MCG_SC_ATMF_MASK) // check if error flag set
 5337              		.loc 1 1758 0
 5338 00fc 017A     		ldrb	r1, [r0, #8]
 5339 00fe 8906     		lsl	r1, r1, #26
 5340 0100 1AD5     		bpl	.L941
1760:../Sources/TFC/TFC_CrystalClock.c ****     SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 5341              		.loc 1 1760 0
 5342 0102 1F4E     		ldr	r6, .L954+4
 5343 0104 1D4A     		ldr	r2, .L954
 5344 0106 5146     		mov	r1, sl
 5345 0108 9151     		str	r1, [r2, r6]
1761:../Sources/TFC/TFC_CrystalClock.c ****     return 8;
 5346              		.loc 1 1761 0
 5347 010a 0820     		mov	r0, #8
 5348 010c 8AE7     		b	.L932
 5349              	.LVL478:
 5350              	.L938:
1744:../Sources/TFC/TFC_CrystalClock.c ****     atcv = (unsigned short)(128.0f * (21.0f * (bus_clock_freq / (float)irc_freq)));
 5351              		.loc 1 1744 0
 5352 010e FFF7FEFF 		bl	__aeabi_i2f
 5353              	.LVL479:
 5354 0112 051C     		add	r5, r0, #0
 5355 0114 381C     		mov	r0, r7
 5356 0116 FFF7FEFF 		bl	__aeabi_i2f
 5357              	.LVL480:
 5358 011a 011C     		add	r1, r0, #0
 5359 011c 281C     		add	r0, r5, #0
 5360 011e FFF7FEFF 		bl	__aeabi_fdiv
 5361              	.LVL481:
 5362 0122 8627     		mov	r7, #134
 5363              	.LVL482:
 5364 0124 1F49     		ldr	r1, .L954+40
 5365 0126 FFF7FEFF 		bl	__aeabi_fmul
 5366              	.LVL483:
 5367 012a F905     		lsl	r1, r7, #23
 5368 012c FFF7FEFF 		bl	__aeabi_fmul
 5369              	.LVL484:
 5370 0130 FFF7FEFF 		bl	__aeabi_f2uiz
 5371              	.LVL485:
 5372 0134 85B2     		uxth	r5, r0
 5373              	.LVL486:
 5374 0136 CDE7     		b	.L939
 5375              	.LVL487:
 5376              	.L941:
1765:../Sources/TFC/TFC_CrystalClock.c ****     if (!irc_select)
 5377              		.loc 1 1765 0
 5378 0138 002E     		cmp	r6, #0
 5379 013a 0BD1     		bne	.L942
1767:../Sources/TFC/TFC_CrystalClock.c ****       if ((MCG_C3 == 0xFF) || (MCG_C3 == 0))
 5380              		.loc 1 1767 0
 5381 013c 8278     		ldrb	r2, [r0, #2]
 5382 013e FF2A     		cmp	r2, #255
 5383 0140 02D0     		beq	.L943
1767:../Sources/TFC/TFC_CrystalClock.c ****       if ((MCG_C3 == 0xFF) || (MCG_C3 == 0))
 5384              		.loc 1 1767 0 is_stmt 0
 5385 0142 8178     		ldrb	r1, [r0, #2]
 5386 0144 0029     		cmp	r1, #0
 5387 0146 13D1     		bne	.L944
 5388              	.L943:
1769:../Sources/TFC/TFC_CrystalClock.c ****         SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 5389              		.loc 1 1769 0 is_stmt 1
 5390 0148 0C48     		ldr	r0, .L954
 5391 014a 0D4F     		ldr	r7, .L954+4
 5392 014c 5346     		mov	r3, sl
 5393 014e C351     		str	r3, [r0, r7]
1770:../Sources/TFC/TFC_CrystalClock.c ****         return 9;
 5394              		.loc 1 1770 0
 5395 0150 0920     		mov	r0, #9
 5396 0152 67E7     		b	.L932
 5397              	.L942:
1775:../Sources/TFC/TFC_CrystalClock.c ****       if ((((MCG_C4 & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT) == 0xF) ||
 5398              		.loc 1 1775 0
 5399 0154 C678     		ldrb	r6, [r0, #3]
 5400 0156 1E24     		mov	r4, #30
 5401 0158 2640     		and	r6, r4
 5402 015a 1E2E     		cmp	r6, #30
 5403 015c 02D0     		beq	.L945
1776:../Sources/TFC/TFC_CrystalClock.c ****           (((MCG_C4 & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT) == 0))
 5404              		.loc 1 1776 0
 5405 015e C578     		ldrb	r5, [r0, #3]
1775:../Sources/TFC/TFC_CrystalClock.c ****       if ((((MCG_C4 & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT) == 0xF) ||
 5406              		.loc 1 1775 0
 5407 0160 2C42     		tst	r4, r5
 5408 0162 05D1     		bne	.L944
 5409              	.L945:
1778:../Sources/TFC/TFC_CrystalClock.c ****         SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 5410              		.loc 1 1778 0
 5411 0164 0548     		ldr	r0, .L954
 5412 0166 064F     		ldr	r7, .L954+4
 5413 0168 5346     		mov	r3, sl
 5414 016a C351     		str	r3, [r0, r7]
1779:../Sources/TFC/TFC_CrystalClock.c ****         return 10;
 5415              		.loc 1 1779 0
 5416 016c 0A20     		mov	r0, #10
 5417 016e 59E7     		b	.L932
 5418              	.L944:
1783:../Sources/TFC/TFC_CrystalClock.c ****   SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 5419              		.loc 1 1783 0
 5420 0170 034E     		ldr	r6, .L954+4
 5421 0172 024C     		ldr	r4, .L954
 5422 0174 5546     		mov	r5, sl
 5423 0176 A551     		str	r5, [r4, r6]
1784:../Sources/TFC/TFC_CrystalClock.c ****   return 0;
 5424              		.loc 1 1784 0
 5425 0178 0020     		mov	r0, #0
 5426 017a 53E7     		b	.L932
 5427              	.L955:
 5428              		.align	2
 5429              	.L954:
 5430 017c 00700440 		.word	1074032640
 5431 0180 44100000 		.word	4164
 5432 0184 0024F400 		.word	16000000
 5433 0188 FFFFF8FF 		.word	-458753
 5434 018c 00EE85FF 		.word	-8000000
 5435 0190 00127A00 		.word	8000000
 5436 0194 117A0000 		.word	31249
 5437 0198 BFC62D00 		.word	2999999
 5438 019c 96980000 		.word	39062
 5439 01a0 404B4C00 		.word	5000000
 5440 01a4 0000A841 		.word	1101529088
 5441 01a8 00400640 		.word	1074151424
 5442              		.cfi_endproc
 5443              	.LFE24:
 5445              		.section	.text.clk_monitor_0,"ax",%progbits
 5446              		.align	2
 5447              		.global	clk_monitor_0
 5448              		.code	16
 5449              		.thumb_func
 5451              	clk_monitor_0:
 5452              	.LFB27:
1923:../Sources/TFC/TFC_CrystalClock.c **** 
1924:../Sources/TFC/TFC_CrystalClock.c **** 
1925:../Sources/TFC/TFC_CrystalClock.c **** /********************************************************************/
1926:../Sources/TFC/TFC_CrystalClock.c **** /* Functon name : clk_monitor_0
1927:../Sources/TFC/TFC_CrystalClock.c ****  *
1928:../Sources/TFC/TFC_CrystalClock.c ****  * This function simply enables or disables the OSC 0 clock monitor. This is
1929:../Sources/TFC/TFC_CrystalClock.c ****  * achieved by setting or clearing the MCG_C6[CME] bit. It is recommended to  
1930:../Sources/TFC/TFC_CrystalClock.c ****  * enable this monitor in external clock modes (FEE, FBE, BLPE, PBE and PEE.
1931:../Sources/TFC/TFC_CrystalClock.c ****  * It MUST be disabled in all other modes or a reset may be generated. It must
1932:../Sources/TFC/TFC_CrystalClock.c ****  * also be disabled if it is desired to enter VLPR from BLPE mode.
1933:../Sources/TFC/TFC_CrystalClock.c ****  *
1934:../Sources/TFC/TFC_CrystalClock.c ****  * Parameters: en_dis - enables (= 1) or disables (= 0) the OSC 0 clock monitor
1935:../Sources/TFC/TFC_CrystalClock.c ****  *
1936:../Sources/TFC/TFC_CrystalClock.c ****  * Return value : none
1937:../Sources/TFC/TFC_CrystalClock.c ****  */
1938:../Sources/TFC/TFC_CrystalClock.c **** void clk_monitor_0(unsigned char en_dis)
1939:../Sources/TFC/TFC_CrystalClock.c **** {         
 5453              		.loc 1 1939 0
 5454              		.cfi_startproc
 5455              	.LVL488:
 5456 0000 00B5     		push	{lr}
 5457              	.LCFI33:
 5458              		.cfi_def_cfa_offset 4
 5459              		.cfi_offset 14, -4
1940:../Sources/TFC/TFC_CrystalClock.c ****   if (en_dis)
1941:../Sources/TFC/TFC_CrystalClock.c ****   {
1942:../Sources/TFC/TFC_CrystalClock.c ****     MCG_C6 |= MCG_C6_CME0_MASK;   
 5460              		.loc 1 1942 0
 5461 0002 064B     		ldr	r3, .L960
1940:../Sources/TFC/TFC_CrystalClock.c ****   if (en_dis)
 5462              		.loc 1 1940 0
 5463 0004 0028     		cmp	r0, #0
 5464 0006 04D1     		bne	.L959
1943:../Sources/TFC/TFC_CrystalClock.c ****   }
1944:../Sources/TFC/TFC_CrystalClock.c ****   else
1945:../Sources/TFC/TFC_CrystalClock.c ****   {
1946:../Sources/TFC/TFC_CrystalClock.c ****     MCG_C6 &= ~MCG_C6_CME0_MASK;
 5465              		.loc 1 1946 0
 5466 0008 5A79     		ldrb	r2, [r3, #5]
 5467 000a 2021     		mov	r1, #32
 5468 000c 8A43     		bic	r2, r1
 5469 000e 5A71     		strb	r2, [r3, #5]
 5470              	.LVL489:
 5471              	.L956:
1947:../Sources/TFC/TFC_CrystalClock.c ****   }
1948:../Sources/TFC/TFC_CrystalClock.c **** }    // end clk_monitor_0
 5472              		.loc 1 1948 0
 5473              		@ sp needed for prologue
 5474 0010 00BD     		pop	{pc}
 5475              	.LVL490:
 5476              	.L959:
1942:../Sources/TFC/TFC_CrystalClock.c ****     MCG_C6 |= MCG_C6_CME0_MASK;   
 5477              		.loc 1 1942 0
 5478 0012 5879     		ldrb	r0, [r3, #5]
 5479              	.LVL491:
 5480 0014 2022     		mov	r2, #32
 5481 0016 0243     		orr	r2, r0
 5482 0018 5A71     		strb	r2, [r3, #5]
 5483 001a F9E7     		b	.L956
 5484              	.L961:
 5485              		.align	2
 5486              	.L960:
 5487 001c 00400640 		.word	1074151424
 5488              		.cfi_endproc
 5489              	.LFE27:
 5491              		.comm	dmx32_val,1,1
 5492              		.comm	drs_val,1,1
 5493              		.text
 5494              	.Letext0:
 5495              		.file 2 "C:/Freescale/CW MCU v10.6/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 5496              		.file 3 "C:/Users/bentr_000/Desktop/FreescaleCup2016Group2/Project_Headers/MKL25Z4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 TFC_CrystalClock.c
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:18     .text.fll_freq.part.0:00000000 $t
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:22     .text.fll_freq.part.0:00000000 fll_freq.part.0
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:218    .text.fll_freq.part.0:000000c0 $d
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:234    .text.pll_init:00000000 $t
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:239    .text.pll_init:00000000 pll_init
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:733    .text.pll_init:00000254 $d
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:753    .text.TFC_InitClock:00000000 $t
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:758    .text.TFC_InitClock:00000000 TFC_InitClock
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:789    .text.TFC_InitClock:0000001c $d
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:794    .text.pee_pbe:00000000 $t
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:799    .text.pee_pbe:00000000 pee_pbe
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:880    .text.pee_pbe:0000005c $d
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:885    .text.pbe_pee:00000000 $t
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:890    .text.pbe_pee:00000000 pbe_pee
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:1030   .text.pbe_pee:000000a8 $d
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:1035   .text.pbe_fbe:00000000 $t
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:1040   .text.pbe_fbe:00000000 pbe_fbe
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:1124   .text.pbe_fbe:00000058 $d
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:1129   .text.fbe_pbe:00000000 $t
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:1134   .text.fbe_pbe:00000000 fbe_pbe
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:1337   .text.fbe_pbe:000000dc $d
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:1346   .text.pbe_blpe:00000000 $t
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:1351   .text.pbe_blpe:00000000 pbe_blpe
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:1403   .text.pbe_blpe:00000030 $d
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:1408   .text.blpe_pbe:00000000 $t
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:1413   .text.blpe_pbe:00000000 blpe_pbe
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:1602   .text.blpe_pbe:000000d0 $d
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:1609   .text.blpe_fbe:00000000 $t
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:1614   .text.blpe_fbe:00000000 blpe_fbe
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:1695   .text.blpe_fbe:00000058 $d
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:1700   .text.fbe_blpe:00000000 $t
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:1705   .text.fbe_blpe:00000000 fbe_blpe
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:1757   .text.fbe_blpe:00000030 $d
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:1762   .text.fei_fbe:00000000 $t
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:1767   .text.fei_fbe:00000000 fei_fbe
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:2087   .text.fei_fbe:00000174 $d
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:2106   .text.fbe_fee:00000000 $t
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:2111   .text.fbe_fee:00000000 fbe_fee
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:2246   .text.fbe_fee:0000009c $d
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:2251   .text.fee_fbe:00000000 $t
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:2256   .text.fee_fbe:00000000 fee_fbe
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:2336   .text.fee_fbe:00000058 $d
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:2341   .text.fbe_fbi:00000000 $t
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:2346   .text.fbe_fbi:00000000 fbe_fbi
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:2623   .text.fbe_fbi:0000014c $d
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:2632   .text.fbi_fbe:00000000 $t
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:2637   .text.fbi_fbe:00000000 fbi_fbe
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:2958   .text.fbi_fbe:00000178 $d
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:2977   .text.fbi_blpi:00000000 $t
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:2982   .text.fbi_blpi:00000000 fbi_blpi
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:3051   .text.fbi_blpi:00000044 $d
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:3056   .text.blpi_fbi:00000000 $t
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:3061   .text.blpi_fbi:00000000 blpi_fbi
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:3129   .text.blpi_fbi:00000044 $d
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:3134   .text.fee_fbi:00000000 $t
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:3139   .text.fee_fbi:00000000 fee_fbi
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:3391   .text.fee_fbi:0000013c $d
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:3400   .text.fei_fbi:00000000 $t
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:3405   .text.fei_fbi:00000000 fei_fbi
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:3635   .text.fei_fbi:00000108 $d
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:3644   .text.fei_fee:00000000 $t
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:3649   .text.fei_fee:00000000 fei_fee
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:3985   .text.fei_fee:00000180 $d
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:4003   .text.fee_fei:00000000 $t
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:4008   .text.fee_fei:00000000 fee_fei
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:4122   .text.fee_fei:00000078 $d
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:4129   .text.fll_freq:00000000 $t
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:4134   .text.fll_freq:00000000 fll_freq
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:4167   .text.fll_freq:00000018 $d
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:4172   .text.fbi_fei:00000000 $t
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:4177   .text.fbi_fei:00000000 fbi_fei
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:4321   .text.fbi_fei:000000a4 $d
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:4328   .text.fbi_fee:00000000 $t
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:4333   .text.fbi_fee:00000000 fbi_fee
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:4691   .text.fbi_fee:000001b4 $d
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:4710   .text.fbe_fei:00000000 $t
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:4715   .text.fbe_fei:00000000 fbe_fei
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:4870   .text.fbe_fei:000000ac $d
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:4877   .text.what_mcg_mode:00000000 $t
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:4882   .text.what_mcg_mode:00000000 what_mcg_mode
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:5093   .text.what_mcg_mode:000000fc $d
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:5103   .text.atc:00000000 $t
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:5108   .text.atc:00000000 atc
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:5430   .text.atc:0000017c $d
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:5446   .text.clk_monitor_0:00000000 $t
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:5451   .text.clk_monitor_0:00000000 clk_monitor_0
C:\Users\BENTR_~1\AppData\Local\Temp\ccpmDAdf.s:5487   .text.clk_monitor_0:0000001c $d
                            *COM*:00000001 dmx32_val
                            *COM*:00000001 drs_val
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
__aeabi_idiv
__aeabi_uidiv
__aeabi_i2f
__aeabi_fdiv
__aeabi_fmul
__aeabi_f2uiz
